; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\adler32.c
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+247
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 011101H
	DD	02211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32_combine_
_TEXT	SEGMENT
sum1$ = 0
rem$ = 4
sum2$ = 8
adler1$ = 32
adler2$ = 40
len2$ = 48
adler32_combine_ PROC					; COMDAT

; 135  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 136  :     unsigned long sum1;
; 137  :     unsigned long sum2;
; 138  :     unsigned rem;
; 139  : 
; 140  :     /* the derivation of this formula is left as an exercise for the reader */
; 141  :     rem = (unsigned)(len2 % BASE);

  00011	33 d2		 xor	 edx, edx
  00013	8b 44 24 30	 mov	 eax, DWORD PTR len2$[rsp]
  00017	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0001c	f7 f1		 div	 ecx
  0001e	89 54 24 04	 mov	 DWORD PTR rem$[rsp], edx

; 142  :     sum1 = adler1 & 0xffff;

  00022	8b 44 24 20	 mov	 eax, DWORD PTR adler1$[rsp]
  00026	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002b	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax

; 143  :     sum2 = rem * sum1;

  0002e	8b 44 24 04	 mov	 eax, DWORD PTR rem$[rsp]
  00032	0f af 04 24	 imul	 eax, DWORD PTR sum1$[rsp]
  00036	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax

; 144  :     MOD(sum2);

  0003a	33 d2		 xor	 edx, edx
  0003c	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  00040	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00045	f7 f1		 div	 ecx
  00047	89 54 24 08	 mov	 DWORD PTR sum2$[rsp], edx

; 145  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  0004b	8b 4c 24 28	 mov	 ecx, DWORD PTR adler2$[rsp]
  0004f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00055	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  00058	8d 84 08 f0 ff
	00 00		 lea	 eax, DWORD PTR [rax+rcx+65520]
  0005f	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax

; 146  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00062	8b 4c 24 20	 mov	 ecx, DWORD PTR adler1$[rsp]
  00066	c1 e9 10	 shr	 ecx, 16
  00069	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0006f	8b 44 24 28	 mov	 eax, DWORD PTR adler2$[rsp]
  00073	c1 e8 10	 shr	 eax, 16
  00076	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007b	8d 8c 01 f1 ff
	00 00		 lea	 ecx, DWORD PTR [rcx+rax+65521]
  00082	2b 4c 24 04	 sub	 ecx, DWORD PTR rem$[rsp]
  00086	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  0008a	03 c1		 add	 eax, ecx
  0008c	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax

; 147  :     if (sum1 >= BASE) sum1 -= BASE;

  00090	81 3c 24 f1 ff
	00 00		 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  00097	72 0b		 jb	 SHORT $LN4@adler32_co
  00099	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  0009c	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000a1	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax
$LN4@adler32_co:

; 148  :     if (sum1 >= BASE) sum1 -= BASE;

  000a4	81 3c 24 f1 ff
	00 00		 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  000ab	72 0b		 jb	 SHORT $LN3@adler32_co
  000ad	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  000b0	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000b5	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax
$LN3@adler32_co:

; 149  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  000b8	81 7c 24 08 e2
	ff 01 00	 cmp	 DWORD PTR sum2$[rsp], 131042 ; 0001ffe2H
  000c0	72 0d		 jb	 SHORT $LN2@adler32_co
  000c2	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  000c6	2d e2 ff 01 00	 sub	 eax, 131042		; 0001ffe2H
  000cb	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax
$LN2@adler32_co:

; 150  :     if (sum2 >= BASE) sum2 -= BASE;

  000cf	81 7c 24 08 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  000d7	72 0d		 jb	 SHORT $LN1@adler32_co
  000d9	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  000dd	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000e2	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax
$LN1@adler32_co:

; 151  :     return sum1 | (sum2 << 16);

  000e6	8b 4c 24 08	 mov	 ecx, DWORD PTR sum2$[rsp]
  000ea	c1 e1 10	 shl	 ecx, 16
  000ed	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  000f0	0b c1		 or	 eax, ecx

; 152  : }

  000f2	48 83 c4 18	 add	 rsp, 24
  000f6	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
PUBLIC	adler32
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32 DD imagerel $LN21
	DD	imagerel $LN21+1631
	DD	imagerel $unwind$adler32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32 DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32
_TEXT	SEGMENT
n$ = 0
sum2$ = 4
adler$ = 32
buf$ = 40
len$ = 48
adler32	PROC						; COMDAT

; 64   : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 65   :     unsigned long sum2;
; 66   :     unsigned n;
; 67   : 
; 68   :     /* split Adler-32 into component sums */
; 69   :     sum2 = (adler >> 16) & 0xffff;

  00012	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00016	c1 e8 10	 shr	 eax, 16
  00019	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0001e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 70   :     adler &= 0xffff;

  00022	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00026	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 71   : 
; 72   :     /* in case user likes doing a byte at a time, keep it fast */
; 73   :     if (len == 1) {

  0002f	83 7c 24 30 01	 cmp	 DWORD PTR len$[rsp], 1
  00034	75 60		 jne	 SHORT $LN18@adler32

; 74   :         adler += buf[0];

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0003b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00042	03 c1		 add	 eax, ecx
  00044	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 75   :         if (adler >= BASE)

  00048	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  00050	72 0d		 jb	 SHORT $LN17@adler32

; 76   :             adler -= BASE;

  00052	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00056	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  0005b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN17@adler32:

; 77   :         sum2 += adler;

  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00063	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00067	03 c1		 add	 eax, ecx
  00069	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 78   :         if (sum2 >= BASE)

  0006d	81 7c 24 04 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  00075	72 0d		 jb	 SHORT $LN16@adler32

; 79   :             sum2 -= BASE;

  00077	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0007b	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00080	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
$LN16@adler32:

; 80   :         return adler | (sum2 << 16);

  00084	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00088	c1 e1 10	 shl	 ecx, 16
  0008b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0008f	0b c1		 or	 eax, ecx
  00091	e9 c4 05 00 00	 jmp	 $LN19@adler32
$LN18@adler32:

; 81   :     }
; 82   : 
; 83   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 84   :     if (buf == Z_NULL)

  00096	48 83 7c 24 28
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN15@adler32

; 85   :         return 1L;

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	e9 b2 05 00 00	 jmp	 $LN19@adler32
$LN15@adler32:

; 86   : 
; 87   :     /* in case short lengths are provided, keep it somewhat fast */
; 88   :     if (len < 16) {

  000a8	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  000ad	73 7d		 jae	 SHORT $LN14@adler32
$LN13@adler32:

; 89   :         while (len--) {

  000af	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000b3	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000b7	83 e8 01	 sub	 eax, 1
  000ba	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
  000be	85 c9		 test	 ecx, ecx
  000c0	74 30		 je	 SHORT $LN12@adler32

; 90   :             adler += *buf++;

  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000c7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000ca	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  000ce	03 c1		 add	 eax, ecx
  000d0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000d9	48 83 c0 01	 add	 rax, 1
  000dd	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 91   :             sum2 += adler;

  000e2	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  000e6	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  000ea	03 c1		 add	 eax, ecx
  000ec	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 92   :         }

  000f0	eb bd		 jmp	 SHORT $LN13@adler32
$LN12@adler32:

; 93   :         if (adler >= BASE)

  000f2	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  000fa	72 0d		 jb	 SHORT $LN11@adler32

; 94   :             adler -= BASE;

  000fc	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00100	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00105	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN11@adler32:

; 95   :         MOD4(sum2);             /* only added so many BASE's */

  00109	33 d2		 xor	 edx, edx
  0010b	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0010f	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00114	f7 f1		 div	 ecx
  00116	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx

; 96   :         return adler | (sum2 << 16);

  0011a	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0011e	c1 e1 10	 shl	 ecx, 16
  00121	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00125	0b c1		 or	 eax, ecx
  00127	e9 2e 05 00 00	 jmp	 $LN19@adler32
$LN14@adler32:
$LN10@adler32:

; 97   :     }
; 98   : 
; 99   :     /* do length NMAX blocks -- requires just one modulo operation */
; 100  :     while (len >= NMAX) {

  0012c	81 7c 24 30 b0
	15 00 00	 cmp	 DWORD PTR len$[rsp], 5552 ; 000015b0H
  00134	0f 82 6b 02 00
	00		 jb	 $LN9@adler32

; 101  :         len -= NMAX;

  0013a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0013e	2d b0 15 00 00	 sub	 eax, 5552		; 000015b0H
  00143	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 102  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00147	c7 04 24 5b 01
	00 00		 mov	 DWORD PTR n$[rsp], 347	; 0000015bH
$LN8@adler32:

; 103  :         do {
; 104  :             DO16(buf);          /* 16 sums unrolled */

  0014e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00153	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00156	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0015a	03 c1		 add	 eax, ecx
  0015c	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00160	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00164	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00168	03 c1		 add	 eax, ecx
  0016a	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0016e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00173	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00177	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0017b	03 c1		 add	 eax, ecx
  0017d	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00181	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00185	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00189	03 c1		 add	 eax, ecx
  0018b	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00194	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00198	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0019c	03 c1		 add	 eax, ecx
  0019e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001a2	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001a6	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001aa	03 c1		 add	 eax, ecx
  001ac	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001b5	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001bd	03 c1		 add	 eax, ecx
  001bf	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001c3	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001c7	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001cb	03 c1		 add	 eax, ecx
  001cd	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001d6	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  001da	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001de	03 c1		 add	 eax, ecx
  001e0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001e4	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001e8	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001ec	03 c1		 add	 eax, ecx
  001ee	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001f2	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001f7	0f b6 48 05	 movzx	 ecx, BYTE PTR [rax+5]
  001fb	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001ff	03 c1		 add	 eax, ecx
  00201	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00205	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00209	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0020d	03 c1		 add	 eax, ecx
  0020f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00218	0f b6 48 06	 movzx	 ecx, BYTE PTR [rax+6]
  0021c	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00220	03 c1		 add	 eax, ecx
  00222	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00226	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0022a	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0022e	03 c1		 add	 eax, ecx
  00230	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00234	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00239	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  0023d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00241	03 c1		 add	 eax, ecx
  00243	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00247	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0024b	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0024f	03 c1		 add	 eax, ecx
  00251	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00255	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0025a	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  0025e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00262	03 c1		 add	 eax, ecx
  00264	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00268	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0026c	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00270	03 c1		 add	 eax, ecx
  00272	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00276	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0027b	0f b6 48 09	 movzx	 ecx, BYTE PTR [rax+9]
  0027f	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00283	03 c1		 add	 eax, ecx
  00285	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00289	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0028d	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00291	03 c1		 add	 eax, ecx
  00293	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0029c	0f b6 48 0a	 movzx	 ecx, BYTE PTR [rax+10]
  002a0	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002a4	03 c1		 add	 eax, ecx
  002a6	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002aa	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002ae	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002b2	03 c1		 add	 eax, ecx
  002b4	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002b8	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002bd	0f b6 48 0b	 movzx	 ecx, BYTE PTR [rax+11]
  002c1	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002c5	03 c1		 add	 eax, ecx
  002c7	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002cb	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002cf	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002d3	03 c1		 add	 eax, ecx
  002d5	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002d9	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002de	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  002e2	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002e6	03 c1		 add	 eax, ecx
  002e8	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002ec	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002f0	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002f4	03 c1		 add	 eax, ecx
  002f6	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002fa	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002ff	0f b6 48 0d	 movzx	 ecx, BYTE PTR [rax+13]
  00303	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00307	03 c1		 add	 eax, ecx
  00309	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0030d	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00311	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00315	03 c1		 add	 eax, ecx
  00317	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0031b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00320	0f b6 48 0e	 movzx	 ecx, BYTE PTR [rax+14]
  00324	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00328	03 c1		 add	 eax, ecx
  0032a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0032e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00332	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00336	03 c1		 add	 eax, ecx
  00338	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0033c	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00341	0f b6 48 0f	 movzx	 ecx, BYTE PTR [rax+15]
  00345	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00349	03 c1		 add	 eax, ecx
  0034b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0034f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00353	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00357	03 c1		 add	 eax, ecx
  00359	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 105  :             buf += 16;

  0035d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00362	48 83 c0 10	 add	 rax, 16
  00366	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 106  :         } while (--n);

  0036b	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0036e	83 e8 01	 sub	 eax, 1
  00371	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00374	83 3c 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00378	0f 85 d0 fd ff
	ff		 jne	 $LN8@adler32

; 107  :         MOD(adler);

  0037e	33 d2		 xor	 edx, edx
  00380	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00384	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00389	f7 f1		 div	 ecx
  0038b	89 54 24 20	 mov	 DWORD PTR adler$[rsp], edx

; 108  :         MOD(sum2);

  0038f	33 d2		 xor	 edx, edx
  00391	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00395	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0039a	f7 f1		 div	 ecx
  0039c	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx

; 109  :     }

  003a0	e9 87 fd ff ff	 jmp	 $LN10@adler32
$LN9@adler32:

; 110  : 
; 111  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 112  :     if (len) {                  /* avoid modulos if none remaining */

  003a5	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  003aa	0f 84 9d 02 00
	00		 je	 $LN5@adler32
$LN4@adler32:

; 113  :         while (len >= 16) {

  003b0	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  003b5	0f 82 2d 02 00
	00		 jb	 $LN3@adler32

; 114  :             len -= 16;

  003bb	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  003bf	83 e8 10	 sub	 eax, 16
  003c2	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 115  :             DO16(buf);

  003c6	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  003cb	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003ce	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003d2	03 c1		 add	 eax, ecx
  003d4	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  003d8	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  003dc	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  003e0	03 c1		 add	 eax, ecx
  003e2	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  003e6	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  003eb	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  003ef	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003f3	03 c1		 add	 eax, ecx
  003f5	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  003f9	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  003fd	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00401	03 c1		 add	 eax, ecx
  00403	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00407	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0040c	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00410	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00414	03 c1		 add	 eax, ecx
  00416	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0041a	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0041e	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00422	03 c1		 add	 eax, ecx
  00424	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00428	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0042d	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00431	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00435	03 c1		 add	 eax, ecx
  00437	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0043b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0043f	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00443	03 c1		 add	 eax, ecx
  00445	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00449	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0044e	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00452	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00456	03 c1		 add	 eax, ecx
  00458	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0045c	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00460	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00464	03 c1		 add	 eax, ecx
  00466	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0046a	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0046f	0f b6 48 05	 movzx	 ecx, BYTE PTR [rax+5]
  00473	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00477	03 c1		 add	 eax, ecx
  00479	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0047d	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00481	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00485	03 c1		 add	 eax, ecx
  00487	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0048b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00490	0f b6 48 06	 movzx	 ecx, BYTE PTR [rax+6]
  00494	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00498	03 c1		 add	 eax, ecx
  0049a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0049e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004a2	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004a6	03 c1		 add	 eax, ecx
  004a8	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004ac	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004b1	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  004b5	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004b9	03 c1		 add	 eax, ecx
  004bb	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004bf	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004c3	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004c7	03 c1		 add	 eax, ecx
  004c9	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004cd	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004d2	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  004d6	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004da	03 c1		 add	 eax, ecx
  004dc	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004e0	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004e4	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004e8	03 c1		 add	 eax, ecx
  004ea	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004ee	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004f3	0f b6 48 09	 movzx	 ecx, BYTE PTR [rax+9]
  004f7	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004fb	03 c1		 add	 eax, ecx
  004fd	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00501	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00505	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00509	03 c1		 add	 eax, ecx
  0050b	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0050f	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00514	0f b6 48 0a	 movzx	 ecx, BYTE PTR [rax+10]
  00518	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0051c	03 c1		 add	 eax, ecx
  0051e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00522	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00526	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0052a	03 c1		 add	 eax, ecx
  0052c	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00530	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00535	0f b6 48 0b	 movzx	 ecx, BYTE PTR [rax+11]
  00539	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0053d	03 c1		 add	 eax, ecx
  0053f	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00543	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00547	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0054b	03 c1		 add	 eax, ecx
  0054d	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00551	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00556	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  0055a	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0055e	03 c1		 add	 eax, ecx
  00560	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00564	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00568	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0056c	03 c1		 add	 eax, ecx
  0056e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00572	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00577	0f b6 48 0d	 movzx	 ecx, BYTE PTR [rax+13]
  0057b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0057f	03 c1		 add	 eax, ecx
  00581	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00585	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00589	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0058d	03 c1		 add	 eax, ecx
  0058f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00593	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00598	0f b6 48 0e	 movzx	 ecx, BYTE PTR [rax+14]
  0059c	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005a0	03 c1		 add	 eax, ecx
  005a2	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005a6	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005aa	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  005ae	03 c1		 add	 eax, ecx
  005b0	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  005b4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005b9	0f b6 48 0f	 movzx	 ecx, BYTE PTR [rax+15]
  005bd	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005c1	03 c1		 add	 eax, ecx
  005c3	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005c7	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005cb	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  005cf	03 c1		 add	 eax, ecx
  005d1	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 116  :             buf += 16;

  005d5	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005da	48 83 c0 10	 add	 rax, 16
  005de	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 117  :         }

  005e3	e9 c8 fd ff ff	 jmp	 $LN4@adler32
$LN3@adler32:
$LN2@adler32:

; 118  :         while (len--) {

  005e8	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  005ec	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  005f0	83 e8 01	 sub	 eax, 1
  005f3	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
  005f7	85 c9		 test	 ecx, ecx
  005f9	74 30		 je	 SHORT $LN1@adler32

; 119  :             adler += *buf++;

  005fb	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00600	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00603	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00607	03 c1		 add	 eax, ecx
  00609	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0060d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00612	48 83 c0 01	 add	 rax, 1
  00616	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 120  :             sum2 += adler;

  0061b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0061f	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00623	03 c1		 add	 eax, ecx
  00625	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 121  :         }

  00629	eb bd		 jmp	 SHORT $LN2@adler32
$LN1@adler32:

; 122  :         MOD(adler);

  0062b	33 d2		 xor	 edx, edx
  0062d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00631	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00636	f7 f1		 div	 ecx
  00638	89 54 24 20	 mov	 DWORD PTR adler$[rsp], edx

; 123  :         MOD(sum2);

  0063c	33 d2		 xor	 edx, edx
  0063e	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00642	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00647	f7 f1		 div	 ecx
  00649	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx
$LN5@adler32:

; 124  :     }
; 125  : 
; 126  :     /* return recombined sums */
; 127  :     return adler | (sum2 << 16);

  0064d	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00651	c1 e1 10	 shl	 ecx, 16
  00654	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00658	0b c1		 or	 eax, ecx
$LN19@adler32:

; 128  : }

  0065a	48 83 c4 18	 add	 rsp, 24
  0065e	c3		 ret	 0
adler32	ENDP
PUBLIC	adler32_combine
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$adler32_combine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine DD 011101H
	DD	04211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 48
adler2$ = 56
len2$ = 64
adler32_combine PROC					; COMDAT

; 159  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 160  :     return adler32_combine_(adler1, adler2, len2);

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR len2$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR adler2$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR adler1$[rsp]
  0001e	e8 00 00 00 00	 call	 adler32_combine_

; 161  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
adler32_combine ENDP
END
