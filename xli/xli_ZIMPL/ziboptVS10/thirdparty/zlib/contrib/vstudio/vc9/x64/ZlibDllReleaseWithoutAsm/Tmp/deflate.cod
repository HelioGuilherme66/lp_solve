; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	deflate_copyright
EXTRN	memset:PROC
EXTRN	memcpy:PROC
?my_version@?1??deflateInit2_@@9@9 DB '1.2.5', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+10
deflate_copyright DB ' deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly'
	DB	' and Mark Adler ', 00H
	ORG $+12
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\deflate.c
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+1114
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT longest_match
_TEXT	SEGMENT
best_len$ = 0
chain_length$ = 4
scan_end1$ = 8
prev$ = 16
scan_end$ = 24
len$ = 28
scan$ = 32
strend$ = 40
match$ = 48
limit$ = 56
nice_match$ = 60
wmask$ = 64
tv79 = 68
s$ = 96
cur_match$ = 104
longest_match PROC					; COMDAT

; 1066 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1067 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00012	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [rax+164]
  00018	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax

; 1068 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00021	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00030	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1069 :     register Bytef *match;                       /* matched string */
; 1070 :     register int len;                           /* length of current match */
; 1071 :     int best_len = s->prev_length;              /* best match length so far */

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00040	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1072 :     int nice_match = s->nice_match;             /* stop if match long enough */

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00048	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  0004e	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax

; 1073 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
; 1074 :         s->strstart - (IPos)MAX_DIST(s) : NIL;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00057	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  0005a	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  00060	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00065	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  0006b	76 21		 jbe	 SHORT $LN18@longest_ma
  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00072	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00075	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00080	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00086	2b c1		 sub	 eax, ecx
  00088	89 44 24 44	 mov	 DWORD PTR tv79[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN19@longest_ma
$LN18@longest_ma:
  0008e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN19@longest_ma:
  00096	8b 44 24 44	 mov	 eax, DWORD PTR tv79[rsp]
  0009a	89 44 24 38	 mov	 DWORD PTR limit$[rsp], eax

; 1075 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1076 :      * we prevent matches with the string of window index 0.
; 1077 :      */
; 1078 :     Posf *prev = s->prev;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a7	48 89 44 24 10	 mov	 QWORD PTR prev$[rsp], rax

; 1079 :     uInt wmask = s->w_mask;

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000b4	89 44 24 40	 mov	 DWORD PTR wmask$[rsp], eax

; 1080 : 
; 1081 : #ifdef UNALIGNED_OK
; 1082 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1083 :      * Try with and without -DUNALIGNED_OK to check.
; 1084 :      */
; 1085 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1086 :     register ush scan_start = *(ushf*)scan;
; 1087 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1088 : #else
; 1089 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000bd	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000cc	48 8d 84 08 02
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+258]
  000d4	48 89 44 24 28	 mov	 QWORD PTR strend$[rsp], rax

; 1090 :     register Byte scan_end1  = scan[best_len-1];

  000d9	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  000dc	83 e8 01	 sub	 eax, 1
  000df	48 63 c8	 movsxd	 rcx, eax
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  000e7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000eb	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1091 :     register Byte scan_end   = scan[best_len];

  000ef	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  000f8	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000fc	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al

; 1092 : #endif
; 1093 : 
; 1094 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1095 :      * It is easy to get rid of this optimization if necessary.
; 1096 :      */
; 1097 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1098 : 
; 1099 :     /* Do not waste too much time if we already have a good match: */
; 1100 :     if (s->prev_length >= s->good_match) {

  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0010a	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00110	39 81 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], eax
  00116	72 0b		 jb	 SHORT $LN15@longest_ma

; 1101 :         chain_length >>= 2;

  00118	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  0011c	c1 e8 02	 shr	 eax, 2
  0011f	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
$LN15@longest_ma:

; 1102 :     }
; 1103 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1104 :      * to make deflate deterministic.
; 1105 :      */
; 1106 :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00128	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0012e	39 44 24 3c	 cmp	 DWORD PTR nice_match$[rsp], eax
  00132	76 0f		 jbe	 SHORT $LN14@longest_ma
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00139	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0013f	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax
$LN14@longest_ma:
$LN13@longest_ma:

; 1107 : 
; 1108 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1109 : 
; 1110 :     do {
; 1111 :         Assert(cur_match < s->strstart, "no future");
; 1112 :         match = s->window + cur_match;

  00143	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00150	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax

; 1113 : 
; 1114 :         /* Skip to next match if the match length cannot increase
; 1115 :          * or if the match length is less than 2.  Note that the checks below
; 1116 :          * for insufficient lookahead only occur occasionally for performance
; 1117 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1118 :          * conditional jumps will be made that depend on those values.
; 1119 :          * However the length of the match is limited to the lookahead, so
; 1120 :          * the output of deflate is not affected by the uninitialized values.
; 1121 :          */
; 1122 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1123 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1124 :          * UNALIGNED_OK if your compiler uses a different size.
; 1125 :          */
; 1126 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1127 :             *(ushf*)match != scan_start) continue;
; 1128 : 
; 1129 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1130 :          * always equal when the other bytes match, given that the hash keys
; 1131 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1132 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1133 :          * lookahead only every 4th comparison; the 128th check will be made
; 1134 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1135 :          * necessary to put more guard bytes at the end of the window, or
; 1136 :          * to check more often for insufficient lookahead.
; 1137 :          */
; 1138 :         Assert(scan[2] == match[2], "scan[2]?");
; 1139 :         scan++, match++;
; 1140 :         do {
; 1141 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1142 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1143 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1144 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1145 :                  scan < strend);
; 1146 :         /* The funny "do {}" generates better code on most compilers */
; 1147 : 
; 1148 :         /* Here, scan <= window+strstart+257 */
; 1149 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1150 :         if (*scan == *match) scan++;
; 1151 : 
; 1152 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1153 :         scan = strend - (MAX_MATCH-1);
; 1154 : 
; 1155 : #else /* UNALIGNED_OK */
; 1156 : 
; 1157 :         if (match[best_len]   != scan_end  ||
; 1158 :             match[best_len-1] != scan_end1 ||
; 1159 :             *match            != *scan     ||
; 1160 :             *++match          != scan[1])      continue;

  00155	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  00159	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0015e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00162	0f b6 44 24 18	 movzx	 eax, BYTE PTR scan_end$[rsp]
  00167	3b c8		 cmp	 ecx, eax
  00169	75 52		 jne	 SHORT $LN9@longest_ma
  0016b	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  0016e	83 e8 01	 sub	 eax, 1
  00171	48 63 c8	 movsxd	 rcx, eax
  00174	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00179	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0017d	0f b6 44 24 08	 movzx	 eax, BYTE PTR scan_end1$[rsp]
  00182	3b c8		 cmp	 ecx, eax
  00184	75 37		 jne	 SHORT $LN9@longest_ma
  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0018b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0018e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00193	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00196	3b c8		 cmp	 ecx, eax
  00198	75 23		 jne	 SHORT $LN9@longest_ma
  0019a	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0019f	48 83 c0 01	 add	 rax, 1
  001a3	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001ad	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001b5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001b9	3b c8		 cmp	 ecx, eax
  001bb	74 05		 je	 SHORT $LN10@longest_ma
$LN9@longest_ma:
  001bd	e9 3a 02 00 00	 jmp	 $LN12@longest_ma
$LN10@longest_ma:

; 1161 : 
; 1162 :         /* The check at best_len-1 can be removed because it will be made
; 1163 :          * again later. (This heuristic is not always a win.)
; 1164 :          * It is not necessary to compare scan[2] and match[2] since they
; 1165 :          * are always equal when the other bytes match, given that
; 1166 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1167 :          */
; 1168 :         scan += 2, match++;

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001c7	48 83 c0 02	 add	 rax, 2
  001cb	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001d0	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001d5	48 83 c0 01	 add	 rax, 1
  001d9	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
$LN8@longest_ma:

; 1169 :         Assert(*scan == *match, "match[2]?");
; 1170 : 
; 1171 :         /* We check for insufficient lookahead only every 8th comparison;
; 1172 :          * the 256th check will be made at strstart+258.
; 1173 :          */
; 1174 :         do {
; 1175 :         } while (*++scan == *++match && *++scan == *++match &&
; 1176 :                  *++scan == *++match && *++scan == *++match &&
; 1177 :                  *++scan == *++match && *++scan == *++match &&
; 1178 :                  *++scan == *++match && *++scan == *++match &&
; 1179 :                  scan < strend);

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001e3	48 83 c0 01	 add	 rax, 1
  001e7	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001ec	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001f1	48 83 c0 01	 add	 rax, 1
  001f5	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001ff	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00202	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	3b c1		 cmp	 eax, ecx
  0020c	0f 85 70 01 00
	00		 jne	 $LN5@longest_ma
  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00217	48 83 c0 01	 add	 rax, 1
  0021b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00220	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00225	48 83 c0 01	 add	 rax, 1
  00229	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00233	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00236	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0023b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023e	3b c1		 cmp	 eax, ecx
  00240	0f 85 3c 01 00
	00		 jne	 $LN5@longest_ma
  00246	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0024b	48 83 c0 01	 add	 rax, 1
  0024f	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00254	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00259	48 83 c0 01	 add	 rax, 1
  0025d	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00262	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00267	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0026a	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0026f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00272	3b c1		 cmp	 eax, ecx
  00274	0f 85 08 01 00
	00		 jne	 $LN5@longest_ma
  0027a	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0027f	48 83 c0 01	 add	 rax, 1
  00283	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00288	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0028d	48 83 c0 01	 add	 rax, 1
  00291	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00296	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0029b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0029e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a6	3b c1		 cmp	 eax, ecx
  002a8	0f 85 d4 00 00
	00		 jne	 $LN5@longest_ma
  002ae	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002b3	48 83 c0 01	 add	 rax, 1
  002b7	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002bc	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002c1	48 83 c0 01	 add	 rax, 1
  002c5	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002ca	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002cf	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002d2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002da	3b c1		 cmp	 eax, ecx
  002dc	0f 85 a0 00 00
	00		 jne	 $LN5@longest_ma
  002e2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002e7	48 83 c0 01	 add	 rax, 1
  002eb	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002f0	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002f5	48 83 c0 01	 add	 rax, 1
  002f9	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002fe	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00303	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00306	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0030b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030e	3b c1		 cmp	 eax, ecx
  00310	75 70		 jne	 SHORT $LN5@longest_ma
  00312	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00317	48 83 c0 01	 add	 rax, 1
  0031b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00320	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00325	48 83 c0 01	 add	 rax, 1
  00329	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0032e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00333	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00336	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0033b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0033e	3b c1		 cmp	 eax, ecx
  00340	75 40		 jne	 SHORT $LN5@longest_ma
  00342	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00347	48 83 c0 01	 add	 rax, 1
  0034b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00350	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00355	48 83 c0 01	 add	 rax, 1
  00359	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0035e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00363	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00366	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0036b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0036e	3b c1		 cmp	 eax, ecx
  00370	75 10		 jne	 SHORT $LN5@longest_ma
  00372	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  00377	48 39 44 24 20	 cmp	 QWORD PTR scan$[rsp], rax
  0037c	0f 82 5c fe ff
	ff		 jb	 $LN8@longest_ma
$LN5@longest_ma:

; 1180 : 
; 1181 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1182 : 
; 1183 :         len = MAX_MATCH - (int)(strend - scan);

  00382	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00387	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strend$[rsp]
  0038c	48 2b c8	 sub	 rcx, rax
  0038f	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00394	2b c1		 sub	 eax, ecx
  00396	89 44 24 1c	 mov	 DWORD PTR len$[rsp], eax

; 1184 :         scan = strend - MAX_MATCH;

  0039a	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  0039f	48 2d 02 01 00
	00		 sub	 rax, 258		; 00000102H
  003a5	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1185 : 
; 1186 : #endif /* UNALIGNED_OK */
; 1187 : 
; 1188 :         if (len > best_len) {

  003aa	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  003ad	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003b1	7e 49		 jle	 SHORT $LN4@longest_ma

; 1189 :             s->match_start = cur_match;

  003b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003b8	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  003bc	89 81 98 00 00
	00		 mov	 DWORD PTR [rcx+152], eax

; 1190 :             best_len = len;

  003c2	8b 44 24 1c	 mov	 eax, DWORD PTR len$[rsp]
  003c6	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1191 :             if (len >= nice_match) break;

  003c9	8b 44 24 3c	 mov	 eax, DWORD PTR nice_match$[rsp]
  003cd	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003d1	7c 02		 jl	 SHORT $LN3@longest_ma
  003d3	eb 60		 jmp	 SHORT $LN11@longest_ma
$LN3@longest_ma:

; 1192 : #ifdef UNALIGNED_OK
; 1193 :             scan_end = *(ushf*)(scan+best_len-1);
; 1194 : #else
; 1195 :             scan_end1  = scan[best_len-1];

  003d5	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  003d8	83 e8 01	 sub	 eax, 1
  003db	48 63 c8	 movsxd	 rcx, eax
  003de	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  003e3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003e7	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1196 :             scan_end   = scan[best_len];

  003eb	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  003ef	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  003f4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003f8	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al
$LN4@longest_ma:
$LN12@longest_ma:

; 1197 : #endif
; 1198 :         }
; 1199 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1200 :              && --chain_length != 0);

  003fc	8b 4c 24 40	 mov	 ecx, DWORD PTR wmask$[rsp]
  00400	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  00404	23 c1		 and	 eax, ecx
  00406	8b c8		 mov	 ecx, eax
  00408	48 8b 44 24 10	 mov	 rax, QWORD PTR prev$[rsp]
  0040d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00411	89 44 24 68	 mov	 DWORD PTR cur_match$[rsp], eax
  00415	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00419	39 44 24 68	 cmp	 DWORD PTR cur_match$[rsp], eax
  0041d	76 16		 jbe	 SHORT $LN2@longest_ma
  0041f	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  00423	83 e8 01	 sub	 eax, 1
  00426	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
  0042a	83 7c 24 04 00	 cmp	 DWORD PTR chain_length$[rsp], 0
  0042f	0f 85 0e fd ff
	ff		 jne	 $LN13@longest_ma
$LN2@longest_ma:
$LN11@longest_ma:

; 1201 : 
; 1202 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

  00435	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0043a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00440	39 04 24	 cmp	 DWORD PTR best_len$[rsp], eax
  00443	77 05		 ja	 SHORT $LN1@longest_ma
  00445	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  00448	eb 0b		 jmp	 SHORT $LN16@longest_ma
$LN1@longest_ma:

; 1203 :     return s->lookahead;

  0044a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0044f	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
$LN16@longest_ma:

; 1204 : }

  00455	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00459	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+350
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1024 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1025 :     s->window_size = (ulg)2L*s->w_size;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00011	d1 e1		 shl	 ecx, 1
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00018	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 1026 : 
; 1027 :     CLEAR_HASH(s);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00020	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00023	83 e8 01	 sub	 eax, 1
  00026	8b d0		 mov	 edx, eax
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00031	33 c0		 xor	 eax, eax
  00033	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0003c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0003f	83 e8 01	 sub	 eax, 1
  00042	44 8b c0	 mov	 r8d, eax
  00045	49 d1 e0	 shl	 r8, 1
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00053	e8 00 00 00 00	 call	 memset

; 1028 : 
; 1029 :     /* Set the default configuration parameters:
; 1030 :      */
; 1031 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00058	4c 8b 5c 24 30	 mov	 r11, QWORD PTR s$[rsp]
  0005d	49 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [r11+172]
  00064	48 6b c9 10	 imul	 rcx, 16
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0006f	0f b7 4c 08 02	 movzx	 ecx, WORD PTR [rax+rcx+2]
  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00079	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 1032 :     s->good_match       = configuration_table[s->level].good_length;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00084	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  0008b	48 6b c9 10	 imul	 rcx, 16
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00096	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0009f	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 1033 :     s->nice_match       = configuration_table[s->level].nice_length;

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  000b1	48 6b c9 10	 imul	 rcx, 16
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000bc	0f b7 4c 08 04	 movzx	 ecx, WORD PTR [rax+rcx+4]
  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000c6	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 1034 :     s->max_chain_length = configuration_table[s->level].max_chain;

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000d1	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  000d8	48 6b c9 10	 imul	 rcx, 16
  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000e3	0f b7 4c 08 06	 movzx	 ecx, WORD PTR [rax+rcx+6]
  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000ed	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx

; 1035 : 
; 1036 :     s->strstart = 0;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f8	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 1037 :     s->block_start = 0L;

  00102	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00107	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1038 :     s->lookahead = 0;

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00116	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1039 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00125	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+160], 2
  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00134	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1040 :     s->match_available = 0;

  0013e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00143	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1041 :     s->ins_h = 0;

  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00152	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1042 : #ifndef FASTEST
; 1043 : #ifdef ASMV
; 1044 :     match_init(); /* initialize the asm code */
; 1045 : #endif
; 1046 : #endif
; 1047 : }

  00159	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0015d	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
PUBLIC	deflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateEnd
_TEXT	SEGMENT
status$ = 32
tv151 = 36
strm$ = 64
deflateEnd PROC						; COMDAT

; 897  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@deflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@deflateEnd
$LN6@deflateEnd:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 4a 01 00 00	 jmp	 $LN8@deflateEnd
$LN7@deflateEnd:

; 901  : 
; 902  :     status = strm->state->status;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00033	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 903  :     if (status != INIT_STATE &&
; 904  :         status != EXTRA_STATE &&
; 905  :         status != NAME_STATE &&
; 906  :         status != COMMENT_STATE &&
; 907  :         status != HCRC_STATE &&
; 908  :         status != BUSY_STATE &&
; 909  :         status != FINISH_STATE) {

  00037	83 7c 24 20 2a	 cmp	 DWORD PTR status$[rsp], 42 ; 0000002aH
  0003c	74 37		 je	 SHORT $LN5@deflateEnd
  0003e	83 7c 24 20 45	 cmp	 DWORD PTR status$[rsp], 69 ; 00000045H
  00043	74 30		 je	 SHORT $LN5@deflateEnd
  00045	83 7c 24 20 49	 cmp	 DWORD PTR status$[rsp], 73 ; 00000049H
  0004a	74 29		 je	 SHORT $LN5@deflateEnd
  0004c	83 7c 24 20 5b	 cmp	 DWORD PTR status$[rsp], 91 ; 0000005bH
  00051	74 22		 je	 SHORT $LN5@deflateEnd
  00053	83 7c 24 20 67	 cmp	 DWORD PTR status$[rsp], 103 ; 00000067H
  00058	74 1b		 je	 SHORT $LN5@deflateEnd
  0005a	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  0005f	74 14		 je	 SHORT $LN5@deflateEnd
  00061	81 7c 24 20 9a
	02 00 00	 cmp	 DWORD PTR status$[rsp], 666 ; 0000029aH
  00069	74 0a		 je	 SHORT $LN5@deflateEnd

; 910  :       return Z_STREAM_ERROR;

  0006b	b8 fe ff ff ff	 mov	 eax, -2
  00070	e9 fc 00 00 00	 jmp	 $LN8@deflateEnd
$LN5@deflateEnd:

; 911  :     }
; 912  : 
; 913  :     /* Deallocate in reverse order of allocations: */
; 914  :     TRY_FREE(strm, strm->state->pending_buf);

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00083	74 1e		 je	 SHORT $LN4@deflateEnd
  00085	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0008a	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0008e	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00097	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a0	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@deflateEnd:

; 915  :     TRY_FREE(strm, strm->state->head);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ac	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000b1	74 1e		 je	 SHORT $LN3@deflateEnd
  000b3	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000b8	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  000bc	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000c5	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ce	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@deflateEnd:

; 916  :     TRY_FREE(strm, strm->state->prev);

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000da	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000df	74 1e		 je	 SHORT $LN2@deflateEnd
  000e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000e6	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  000ea	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f3	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fc	ff 50 38	 call	 QWORD PTR [rax+56]
$LN2@deflateEnd:

; 917  :     TRY_FREE(strm, strm->state->window);

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00104	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00108	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0010d	74 1e		 je	 SHORT $LN1@deflateEnd
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00114	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00118	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00121	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0012a	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@deflateEnd:

; 918  : 
; 919  :     ZFREE(strm, strm->state);

  0012d	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00132	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0013b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00144	ff 50 38	 call	 QWORD PTR [rax+56]

; 920  :     strm->state = Z_NULL;

  00147	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  0014c	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 921  : 
; 922  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00154	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  00159	75 0a		 jne	 SHORT $LN10@deflateEnd
  0015b	c7 44 24 24 fd
	ff ff ff	 mov	 DWORD PTR tv151[rsp], -3
  00163	eb 08		 jmp	 SHORT $LN11@deflateEnd
$LN10@deflateEnd:
  00165	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN11@deflateEnd:
  0016d	8b 44 24 24	 mov	 eax, DWORD PTR tv151[rsp]
$LN8@deflateEnd:

; 923  : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+265
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT flush_pending
_TEXT	SEGMENT
len$ = 32
strm$ = 64
flush_pending PROC					; COMDAT

; 564  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 565  :     unsigned len = strm->state->pending;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0000e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00012	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00015	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 566  : 
; 567  :     if (len > strm->avail_out) len = strm->avail_out;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0001e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00021	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00025	76 0c		 jbe	 SHORT $LN3@flush_pend
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002f	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN3@flush_pend:

; 568  :     if (len == 0) return;

  00033	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00038	75 05		 jne	 SHORT $LN2@flush_pend
  0003a	e9 c5 00 00 00	 jmp	 $LN4@flush_pend
$LN2@flush_pend:

; 569  : 
; 570  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  0003f	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00044	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00049	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0004d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00056	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0005a	e8 00 00 00 00	 call	 memcpy

; 571  :     strm->next_out  += len;

  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00068	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 572  :     strm->state->pending_out  += len;

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00082	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 573  :     strm->total_out += len;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00098	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0009b	03 4c 24 20	 add	 ecx, DWORD PTR len$[rsp]
  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a4	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 574  :     strm->avail_out  -= len;

  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000ac	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000b0	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000b3	2b c8		 sub	 ecx, eax
  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ba	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 575  :     strm->state->pending -= len;

  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000c2	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000c6	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000ca	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000cd	2b c8		 sub	 ecx, eax
  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000d8	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 576  :     if (strm->state->pending == 0) {

  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e4	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000e8	75 1a		 jne	 SHORT $LN1@flush_pend

; 577  :         strm->state->pending_out = strm->state->pending_buf;

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ef	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00100	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN1@flush_pend:
$LN4@flush_pend:

; 578  :     }
; 579  : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
flush_pending ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 551  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 552  :     put_byte(s, (Byte)(b >> 8));

  00009	8b 54 24 10	 mov	 edx, DWORD PTR b$[rsp]
  0000d	c1 ea 08	 shr	 edx, 8
  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00015	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00018	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00029	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00034	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 553  :     put_byte(s, (Byte)(b & 0xff));

  00037	8b 54 24 10	 mov	 edx, DWORD PTR b$[rsp]
  0003b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00046	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0004e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00052	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00055	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0005a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0005d	83 c1 01	 add	 ecx, 1
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00065	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 554  : }

  00068	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
PUBLIC	deflateBound
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN26
	DD	imagerel $LN26+485
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateBound
_TEXT	SEGMENT
s$ = 0
complen$ = 8
wraplen$ = 12
str$ = 16
tv77 = 24
tv80 = 28
strm$ = 48
sourceLen$ = 56
deflateBound PROC					; COMDAT

; 489  : {

$LN26:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 490  :     deflate_state *s;
; 491  :     uLong complen, wraplen;
; 492  :     Bytef *str;
; 493  : 
; 494  :     /* conservative upper bound for compressed data */
; 495  :     complen = sourceLen +
; 496  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

  0000d	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00011	83 c0 07	 add	 eax, 7
  00014	c1 e8 03	 shr	 eax, 3
  00017	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0001b	03 c8		 add	 ecx, eax
  0001d	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00021	83 c0 3f	 add	 eax, 63			; 0000003fH
  00024	c1 e8 06	 shr	 eax, 6
  00027	8d 44 01 05	 lea	 eax, DWORD PTR [rcx+rax+5]
  0002b	89 44 24 08	 mov	 DWORD PTR complen$[rsp], eax

; 497  : 
; 498  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002f	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00035	74 0c		 je	 SHORT $LN20@deflateBou
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  0003c	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00041	75 0c		 jne	 SHORT $LN21@deflateBou
$LN20@deflateBou:

; 500  :         return complen + 6;

  00043	8b 44 24 08	 mov	 eax, DWORD PTR complen$[rsp]
  00047	83 c0 06	 add	 eax, 6
  0004a	e9 91 01 00 00	 jmp	 $LN22@deflateBou
$LN21@deflateBou:

; 501  : 
; 502  :     /* compute wrapper length */
; 503  :     s = strm->state;

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00054	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00058	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 504  :     switch (s->wrap) {

  0005c	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00060	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00063	89 44 24 18	 mov	 DWORD PTR tv77[rsp], eax
  00067	83 7c 24 18 00	 cmp	 DWORD PTR tv77[rsp], 0
  0006c	74 13		 je	 SHORT $LN17@deflateBou
  0006e	83 7c 24 18 01	 cmp	 DWORD PTR tv77[rsp], 1
  00073	74 19		 je	 SHORT $LN16@deflateBou
  00075	83 7c 24 18 02	 cmp	 DWORD PTR tv77[rsp], 2
  0007a	74 41		 je	 SHORT $LN15@deflateBou
  0007c	e9 10 01 00 00	 jmp	 $LN3@deflateBou
$LN17@deflateBou:

; 505  :     case 0:                                 /* raw deflate */
; 506  :         wraplen = 0;

  00081	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 0

; 507  :         break;

  00089	e9 0b 01 00 00	 jmp	 $LN18@deflateBou
$LN16@deflateBou:

; 508  :     case 1:                                 /* zlib wrapper */
; 509  :         wraplen = 6 + (s->strstart ? 4 : 0);

  0008e	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00092	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00099	74 0a		 je	 SHORT $LN24@deflateBou
  0009b	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR tv80[rsp], 4
  000a3	eb 08		 jmp	 SHORT $LN25@deflateBou
$LN24@deflateBou:
  000a5	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN25@deflateBou:
  000ad	8b 44 24 1c	 mov	 eax, DWORD PTR tv80[rsp]
  000b1	83 c0 06	 add	 eax, 6
  000b4	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 510  :         break;

  000b8	e9 dc 00 00 00	 jmp	 $LN18@deflateBou
$LN15@deflateBou:

; 511  :     case 2:                                 /* gzip wrapper */
; 512  :         wraplen = 18;

  000bd	c7 44 24 0c 12
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 18

; 513  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  000c5	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000c9	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000ce	0f 84 bb 00 00
	00		 je	 $LN14@deflateBou

; 514  :             if (s->gzhead->extra != Z_NULL)

  000d4	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000d8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000dc	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000e1	74 17		 je	 SHORT $LN13@deflateBou

; 515  :                 wraplen += 2 + s->gzhead->extra_len;

  000e3	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000e7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000eb	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000ee	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  000f2	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  000f6	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN13@deflateBou:

; 516  :             str = s->gzhead->name;

  000fa	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000fe	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00102	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00106	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax

; 517  :             if (str != Z_NULL)

  0010b	48 83 7c 24 10
	00		 cmp	 QWORD PTR str$[rsp], 0
  00111	74 25		 je	 SHORT $LN12@deflateBou
$LN11@deflateBou:

; 518  :                 do {
; 519  :                     wraplen++;

  00113	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00117	83 c0 01	 add	 eax, 1
  0011a	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 520  :                 } while (*str++);

  0011e	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  00123	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00126	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  0012b	48 83 c0 01	 add	 rax, 1
  0012f	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax
  00134	85 c9		 test	 ecx, ecx
  00136	75 db		 jne	 SHORT $LN11@deflateBou
$LN12@deflateBou:

; 521  :             str = s->gzhead->comment;

  00138	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0013c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00140	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00144	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax

; 522  :             if (str != Z_NULL)

  00149	48 83 7c 24 10
	00		 cmp	 QWORD PTR str$[rsp], 0
  0014f	74 25		 je	 SHORT $LN8@deflateBou
$LN7@deflateBou:

; 523  :                 do {
; 524  :                     wraplen++;

  00151	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00155	83 c0 01	 add	 eax, 1
  00158	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 525  :                 } while (*str++);

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  00161	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00164	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  00169	48 83 c0 01	 add	 rax, 1
  0016d	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax
  00172	85 c9		 test	 ecx, ecx
  00174	75 db		 jne	 SHORT $LN7@deflateBou
$LN8@deflateBou:

; 526  :             if (s->gzhead->hcrc)

  00176	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0017a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0017e	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00182	74 0b		 je	 SHORT $LN4@deflateBou

; 527  :                 wraplen += 2;

  00184	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00188	83 c0 02	 add	 eax, 2
  0018b	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN4@deflateBou:
$LN14@deflateBou:

; 528  :         }
; 529  :         break;

  0018f	eb 08		 jmp	 SHORT $LN18@deflateBou
$LN3@deflateBou:

; 530  :     default:                                /* for compiler happiness */
; 531  :         wraplen = 6;

  00191	c7 44 24 0c 06
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 6
$LN18@deflateBou:

; 532  :     }
; 533  : 
; 534  :     /* if not default parameters, return conservative bound */
; 535  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  00199	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0019d	83 78 48 0f	 cmp	 DWORD PTR [rax+72], 15
  001a1	75 0a		 jne	 SHORT $LN1@deflateBou
  001a3	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  001a7	83 78 78 0f	 cmp	 DWORD PTR [rax+120], 15
  001ab	74 0c		 je	 SHORT $LN2@deflateBou
$LN1@deflateBou:

; 536  :         return complen + wraplen;

  001ad	8b 4c 24 0c	 mov	 ecx, DWORD PTR wraplen$[rsp]
  001b1	8b 44 24 08	 mov	 eax, DWORD PTR complen$[rsp]
  001b5	03 c1		 add	 eax, ecx
  001b7	eb 27		 jmp	 SHORT $LN22@deflateBou
$LN2@deflateBou:

; 537  : 
; 538  :     /* default settings: return tight bound for that case */
; 539  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  001b9	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  001bd	c1 e8 0c	 shr	 eax, 12
  001c0	8b 54 24 38	 mov	 edx, DWORD PTR sourceLen$[rsp]
  001c4	03 d0		 add	 edx, eax
  001c6	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  001ca	c1 e8 0e	 shr	 eax, 14
  001cd	03 d0		 add	 edx, eax
  001cf	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  001d3	c1 e9 19	 shr	 ecx, 25
  001d6	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  001da	03 c2		 add	 eax, edx
  001dc	8d 44 01 07	 lea	 eax, DWORD PTR [rcx+rax+7]
$LN22@deflateBou:

; 541  : }

  001e0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001e4	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
PUBLIC	deflateTune
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateTune
_TEXT	SEGMENT
s$ = 0
strm$ = 32
good_length$ = 40
max_lazy$ = 48
nice_length$ = 56
max_chain$ = 64
deflateTune PROC					; COMDAT

; 457  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0001d	74 0c		 je	 SHORT $LN1@deflateTun
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00024	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00029	75 07		 jne	 SHORT $LN2@deflateTun
$LN1@deflateTun:
  0002b	b8 fe ff ff ff	 mov	 eax, -2
  00030	eb 47		 jmp	 SHORT $LN3@deflateTun
$LN2@deflateTun:

; 461  :     s = strm->state;

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00037	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003b	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 462  :     s->good_match = good_length;

  0003f	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  00043	8b 44 24 28	 mov	 eax, DWORD PTR good_length$[rsp]
  00047	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax

; 463  :     s->max_lazy_match = max_lazy;

  0004d	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  00051	8b 44 24 30	 mov	 eax, DWORD PTR max_lazy$[rsp]
  00055	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 464  :     s->nice_match = nice_length;

  0005b	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	8b 44 24 38	 mov	 eax, DWORD PTR nice_length$[rsp]
  00063	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 465  :     s->max_chain_length = max_chain;

  00069	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	8b 44 24 40	 mov	 eax, DWORD PTR max_chain$[rsp]
  00071	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 466  :     return Z_OK;

  00077	33 c0		 xor	 eax, eax
$LN3@deflateTun:

; 467  : }

  00079	48 83 c4 18	 add	 rsp, 24
  0007d	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
PUBLIC	deflatePrime
; Function compile flags: /Odtp
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
deflatePrime PROC					; COMDAT

; 404  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000e	48 83 7c 24 08
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00014	74 0c		 je	 SHORT $LN1@deflatePri
  00016	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  0001b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00020	75 07		 jne	 SHORT $LN2@deflatePri
$LN1@deflatePri:
  00022	b8 fe ff ff ff	 mov	 eax, -2
  00027	eb 39		 jmp	 SHORT $LN3@deflatePri
$LN2@deflatePri:

; 406  :     strm->state->bi_valid = bits;

  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR strm$[rsp]
  0002e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00032	8b 44 24 10	 mov	 eax, DWORD PTR bits$[rsp]
  00036	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax

; 407  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  0003c	8b 4c 24 10	 mov	 ecx, DWORD PTR bits$[rsp]
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	d3 e0		 shl	 eax, cl
  00047	83 e8 01	 sub	 eax, 1
  0004a	8b 4c 24 18	 mov	 ecx, DWORD PTR value$[rsp]
  0004e	23 c8		 and	 ecx, eax
  00050	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  00055	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00059	66 89 88 10 17
	00 00		 mov	 WORD PTR [rax+5904], cx

; 408  :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
$LN3@deflatePri:

; 409  : }

  00062	f3 c3		 fatret	 0
deflatePrime ENDP
_TEXT	ENDS
PUBLIC	deflateSetHeader
; Function compile flags: /Odtp
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
deflateSetHeader PROC					; COMDAT

; 392  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00010	74 0c		 je	 SHORT $LN2@deflateSet
  00012	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  00017	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001c	75 07		 jne	 SHORT $LN3@deflateSet
$LN2@deflateSet:
  0001e	b8 fe ff ff ff	 mov	 eax, -2
  00023	eb 2a		 jmp	 SHORT $LN4@deflateSet
$LN3@deflateSet:

; 394  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  0002a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002e	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00032	74 07		 je	 SHORT $LN1@deflateSet
  00034	b8 fe ff ff ff	 mov	 eax, -2
  00039	eb 14		 jmp	 SHORT $LN4@deflateSet
$LN1@deflateSet:

; 395  :     strm->state->gzhead = head;

  0003b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR strm$[rsp]
  00040	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR head$[rsp]
  00049	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 396  :     return Z_OK;

  0004d	33 c0		 xor	 eax, eax
$LN4@deflateSet:

; 397  : }

  0004f	f3 c3		 fatret	 0
deflateSetHeader ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+265
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read_buf
_TEXT	SEGMENT
len$ = 32
strm$ = 64
buf$ = 72
size$ = 80
read_buf PROC						; COMDAT

; 996  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 997  :     unsigned len = strm->avail_in;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 998  : 
; 999  :     if (len > size) len = size;

  0001f	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00023	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00027	76 08		 jbe	 SHORT $LN5@read_buf
  00029	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN5@read_buf:

; 1000 :     if (len == 0) return 0;

  00031	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@read_buf
  00038	33 c0		 xor	 eax, eax
  0003a	e9 c5 00 00 00	 jmp	 $LN6@read_buf
$LN4@read_buf:

; 1001 : 
; 1002 :     strm->avail_in  -= len;

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00044	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00048	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0004b	2b c8		 sub	 ecx, eax
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00052	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1003 : 
; 1004 :     if (strm->state->wrap == 1) {

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005e	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  00062	75 28		 jne	 SHORT $LN3@read_buf

; 1005 :         strm->adler = adler32(strm->adler, strm->next_in, len);

  00064	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00069	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0006e	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00076	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00079	e8 00 00 00 00	 call	 adler32
  0007e	44 8b d8	 mov	 r11d, eax
  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00086	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
  0008a	eb 35		 jmp	 SHORT $LN2@read_buf
$LN3@read_buf:

; 1006 :     }
; 1007 : #ifdef GZIP
; 1008 :     else if (strm->state->wrap == 2) {

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00091	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00095	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00099	75 26		 jne	 SHORT $LN1@read_buf

; 1009 :         strm->adler = crc32(strm->adler, strm->next_in, len);

  0009b	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000a5	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ad	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000b0	e8 00 00 00 00	 call	 crc32
  000b5	44 8b d8	 mov	 r11d, eax
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000bd	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN1@read_buf:
$LN2@read_buf:

; 1010 :     }
; 1011 : #endif
; 1012 :     zmemcpy(buf, strm->next_in, len);

  000c1	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000c6	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000cb	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  000d3	e8 00 00 00 00	 call	 memcpy

; 1013 :     strm->next_in  += len;

  000d8	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e1	48 03 08	 add	 rcx, QWORD PTR [rax]
  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1014 :     strm->total_in += len;

  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f1	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  000f4	03 4c 24 20	 add	 ecx, DWORD PTR len$[rsp]
  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fd	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1015 : 
; 1016 :     return (int)len;

  00100	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
$LN6@read_buf:

; 1017 : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
PUBLIC	deflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN8
	DD	imagerel $LN8+773
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateCopy
_TEXT	SEGMENT
overlay$ = 32
ds$ = 40
ss$ = 48
dest$ = 80
source$ = 88
deflateCopy PROC					; COMDAT

; 933  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 934  : #ifdef MAXSEG_64K
; 935  :     return Z_STREAM_ERROR;
; 936  : #else
; 937  :     deflate_state *ds;
; 938  :     deflate_state *ss;
; 939  :     ushf *overlay;
; 940  : 
; 941  : 
; 942  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  00014	74 14		 je	 SHORT $LN4@deflateCop
  00016	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  0001c	74 0c		 je	 SHORT $LN4@deflateCop
  0001e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	75 0a		 jne	 SHORT $LN5@deflateCop
$LN4@deflateCop:

; 943  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2
  0002f	e9 cc 02 00 00	 jmp	 $LN6@deflateCop
$LN5@deflateCop:

; 944  :     }
; 945  : 
; 946  :     ss = source->state;

  00034	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00039	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003d	48 89 44 24 30	 mov	 QWORD PTR ss$[rsp], rax

; 947  : 
; 948  :     zmemcpy(dest, source, sizeof(z_stream));

  00042	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00048	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00052	e8 00 00 00 00	 call	 memcpy

; 949  : 
; 950  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00057	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00067	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00070	ff 50 30	 call	 QWORD PTR [rax+48]
  00073	48 89 44 24 28	 mov	 QWORD PTR ds$[rsp], rax

; 951  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00078	48 83 7c 24 28
	00		 cmp	 QWORD PTR ds$[rsp], 0
  0007e	75 0a		 jne	 SHORT $LN3@deflateCop
  00080	b8 fc ff ff ff	 mov	 eax, -4
  00085	e9 76 02 00 00	 jmp	 $LN6@deflateCop
$LN3@deflateCop:

; 952  :     dest->state = (struct internal_state FAR *) ds;

  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00094	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 953  :     zmemcpy(ds, ss, sizeof(deflate_state));

  00098	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0009e	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  000a8	e8 00 00 00 00	 call	 memcpy

; 954  :     ds->strm = dest;

  000ad	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000b7	49 89 03	 mov	 QWORD PTR [r11], rax

; 955  : 
; 956  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000ba	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000c5	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000cd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	4c 8b d8	 mov	 r11, rax
  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000e1	4c 89 58 50	 mov	 QWORD PTR [rax+80], r11

; 957  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000e5	41 b8 02 00 00
	00		 mov	 r8d, 2
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000f0	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000f8	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00101	ff 50 30	 call	 QWORD PTR [rax+48]
  00104	4c 8b d8	 mov	 r11, rax
  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0010c	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 958  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00110	41 b8 02 00 00
	00		 mov	 r8d, 2
  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0011b	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00123	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0012c	ff 50 30	 call	 QWORD PTR [rax+48]
  0012f	4c 8b d8	 mov	 r11, rax
  00132	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00137	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11

; 959  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  0013b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00146	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  0014c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00151	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00155	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0015a	ff 50 30	 call	 QWORD PTR [rax+48]
  0015d	48 89 44 24 20	 mov	 QWORD PTR overlay$[rsp], rax

; 960  :     ds->pending_buf = (uchf *) overlay;

  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR overlay$[rsp]
  0016c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 961  : 
; 962  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 963  :         ds->pending_buf == Z_NULL) {

  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00175	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0017a	74 24		 je	 SHORT $LN1@deflateCop
  0017c	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00181	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00186	74 18		 je	 SHORT $LN1@deflateCop
  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0018d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00192	74 0c		 je	 SHORT $LN1@deflateCop
  00194	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00199	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0019e	75 14		 jne	 SHORT $LN2@deflateCop
$LN1@deflateCop:

; 964  :         deflateEnd (dest);

  001a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  001a5	e8 00 00 00 00	 call	 deflateEnd

; 965  :         return Z_MEM_ERROR;

  001aa	b8 fc ff ff ff	 mov	 eax, -4
  001af	e9 4c 01 00 00	 jmp	 $LN6@deflateCop
$LN2@deflateCop:

; 966  :     }
; 967  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 968  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001b9	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001bc	d1 e0		 shl	 eax, 1
  001be	44 8b c0	 mov	 r8d, eax
  001c1	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  001c6	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  001ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  001cf	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001d3	e8 00 00 00 00	 call	 memcpy

; 969  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  001d8	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  001dd	45 8b 43 44	 mov	 r8d, DWORD PTR [r11+68]
  001e1	49 d1 e0	 shl	 r8, 1
  001e4	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  001e9	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  001ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  001f2	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001f6	e8 00 00 00 00	 call	 memcpy

; 970  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  001fb	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  00200	45 8b 43 74	 mov	 r8d, DWORD PTR [r11+116]
  00204	49 d1 e0	 shl	 r8, 1
  00207	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  0020c	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00215	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00219	e8 00 00 00 00	 call	 memcpy

; 971  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0021e	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  00223	45 8b 43 18	 mov	 r8d, DWORD PTR [r11+24]
  00227	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  0022c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00230	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00235	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00239	e8 00 00 00 00	 call	 memcpy

; 972  : 
; 973  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0023e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ss$[rsp]
  00243	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  00248	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0024c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00250	48 2b c8	 sub	 rcx, rax
  00253	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00258	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0025c	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00261	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 974  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00265	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0026a	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00270	33 d2		 xor	 edx, edx
  00272	b9 02 00 00 00	 mov	 ecx, 2
  00277	48 f7 f1	 div	 rcx
  0027a	48 8b c8	 mov	 rcx, rax
  0027d	48 8b 44 24 20	 mov	 rax, QWORD PTR overlay$[rsp]
  00282	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  00286	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0028b	48 89 88 f8 16
	00 00		 mov	 QWORD PTR [rax+5880], rcx

; 975  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  00292	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00297	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  0029d	48 6b c9 03	 imul	 rcx, 3
  002a1	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002a6	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  002aa	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002af	48 89 88 e8 16
	00 00		 mov	 QWORD PTR [rax+5864], rcx

; 976  : 
; 977  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  002b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002bb	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  002c2	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002c7	48 89 88 40 0b
	00 00		 mov	 QWORD PTR [rax+2880], rcx

; 978  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  002ce	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002d3	48 81 c1 b0 09
	00 00		 add	 rcx, 2480		; 000009b0H
  002da	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002df	48 89 88 58 0b
	00 00		 mov	 QWORD PTR [rax+2904], rcx

; 979  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  002e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002eb	48 81 c1 a4 0a
	00 00		 add	 rcx, 2724		; 00000aa4H
  002f2	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002f7	48 89 88 70 0b
	00 00		 mov	 QWORD PTR [rax+2928], rcx

; 980  : 
; 981  :     return Z_OK;

  002fe	33 c0		 xor	 eax, eax
$LN6@deflateCop:

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  00300	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00304	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
PUBLIC	deflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN10
	DD	imagerel $LN10+322
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateReset
_TEXT	SEGMENT
s$ = 32
tv87 = 40
tv131 = 44
strm$ = 64
deflateReset PROC					; COMDAT

; 355  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 356  :     deflate_state *s;
; 357  : 
; 358  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 359  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 24		 je	 SHORT $LN2@deflateRes
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 18		 je	 SHORT $LN2@deflateRes
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00027	74 0c		 je	 SHORT $LN2@deflateRes
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00033	75 0a		 jne	 SHORT $LN3@deflateRes
$LN2@deflateRes:

; 360  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 fe 00 00 00	 jmp	 $LN4@deflateRes
$LN3@deflateRes:

; 361  :     }
; 362  : 
; 363  :     strm->total_in = strm->total_out = 0;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 364  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 365  :     strm->data_type = Z_UNKNOWN;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 366  : 
; 367  :     s = (deflate_state *)strm->state;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 368  :     s->pending = 0;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 369  :     s->pending_out = s->pending_buf;

  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00094	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00098	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 370  : 
; 371  :     if (s->wrap < 0) {

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000a5	7d 12		 jge	 SHORT $LN1@deflateRes

; 372  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ac	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  000af	f7 d9		 neg	 ecx
  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b6	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
$LN1@deflateRes:

; 373  :     }
; 374  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000be	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000c2	74 0a		 je	 SHORT $LN6@deflateRes
  000c4	c7 44 24 28 2a
	00 00 00	 mov	 DWORD PTR tv87[rsp], 42	; 0000002aH
  000cc	eb 08		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  000ce	c7 44 24 28 71
	00 00 00	 mov	 DWORD PTR tv87[rsp], 113 ; 00000071H
$LN7@deflateRes:
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000db	8b 44 24 28	 mov	 eax, DWORD PTR tv87[rsp]
  000df	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 375  :     strm->adler =
; 376  : #ifdef GZIP
; 377  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 378  : #endif
; 379  :         adler32(0L, Z_NULL, 0);

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e7	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  000eb	75 12		 jne	 SHORT $LN8@deflateRes
  000ed	45 33 c0	 xor	 r8d, r8d
  000f0	33 d2		 xor	 edx, edx
  000f2	33 c9		 xor	 ecx, ecx
  000f4	e8 00 00 00 00	 call	 crc32
  000f9	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
  000fd	eb 10		 jmp	 SHORT $LN9@deflateRes
$LN8@deflateRes:
  000ff	45 33 c0	 xor	 r8d, r8d
  00102	33 d2		 xor	 edx, edx
  00104	33 c9		 xor	 ecx, ecx
  00106	e8 00 00 00 00	 call	 adler32
  0010b	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN9@deflateRes:
  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00114	8b 44 24 2c	 mov	 eax, DWORD PTR tv131[rsp]
  00118	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 380  :     s->last_flush = Z_NO_FLUSH;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00120	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 381  : 
; 382  :     _tr_init(s);

  00127	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	e8 00 00 00 00	 call	 _tr_init

; 383  :     lm_init(s);

  00131	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00136	e8 00 00 00 00	 call	 lm_init

; 384  : 
; 385  :     return Z_OK;

  0013b	33 c0		 xor	 eax, eax
$LN4@deflateRes:

; 386  : }

  0013d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00141	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
PUBLIC	deflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+611
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
length$ = 32
n$ = 36
s$ = 40
hash_head$ = 48
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 315  : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 316  :     deflate_state *s;
; 317  :     uInt length = dictLength;

  00013	8b 44 24 60	 mov	 eax, DWORD PTR dictLength$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 318  :     uInt n;
; 319  :     IPos hash_head = 0;

  0001b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 320  : 
; 321  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 322  :         strm->state->wrap == 2 ||
; 323  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))

  00023	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00029	74 41		 je	 SHORT $LN8@deflateSet@2
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00030	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00035	74 35		 je	 SHORT $LN8@deflateSet@2
  00037	48 83 7c 24 58
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  0003d	74 2d		 je	 SHORT $LN8@deflateSet@2
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0004c	74 1e		 je	 SHORT $LN8@deflateSet@2
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  0005b	75 19		 jne	 SHORT $LN9@deflateSet@2
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00062	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00066	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  0006a	74 0a		 je	 SHORT $LN9@deflateSet@2
$LN8@deflateSet@2:

; 324  :         return Z_STREAM_ERROR;

  0006c	b8 fe ff ff ff	 mov	 eax, -2
  00071	e9 e8 01 00 00	 jmp	 $LN10@deflateSet@2
$LN9@deflateSet@2:

; 325  : 
; 326  :     s = strm->state;

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007f	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 327  :     if (s->wrap)

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0008d	74 23		 je	 SHORT $LN7@deflateSet@2

; 328  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0008f	44 8b 44 24 60	 mov	 r8d, DWORD PTR dictLength$[rsp]
  00094	48 8b 54 24 58	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0009e	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000a1	e8 00 00 00 00	 call	 adler32
  000a6	44 8b d8	 mov	 r11d, eax
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000ae	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN7@deflateSet@2:

; 329  : 
; 330  :     if (length < MIN_MATCH) return Z_OK;

  000b2	83 7c 24 20 03	 cmp	 DWORD PTR length$[rsp], 3
  000b7	73 07		 jae	 SHORT $LN6@deflateSet@2
  000b9	33 c0		 xor	 eax, eax
  000bb	e9 9e 01 00 00	 jmp	 $LN10@deflateSet@2
$LN6@deflateSet@2:

; 331  :     if (length > s->w_size) {

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000c5	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000c8	39 44 24 20	 cmp	 DWORD PTR length$[rsp], eax
  000cc	76 25		 jbe	 SHORT $LN5@deflateSet@2

; 332  :         length = s->w_size;

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000d3	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000d6	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 333  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  000da	8b 4c 24 20	 mov	 ecx, DWORD PTR length$[rsp]
  000de	8b 44 24 60	 mov	 eax, DWORD PTR dictLength$[rsp]
  000e2	2b c1		 sub	 eax, ecx
  000e4	8b c8		 mov	 ecx, eax
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR dictionary$[rsp]
  000eb	48 03 c1	 add	 rax, rcx
  000ee	48 89 44 24 58	 mov	 QWORD PTR dictionary$[rsp], rax
$LN5@deflateSet@2:

; 334  :     }
; 335  :     zmemcpy(s->window, dictionary, length);

  000f3	44 8b 44 24 20	 mov	 r8d, DWORD PTR length$[rsp]
  000f8	48 8b 54 24 58	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00102	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00106	e8 00 00 00 00	 call	 memcpy

; 336  :     s->strstart = length;

  0010b	4c 8b 5c 24 28	 mov	 r11, QWORD PTR s$[rsp]
  00110	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  00114	41 89 83 94 00
	00 00		 mov	 DWORD PTR [r11+148], eax

; 337  :     s->block_start = (long)length;

  0011b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00120	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  00124	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 338  : 
; 339  :     /* Insert all strings in the hash table (except for the last two bytes).
; 340  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 341  :      * call of fill_window.
; 342  :      */
; 343  :     s->ins_h = s->window[0];

  0012a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0012f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00133	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0013b	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 344  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  0013e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00143	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00149	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0014e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00151	d3 e0		 shl	 eax, cl
  00153	8b c8		 mov	 ecx, eax
  00155	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0015a	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0015e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00162	33 c8		 xor	 ecx, eax
  00164	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00169	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  0016c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00171	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 345  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  00174	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0017c	eb 0b		 jmp	 SHORT $LN4@deflateSet@2
$LN3@deflateSet@2:
  0017e	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00182	83 c0 01	 add	 eax, 1
  00185	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN4@deflateSet@2:
  00189	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  0018d	83 e8 03	 sub	 eax, 3
  00190	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  00194	0f 87 b3 00 00
	00		 ja	 $LN2@deflateSet@2

; 346  :         INSERT_STRING(s, n, hash_head);

  0019a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0019f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  001a5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001aa	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  001ad	d3 e2		 shl	 edx, cl
  001af	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001b3	83 c0 02	 add	 eax, 2
  001b6	8b c8		 mov	 ecx, eax
  001b8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001bd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001c1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001c5	8b ca		 mov	 ecx, edx
  001c7	33 c8		 xor	 ecx, eax
  001c9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001ce	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001d6	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  001d9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001de	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  001e2	4c 8b 44 24 28	 mov	 r8, QWORD PTR s$[rsp]
  001e7	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  001eb	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001f0	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  001f3	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001f7	23 c1		 and	 eax, ecx
  001f9	8b d0		 mov	 edx, eax
  001fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00200	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00204	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00209	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0020d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00212	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00215	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00219	23 c1		 and	 eax, ecx
  0021b	8b c8		 mov	 ecx, eax
  0021d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00222	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00226	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0022a	89 44 24 30	 mov	 DWORD PTR hash_head$[rsp], eax
  0022e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00233	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00236	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0023b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0023f	0f b7 44 24 24	 movzx	 eax, WORD PTR n$[rsp]
  00244	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 347  :     }

  00248	e9 31 ff ff ff	 jmp	 $LN3@deflateSet@2
$LN2@deflateSet@2:

; 348  :     if (hash_head) hash_head = 0;  /* to make compiler happy */

  0024d	83 7c 24 30 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  00252	74 08		 je	 SHORT $LN1@deflateSet@2
  00254	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0
$LN1@deflateSet@2:

; 349  :     return Z_OK;

  0025c	33 c0		 xor	 eax, eax
$LN10@deflateSet@2:

; 350  : }

  0025e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00262	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	deflateInit2_
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN18
	DD	imagerel $LN18+1077
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit2_
_TEXT	SEGMENT
s$ = 32
overlay$ = 40
wrap$ = 48
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 220  : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 221  :     deflate_state *s;
; 222  :     int wrap = 1;

  00017	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 1

; 223  :     static const char my_version[] = ZLIB_VERSION;
; 224  : 
; 225  :     ushf *overlay;
; 226  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 227  :      * output size for (length,distance) codes is <= 24 bits.
; 228  :      */
; 229  : 
; 230  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 231  :         stream_size != sizeof(z_stream)) {

  0001f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR version$[rsp], 0
  00028	74 24		 je	 SHORT $LN14@deflateIni
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00035	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?my_version@?1??deflateInit2_@@9@9
  0003c	3b c8		 cmp	 ecx, eax
  0003e	75 0e		 jne	 SHORT $LN14@deflateIni
  00040	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR stream_size$[rsp]
  00048	48 83 f8 58	 cmp	 rax, 88			; 00000058H
  0004c	74 0a		 je	 SHORT $LN15@deflateIni
$LN14@deflateIni:

; 232  :         return Z_VERSION_ERROR;

  0004e	b8 fa ff ff ff	 mov	 eax, -6
  00053	e9 d8 03 00 00	 jmp	 $LN16@deflateIni
$LN15@deflateIni:

; 233  :     }
; 234  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00058	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0005e	75 0a		 jne	 SHORT $LN13@deflateIni
  00060	b8 fe ff ff ff	 mov	 eax, -2
  00065	e9 c6 03 00 00	 jmp	 $LN16@deflateIni
$LN13@deflateIni:

; 235  : 
; 236  :     strm->msg = Z_NULL;

  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0006f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 237  :     if (strm->zalloc == (alloc_func)0) {

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00081	75 1d		 jne	 SHORT $LN12@deflateIni

; 238  :         strm->zalloc = zcalloc;

  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  0008f	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 239  :         strm->opaque = (voidpf)0;

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00098	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN12@deflateIni:

; 240  :     }
; 241  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000a5	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000aa	75 10		 jne	 SHORT $LN11@deflateIni
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000b8	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN11@deflateIni:

; 242  : 
; 243  : #ifdef FASTEST
; 244  :     if (level != 0) level = 1;
; 245  : #else
; 246  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  000bc	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  000c1	75 08		 jne	 SHORT $LN10@deflateIni
  000c3	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN10@deflateIni:

; 247  : #endif
; 248  : 
; 249  :     if (windowBits < 0) { /* suppress zlib wrapper */

  000cb	83 7c 24 68 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  000d0	7d 14		 jge	 SHORT $LN9@deflateIni

; 250  :         wrap = 0;

  000d2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 251  :         windowBits = -windowBits;

  000da	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000de	f7 d8		 neg	 eax
  000e0	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
  000e4	eb 1a		 jmp	 SHORT $LN8@deflateIni
$LN9@deflateIni:

; 252  :     }
; 253  : #ifdef GZIP
; 254  :     else if (windowBits > 15) {

  000e6	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  000eb	7e 13		 jle	 SHORT $LN7@deflateIni

; 255  :         wrap = 2;       /* write gzip wrapper instead */

  000ed	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 2

; 256  :         windowBits -= 16;

  000f5	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000f9	83 e8 10	 sub	 eax, 16
  000fc	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
$LN7@deflateIni:
$LN8@deflateIni:

; 257  :     }
; 258  : #endif
; 259  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 260  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 261  :         strategy < 0 || strategy > Z_FIXED) {

  00100	83 7c 24 70 01	 cmp	 DWORD PTR memLevel$[rsp], 1
  00105	7c 38		 jl	 SHORT $LN5@deflateIni
  00107	83 7c 24 70 09	 cmp	 DWORD PTR memLevel$[rsp], 9
  0010c	7f 31		 jg	 SHORT $LN5@deflateIni
  0010e	83 7c 24 60 08	 cmp	 DWORD PTR method$[rsp], 8
  00113	75 2a		 jne	 SHORT $LN5@deflateIni
  00115	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0011a	7c 23		 jl	 SHORT $LN5@deflateIni
  0011c	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00121	7f 1c		 jg	 SHORT $LN5@deflateIni
  00123	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  00128	7c 15		 jl	 SHORT $LN5@deflateIni
  0012a	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  0012f	7f 0e		 jg	 SHORT $LN5@deflateIni
  00131	83 7c 24 78 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00136	7c 07		 jl	 SHORT $LN5@deflateIni
  00138	83 7c 24 78 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0013d	7e 0a		 jle	 SHORT $LN6@deflateIni
$LN5@deflateIni:

; 262  :         return Z_STREAM_ERROR;

  0013f	b8 fe ff ff ff	 mov	 eax, -2
  00144	e9 e7 02 00 00	 jmp	 $LN16@deflateIni
$LN6@deflateIni:

; 263  :     }
; 264  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  00149	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0014e	75 08		 jne	 SHORT $LN4@deflateIni
  00150	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR windowBits$[rsp], 9
$LN4@deflateIni:

; 265  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  00158	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0015e	ba 01 00 00 00	 mov	 edx, 1
  00163	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00168	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0016c	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00171	ff 50 30	 call	 QWORD PTR [rax+48]
  00174	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 266  :     if (s == Z_NULL) return Z_MEM_ERROR;

  00179	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0017f	75 0a		 jne	 SHORT $LN3@deflateIni
  00181	b8 fc ff ff ff	 mov	 eax, -4
  00186	e9 a5 02 00 00	 jmp	 $LN16@deflateIni
$LN3@deflateIni:

; 267  :     strm->state = (struct internal_state FAR *)s;

  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00195	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 268  :     s->strm = strm;

  00199	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001a3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 269  : 
; 270  :     s->wrap = wrap;

  001a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	8b 44 24 30	 mov	 eax, DWORD PTR wrap$[rsp]
  001af	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 271  :     s->gzhead = Z_NULL;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b7	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 272  :     s->w_bits = windowBits;

  001bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001c4	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  001c8	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 273  :     s->w_size = 1 << s->w_bits;

  001cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d0	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  001d3	b8 01 00 00 00	 mov	 eax, 1
  001d8	d3 e0		 shl	 eax, cl
  001da	8b c8		 mov	 ecx, eax
  001dc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e1	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 274  :     s->w_mask = s->w_size - 1;

  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e9	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  001ec	83 e9 01	 sub	 ecx, 1
  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f4	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 275  : 
; 276  :     s->hash_bits = memLevel + 7;

  001f7	8b 4c 24 70	 mov	 ecx, DWORD PTR memLevel$[rsp]
  001fb	83 c1 07	 add	 ecx, 7
  001fe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00203	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 277  :     s->hash_size = 1 << s->hash_bits;

  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0020b	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  0020e	b8 01 00 00 00	 mov	 eax, 1
  00213	d3 e0		 shl	 eax, cl
  00215	8b c8		 mov	 ecx, eax
  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0021c	89 48 74	 mov	 DWORD PTR [rax+116], ecx

; 278  :     s->hash_mask = s->hash_size - 1;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00224	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  00227	83 e9 01	 sub	 ecx, 1
  0022a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022f	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 279  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  00232	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00237	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0023a	83 c0 02	 add	 eax, 2
  0023d	33 d2		 xor	 edx, edx
  0023f	b9 03 00 00 00	 mov	 ecx, 3
  00244	f7 f1		 div	 ecx
  00246	8b c8		 mov	 ecx, eax
  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0024d	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 280  : 
; 281  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00253	41 b8 02 00 00
	00		 mov	 r8d, 2
  00259	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0025e	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  00261	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00266	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0026a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0026f	ff 50 30	 call	 QWORD PTR [rax+48]
  00272	4c 8b d8	 mov	 r11, rax
  00275	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0027a	4c 89 58 50	 mov	 QWORD PTR [rax+80], r11

; 282  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0027e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00284	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00289	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  0028c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00291	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00295	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0029a	ff 50 30	 call	 QWORD PTR [rax+48]
  0029d	4c 8b d8	 mov	 r11, rax
  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002a5	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 283  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  002a9	41 b8 02 00 00
	00		 mov	 r8d, 2
  002af	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b4	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  002b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  002bc	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  002c0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  002c5	ff 50 30	 call	 QWORD PTR [rax+48]
  002c8	4c 8b d8	 mov	 r11, rax
  002cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002d0	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11

; 284  : 
; 285  :     s->high_water = 0;      /* nothing written to s->window yet */

  002d4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002d9	c7 80 18 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5912], 0

; 286  : 
; 287  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  002e3	8b 4c 24 70	 mov	 ecx, DWORD PTR memLevel$[rsp]
  002e7	83 c1 06	 add	 ecx, 6
  002ea	b8 01 00 00 00	 mov	 eax, 1
  002ef	d3 e0		 shl	 eax, cl
  002f1	8b c8		 mov	 ecx, eax
  002f3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002f8	89 88 f0 16 00
	00		 mov	 DWORD PTR [rax+5872], ecx

; 288  : 
; 289  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  002fe	41 b8 04 00 00
	00		 mov	 r8d, 4
  00304	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00309	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  0030f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00314	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00318	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0031d	ff 50 30	 call	 QWORD PTR [rax+48]
  00320	48 89 44 24 28	 mov	 QWORD PTR overlay$[rsp], rax

; 290  :     s->pending_buf = (uchf *) overlay;

  00325	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0032a	48 8b 44 24 28	 mov	 rax, QWORD PTR overlay$[rsp]
  0032f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 291  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00333	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00338	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  0033e	48 c1 e1 02	 shl	 rcx, 2
  00342	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00347	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 292  : 
; 293  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 294  :         s->pending_buf == Z_NULL) {

  0034a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0034f	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00354	74 24		 je	 SHORT $LN1@deflateIni
  00356	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0035b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00360	74 18		 je	 SHORT $LN1@deflateIni
  00362	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00367	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0036c	74 0c		 je	 SHORT $LN1@deflateIni
  0036e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00373	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00378	75 30		 jne	 SHORT $LN2@deflateIni
$LN1@deflateIni:

; 295  :         s->status = FINISH_STATE;

  0037a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0037f	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH

; 296  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  00386	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0038b	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48
  00392	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 297  :         deflateEnd (strm);

  00396	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0039b	e8 00 00 00 00	 call	 deflateEnd

; 298  :         return Z_MEM_ERROR;

  003a0	b8 fc ff ff ff	 mov	 eax, -4
  003a5	e9 86 00 00 00	 jmp	 $LN16@deflateIni
$LN2@deflateIni:

; 299  :     }
; 300  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  003aa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003af	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  003b5	33 d2		 xor	 edx, edx
  003b7	b9 02 00 00 00	 mov	 ecx, 2
  003bc	48 f7 f1	 div	 rcx
  003bf	48 8b c8	 mov	 rcx, rax
  003c2	48 8b 44 24 28	 mov	 rax, QWORD PTR overlay$[rsp]
  003c7	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  003cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003d0	48 89 88 f8 16
	00 00		 mov	 QWORD PTR [rax+5880], rcx

; 301  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  003d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003dc	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  003e2	48 6b c9 03	 imul	 rcx, 3
  003e6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003eb	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  003ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003f4	48 89 88 e8 16
	00 00		 mov	 QWORD PTR [rax+5864], rcx

; 302  : 
; 303  :     s->level = level;

  003fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00400	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  00404	89 81 ac 00 00
	00		 mov	 DWORD PTR [rcx+172], eax

; 304  :     s->strategy = strategy;

  0040a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0040f	8b 44 24 78	 mov	 eax, DWORD PTR strategy$[rsp]
  00413	89 81 b0 00 00
	00		 mov	 DWORD PTR [rcx+176], eax

; 305  :     s->method = (Byte)method;

  00419	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0041e	0f b6 44 24 60	 movzx	 eax, BYTE PTR method$[rsp]
  00423	88 41 3c	 mov	 BYTE PTR [rcx+60], al

; 306  : 
; 307  :     return deflateReset(strm);

  00426	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0042b	e8 00 00 00 00	 call	 deflateReset
$LN16@deflateIni:

; 308  : }

  00430	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00434	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	deflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 203  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 204  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 205  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00017	8b 44 24 68	 mov	 eax, DWORD PTR stream_size$[rsp]
  0001b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR version$[rsp]
  00024	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00029	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00031	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00039	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	8b 54 24 58	 mov	 edx, DWORD PTR level$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0004e	e8 00 00 00 00	 call	 deflateInit2_

; 206  :     /* To do: ignore strm->next_in if we use it as window */
; 207  : }

  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	c3		 ret	 0
deflateInit_ ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+1118
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fill_window
_TEXT	SEGMENT
p$ = 32
n$ = 40
more$ = 44
wsize$ = 48
m$ = 52
init$78658 = 56
curr$78656 = 60
tv141 = 64
tv153 = 68
s$ = 96
fill_window PROC					; COMDAT

; 1307 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1308 :     register unsigned n, m;
; 1309 :     register Posf *p;
; 1310 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1311 :     uInt wsize = s->w_size;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00011	89 44 24 30	 mov	 DWORD PTR wsize$[rsp], eax
$LN23@fill_windo:

; 1312 : 
; 1313 :     do {
; 1314 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00015	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0001a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001f	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00025	8b 42 58	 mov	 eax, DWORD PTR [rdx+88]
  00028	2b c1		 sub	 eax, ecx
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	2b 81 94 00 00
	00		 sub	 eax, DWORD PTR [rcx+148]
  00035	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax

; 1315 : 
; 1316 :         /* Deal with !@#$% 64K limit: */
; 1317 :         if (sizeof(int) <= 2) {

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	74 3f		 je	 SHORT $LN20@fill_windo

; 1318 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {

  0003f	83 7c 24 2c 00	 cmp	 DWORD PTR more$[rsp], 0
  00044	75 26		 jne	 SHORT $LN19@fill_windo
  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004b	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00052	75 18		 jne	 SHORT $LN19@fill_windo
  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00059	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00060	75 0a		 jne	 SHORT $LN19@fill_windo

; 1319 :                 more = wsize;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00066	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
  0006a	eb 12		 jmp	 SHORT $LN18@fill_windo
$LN19@fill_windo:

; 1320 : 
; 1321 :             } else if (more == (unsigned)(-1)) {

  0006c	83 7c 24 2c ff	 cmp	 DWORD PTR more$[rsp], -1 ; ffffffffH
  00071	75 0b		 jne	 SHORT $LN17@fill_windo

; 1322 :                 /* Very unlikely, but possible on 16 bit machine if
; 1323 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1324 :                  */
; 1325 :                 more--;

  00073	8b 44 24 2c	 mov	 eax, DWORD PTR more$[rsp]
  00077	83 e8 01	 sub	 eax, 1
  0007a	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN17@fill_windo:
$LN18@fill_windo:
$LN20@fill_windo:

; 1326 :             }
; 1327 :         }
; 1328 : 
; 1329 :         /* If the window is almost full and there is insufficient lookahead,
; 1330 :          * move the upper half to the lower one to make room in the upper half.
; 1331 :          */
; 1332 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0007e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00083	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00086	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  0008a	8d 8c 08 fa fe
	ff ff		 lea	 ecx, DWORD PTR [rax+rcx-262]
  00091	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00096	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  0009c	0f 82 79 01 00
	00		 jb	 $LN16@fill_windo

; 1333 : 
; 1334 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  000a2	44 8b 44 24 30	 mov	 r8d, DWORD PTR wsize$[rsp]
  000a7	8b 54 24 30	 mov	 edx, DWORD PTR wsize$[rsp]
  000ab	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b0	48 03 50 50	 add	 rdx, QWORD PTR [rax+80]
  000b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000b9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000bd	e8 00 00 00 00	 call	 memcpy

; 1335 :             s->match_start -= wsize;

  000c2	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  000c7	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000cb	41 8b 8b 98 00
	00 00		 mov	 ecx, DWORD PTR [r11+152]
  000d2	2b c8		 sub	 ecx, eax
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d9	89 88 98 00 00
	00		 mov	 DWORD PTR [rax+152], ecx

; 1336 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  000df	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000e8	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000ee	2b c8		 sub	 ecx, eax
  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f5	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1337 :             s->block_start -= (long) wsize;

  000fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00100	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00104	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0010a	2b c8		 sub	 ecx, eax
  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00111	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1338 : 
; 1339 :             /* Slide the hash table (could be avoided with 32 bit values
; 1340 :                at the expense of memory usage). We slide even when level == 0
; 1341 :                to keep the hash table consistent if we switch back to level > 0
; 1342 :                later. (Using level 0 permanently is not an optimal usage of
; 1343 :                zlib, so we don't care about this pathological case.)
; 1344 :              */
; 1345 :             n = s->hash_size;

  00117	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0011c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0011f	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1346 :             p = &s->head[n];

  00123	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00127	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0012c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00130	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00134	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN15@fill_windo:

; 1347 :             do {
; 1348 :                 m = *--p;

  00139	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0013e	48 83 e8 02	 sub	 rax, 2
  00142	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0014c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0014f	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1349 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00153	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00157	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  0015b	72 10		 jb	 SHORT $LN26@fill_windo
  0015d	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00161	8b 44 24 34	 mov	 eax, DWORD PTR m$[rsp]
  00165	2b c1		 sub	 eax, ecx
  00167	89 44 24 40	 mov	 DWORD PTR tv141[rsp], eax
  0016b	eb 08		 jmp	 SHORT $LN27@fill_windo
$LN26@fill_windo:
  0016d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN27@fill_windo:
  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0017a	0f b7 44 24 40	 movzx	 eax, WORD PTR tv141[rsp]
  0017f	66 89 01	 mov	 WORD PTR [rcx], ax

; 1350 :             } while (--n);

  00182	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00186	83 e8 01	 sub	 eax, 1
  00189	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  0018d	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  00192	75 a5		 jne	 SHORT $LN15@fill_windo

; 1351 : 
; 1352 :             n = wsize;

  00194	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00198	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1353 : #ifndef FASTEST
; 1354 :             p = &s->prev[n];

  0019c	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  001a0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a9	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  001ad	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN12@fill_windo:

; 1355 :             do {
; 1356 :                 m = *--p;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001b7	48 83 e8 02	 sub	 rax, 2
  001bb	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001c5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001c8	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1357 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  001cc	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  001d0	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  001d4	72 10		 jb	 SHORT $LN28@fill_windo
  001d6	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  001da	8b 44 24 34	 mov	 eax, DWORD PTR m$[rsp]
  001de	2b c1		 sub	 eax, ecx
  001e0	89 44 24 44	 mov	 DWORD PTR tv153[rsp], eax
  001e4	eb 08		 jmp	 SHORT $LN29@fill_windo
$LN28@fill_windo:
  001e6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN29@fill_windo:
  001ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001f3	0f b7 44 24 44	 movzx	 eax, WORD PTR tv153[rsp]
  001f8	66 89 01	 mov	 WORD PTR [rcx], ax

; 1358 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1359 :                  * its value will never be used.
; 1360 :                  */
; 1361 :             } while (--n);

  001fb	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  001ff	83 e8 01	 sub	 eax, 1
  00202	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  00206	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  0020b	75 a5		 jne	 SHORT $LN12@fill_windo

; 1362 : #endif
; 1363 :             more += wsize;

  0020d	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00211	8b 44 24 2c	 mov	 eax, DWORD PTR more$[rsp]
  00215	03 c1		 add	 eax, ecx
  00217	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN16@fill_windo:

; 1364 :         }
; 1365 :         if (s->strm->avail_in == 0) return;

  0021b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00227	75 05		 jne	 SHORT $LN9@fill_windo
  00229	e9 2b 02 00 00	 jmp	 $LN24@fill_windo
$LN9@fill_windo:

; 1366 : 
; 1367 :         /* If there was no sliding:
; 1368 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1369 :          *    more == window_size - lookahead - strstart
; 1370 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1371 :          * => more >= window_size - 2*WSIZE + 2
; 1372 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1373 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1374 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1375 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1376 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1377 :          */
; 1378 :         Assert(more >= 2, "more < 2");
; 1379 : 
; 1380 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  0022e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00233	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00239	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0023e	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00242	48 03 d0	 add	 rdx, rax
  00245	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0024a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00250	48 03 d0	 add	 rdx, rax
  00253	44 8b 44 24 2c	 mov	 r8d, DWORD PTR more$[rsp]
  00258	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0025d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00260	e8 00 00 00 00	 call	 read_buf
  00265	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1381 :         s->lookahead += n;

  00269	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0026e	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00274	03 4c 24 28	 add	 ecx, DWORD PTR n$[rsp]
  00278	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0027d	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1382 : 
; 1383 :         /* Initialize the hash value now that we have some input: */
; 1384 :         if (s->lookahead >= MIN_MATCH) {

  00283	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00288	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0028f	72 66		 jb	 SHORT $LN8@fill_windo

; 1385 :             s->ins_h = s->window[s->strstart];

  00291	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00296	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0029c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002a1	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002a5	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  002a9	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ae	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1386 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  002b1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002b6	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  002bc	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002c1	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  002c4	d3 e2		 shl	 edx, cl
  002c6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002cb	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002d1	83 c0 01	 add	 eax, 1
  002d4	8b c8		 mov	 ecx, eax
  002d6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002db	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002df	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002e3	8b ca		 mov	 ecx, edx
  002e5	33 c8		 xor	 ecx, eax
  002e7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ec	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  002ef	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002f4	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN8@fill_windo:

; 1387 : #if MIN_MATCH != 3
; 1388 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1389 : #endif
; 1390 :         }
; 1391 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1392 :          * but this is not important since only literal bytes will be emitted.
; 1393 :          */
; 1394 : 
; 1395 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  002f7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002fc	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00306	73 12		 jae	 SHORT $LN7@fill_windo
  00308	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0030d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00310	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00314	0f 85 fb fc ff
	ff		 jne	 $LN23@fill_windo
$LN7@fill_windo:

; 1396 : 
; 1397 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1398 :      * written, then zero those bytes in order to avoid memory check reports of
; 1399 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1400 :      * the longest match routines.  Update the high water mark for the next
; 1401 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1402 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1403 :      */
; 1404 :     if (s->high_water < s->window_size) {

  0031a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0031f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00324	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00327	39 81 18 17 00
	00		 cmp	 DWORD PTR [rcx+5912], eax
  0032d	0f 83 26 01 00
	00		 jae	 $LN6@fill_windo

; 1405 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  00333	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00338	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0033e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00343	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  00349	89 44 24 3c	 mov	 DWORD PTR curr$78656[rsp], eax

; 1406 :         ulg init;
; 1407 : 
; 1408 :         if (s->high_water < curr) {

  0034d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00352	8b 44 24 3c	 mov	 eax, DWORD PTR curr$78656[rsp]
  00356	39 81 18 17 00
	00		 cmp	 DWORD PTR [rcx+5912], eax
  0035c	73 59		 jae	 SHORT $LN5@fill_windo

; 1409 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1410 :              * bytes or up to end of window, whichever is less.
; 1411 :              */
; 1412 :             init = s->window_size - curr;

  0035e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00363	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$78656[rsp]
  00367	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0036a	2b c1		 sub	 eax, ecx
  0036c	89 44 24 38	 mov	 DWORD PTR init$78658[rsp], eax

; 1413 :             if (init > WIN_INIT)

  00370	81 7c 24 38 02
	01 00 00	 cmp	 DWORD PTR init$78658[rsp], 258 ; 00000102H
  00378	76 08		 jbe	 SHORT $LN4@fill_windo

; 1414 :                 init = WIN_INIT;

  0037a	c7 44 24 38 02
	01 00 00	 mov	 DWORD PTR init$78658[rsp], 258 ; 00000102H
$LN4@fill_windo:

; 1415 :             zmemzero(s->window + curr, (unsigned)init);

  00382	44 8b 44 24 38	 mov	 r8d, DWORD PTR init$78658[rsp]
  00387	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$78656[rsp]
  0038b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00390	48 03 48 50	 add	 rcx, QWORD PTR [rax+80]
  00394	33 d2		 xor	 edx, edx
  00396	e8 00 00 00 00	 call	 memset

; 1416 :             s->high_water = curr + init;

  0039b	44 8b 5c 24 38	 mov	 r11d, DWORD PTR init$78658[rsp]
  003a0	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$78656[rsp]
  003a4	41 03 cb	 add	 ecx, r11d
  003a7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003ac	89 88 18 17 00
	00		 mov	 DWORD PTR [rax+5912], ecx
  003b2	e9 a2 00 00 00	 jmp	 $LN3@fill_windo
$LN5@fill_windo:

; 1417 :         }
; 1418 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  003b7	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$78656[rsp]
  003bb	81 c1 02 01 00
	00		 add	 ecx, 258		; 00000102H
  003c1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003c6	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  003cc	0f 83 87 00 00
	00		 jae	 $LN2@fill_windo

; 1419 :             /* High water mark at or above current data, but below current data
; 1420 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1421 :              * to end of window, whichever is less.
; 1422 :              */
; 1423 :             init = (ulg)curr + WIN_INIT - s->high_water;

  003d2	8b 44 24 3c	 mov	 eax, DWORD PTR curr$78656[rsp]
  003d6	05 02 01 00 00	 add	 eax, 258		; 00000102H
  003db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003e0	2b 81 18 17 00
	00		 sub	 eax, DWORD PTR [rcx+5912]
  003e6	89 44 24 38	 mov	 DWORD PTR init$78658[rsp], eax

; 1424 :             if (init > s->window_size - s->high_water)

  003ea	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  003ef	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003f4	8b 88 18 17 00
	00		 mov	 ecx, DWORD PTR [rax+5912]
  003fa	8b 42 58	 mov	 eax, DWORD PTR [rdx+88]
  003fd	2b c1		 sub	 eax, ecx
  003ff	39 44 24 38	 cmp	 DWORD PTR init$78658[rsp], eax
  00403	76 19		 jbe	 SHORT $LN1@fill_windo

; 1425 :                 init = s->window_size - s->high_water;

  00405	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0040a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0040f	8b 88 18 17 00
	00		 mov	 ecx, DWORD PTR [rax+5912]
  00415	8b 42 58	 mov	 eax, DWORD PTR [rdx+88]
  00418	2b c1		 sub	 eax, ecx
  0041a	89 44 24 38	 mov	 DWORD PTR init$78658[rsp], eax
$LN1@fill_windo:

; 1426 :             zmemzero(s->window + s->high_water, (unsigned)init);

  0041e	44 8b 44 24 38	 mov	 r8d, DWORD PTR init$78658[rsp]
  00423	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00428	8b 88 18 17 00
	00		 mov	 ecx, DWORD PTR [rax+5912]
  0042e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00433	48 03 48 50	 add	 rcx, QWORD PTR [rax+80]
  00437	33 d2		 xor	 edx, edx
  00439	e8 00 00 00 00	 call	 memset

; 1427 :             s->high_water += init;

  0043e	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00443	41 8b 8b 18 17
	00 00		 mov	 ecx, DWORD PTR [r11+5912]
  0044a	03 4c 24 38	 add	 ecx, DWORD PTR init$78658[rsp]
  0044e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00453	89 88 18 17 00
	00		 mov	 DWORD PTR [rax+5912], ecx
$LN2@fill_windo:
$LN3@fill_windo:
$LN6@fill_windo:
$LN24@fill_windo:

; 1428 :         }
; 1429 :     }
; 1430 : }

  00459	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0045d	c3		 ret	 0
fill_window ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+745
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_huff
_TEXT	SEGMENT
bflush$ = 32
cc$78848 = 36
tv136 = 40
tv157 = 48
tv166 = 56
tv178 = 64
tv187 = 72
tv189 = 76
s$ = 96
flush$ = 104
deflate_huff PROC					; COMDAT

; 1810 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN8@deflate_hu:

; 1811 :     int bflush;             /* set if current block must be flushed */
; 1812 : 
; 1813 :     for (;;) {
; 1814 :         /* Make sure that we have a literal to write. */
; 1815 :         if (s->lookahead == 0) {

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00012	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00019	75 2c		 jne	 SHORT $LN6@deflate_hu

; 1816 :             fill_window(s);

  0001b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 fill_window

; 1817 :             if (s->lookahead == 0) {

  00025	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  0002a	41 83 bb 9c 00
	00 00 00	 cmp	 DWORD PTR [r11+156], 0
  00032	75 13		 jne	 SHORT $LN5@deflate_hu

; 1818 :                 if (flush == Z_NO_FLUSH)

  00034	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00039	75 07		 jne	 SHORT $LN4@deflate_hu

; 1819 :                     return need_more;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 a2 02 00 00	 jmp	 $LN9@deflate_hu
$LN4@deflate_hu:

; 1820 :                 break;      /* flush the current block */

  00042	e9 b6 01 00 00	 jmp	 $LN7@deflate_hu
$LN5@deflate_hu:
$LN6@deflate_hu:

; 1821 :             }
; 1822 :         }
; 1823 : 
; 1824 :         /* Output a literal byte */
; 1825 :         s->match_length = 0;

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004c	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1826 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1827 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00056	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0005b	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00066	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0006a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006e	88 44 24 24	 mov	 BYTE PTR cc$78848[rsp], al
  00072	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00077	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00082	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00089	33 c0		 xor	 eax, eax
  0008b	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0008f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00094	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  000a6	0f b6 44 24 24	 movzx	 eax, BYTE PTR cc$78848[rsp]
  000ab	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ae	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b3	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  000b9	83 c1 01	 add	 ecx, 1
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c1	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  000c7	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR cc$78848[rsp]
  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d1	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  000d9	66 83 c2 01	 add	 dx, 1
  000dd	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR cc$78848[rsp]
  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000e7	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f4	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  000fa	83 e9 01	 sub	 ecx, 1
  000fd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00102	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  00108	75 0a		 jne	 SHORT $LN11@deflate_hu
  0010a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00112	eb 08		 jmp	 SHORT $LN12@deflate_hu
$LN11@deflate_hu:
  00114	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN12@deflate_hu:
  0011c	8b 44 24 28	 mov	 eax, DWORD PTR tv136[rsp]
  00120	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1828 :         s->lookahead--;

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00129	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  0012f	83 e9 01	 sub	 ecx, 1
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00137	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1829 :         s->strstart++;

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00142	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00148	83 c1 01	 add	 ecx, 1
  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00150	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1830 :         if (bflush) FLUSH_BLOCK(s, 0);

  00156	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  0015b	0f 84 97 00 00
	00		 je	 $LN3@deflate_hu
  00161	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00166	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0016d	7c 1b		 jl	 SHORT $LN13@deflate_hu
  0016f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00174	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0017a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0017f	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00183	48 89 44 24 30	 mov	 QWORD PTR tv157[rsp], rax
  00188	eb 09		 jmp	 SHORT $LN14@deflate_hu
$LN13@deflate_hu:
  0018a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv157[rsp], 0
$LN14@deflate_hu:
  00193	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00198	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0019d	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001a3	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  001aa	44 2b c0	 sub	 r8d, eax
  001ad	45 33 c9	 xor	 r9d, r9d
  001b0	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv157[rsp]
  001b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ba	e8 00 00 00 00	 call	 _tr_flush_block
  001bf	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  001c4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001c9	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001cf	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001db	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001de	e8 00 00 00 00	 call	 flush_pending
  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001eb	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001ef	75 07		 jne	 SHORT $LN2@deflate_hu
  001f1	33 c0		 xor	 eax, eax
  001f3	e9 ec 00 00 00	 jmp	 $LN9@deflate_hu
$LN2@deflate_hu:
$LN3@deflate_hu:

; 1831 :     }

  001f8	e9 10 fe ff ff	 jmp	 $LN8@deflate_hu
$LN7@deflate_hu:

; 1832 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  001fd	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  00202	75 0a		 jne	 SHORT $LN15@deflate_hu
  00204	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  0020c	eb 08		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  0020e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN16@deflate_hu:
  00216	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0021b	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00222	7c 1b		 jl	 SHORT $LN17@deflate_hu
  00224	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00229	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0022f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00234	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00238	48 89 44 24 40	 mov	 QWORD PTR tv178[rsp], rax
  0023d	eb 09		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  0023f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv178[rsp], 0
$LN18@deflate_hu:
  00248	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0024d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00252	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00258	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0025f	44 2b c0	 sub	 r8d, eax
  00262	44 8b 4c 24 38	 mov	 r9d, DWORD PTR tv166[rsp]
  00267	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv178[rsp]
  0026c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00271	e8 00 00 00 00	 call	 _tr_flush_block
  00276	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  0027b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00280	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00286	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  0028d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00292	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00295	e8 00 00 00 00	 call	 flush_pending
  0029a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a2	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002a6	75 1f		 jne	 SHORT $LN1@deflate_hu
  002a8	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  002ad	75 0a		 jne	 SHORT $LN19@deflate_hu
  002af	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv187[rsp], 2
  002b7	eb 08		 jmp	 SHORT $LN20@deflate_hu
$LN19@deflate_hu:
  002b9	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN20@deflate_hu:
  002c1	8b 44 24 48	 mov	 eax, DWORD PTR tv187[rsp]
  002c5	eb 1d		 jmp	 SHORT $LN9@deflate_hu
$LN1@deflate_hu:

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;

  002c7	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  002cc	75 0a		 jne	 SHORT $LN21@deflate_hu
  002ce	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv189[rsp], 3
  002d6	eb 08		 jmp	 SHORT $LN22@deflate_hu
$LN21@deflate_hu:
  002d8	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
$LN22@deflate_hu:
  002e0	8b 44 24 4c	 mov	 eax, DWORD PTR tv189[rsp]
$LN9@deflate_hu:

; 1834 : }

  002e4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e8	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+2014
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_rle
_TEXT	SEGMENT
prev$ = 32
scan$ = 40
bflush$ = 48
strend$ = 56
len$78820 = 64
dist$78821 = 68
cc$78823 = 72
tv219 = 76
tv236 = 80
tv279 = 84
tv300 = 88
tv309 = 96
tv321 = 104
tv330 = 112
tv332 = 116
s$ = 144
flush$ = 152
deflate_rle PROC					; COMDAT

; 1744 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN17@deflate_rl:

; 1745 :     int bflush;             /* set if current block must be flushed */
; 1746 :     uInt prev;              /* byte at distance one to match */
; 1747 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1748 : 
; 1749 :     for (;;) {
; 1750 :         /* Make sure that we always have enough lookahead, except
; 1751 :          * at the end of the input file. We need MAX_MATCH bytes
; 1752 :          * for the longest encodable run.
; 1753 :          */
; 1754 :         if (s->lookahead < MAX_MATCH) {

  00010	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00018	81 b8 9c 00 00
	00 02 01 00 00	 cmp	 DWORD PTR [rax+156], 258 ; 00000102H
  00022	73 49		 jae	 SHORT $LN15@deflate_rl

; 1755 :             fill_window(s);

  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 fill_window

; 1756 :             if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {

  00031	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  00039	41 81 bb 9c 00
	00 00 02 01 00
	00		 cmp	 DWORD PTR [r11+156], 258 ; 00000102H
  00044	73 11		 jae	 SHORT $LN14@deflate_rl
  00046	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004e	75 07		 jne	 SHORT $LN14@deflate_rl

; 1757 :                 return need_more;

  00050	33 c0		 xor	 eax, eax
  00052	e9 7f 07 00 00	 jmp	 $LN18@deflate_rl
$LN14@deflate_rl:

; 1758 :             }
; 1759 :             if (s->lookahead == 0) break; /* flush the current block */

  00057	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00066	75 05		 jne	 SHORT $LN13@deflate_rl
  00068	e9 5b 06 00 00	 jmp	 $LN16@deflate_rl
$LN13@deflate_rl:
$LN15@deflate_rl:

; 1760 :         }
; 1761 : 
; 1762 :         /* See how many times the previous byte repeats */
; 1763 :         s->match_length = 0;

  0006d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00075	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1764 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0007f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00087	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0008e	0f 82 28 02 00
	00		 jb	 $LN12@deflate_rl
  00094	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009c	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000a3	0f 86 13 02 00
	00		 jbe	 $LN12@deflate_rl

; 1765 :             scan = s->window + s->strstart - 1;

  000a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b1	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  000b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bf	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c3	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  000c8	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax

; 1766 :             prev = *scan;

  000cd	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d5	89 44 24 20	 mov	 DWORD PTR prev$[rsp], eax

; 1767 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  000d9	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000de	48 83 c0 01	 add	 rax, 1
  000e2	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000ec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ef	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  000f3	0f 85 c3 01 00
	00		 jne	 $LN11@deflate_rl
  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000fe	48 83 c0 01	 add	 rax, 1
  00102	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0010c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0010f	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00113	0f 85 a3 01 00
	00		 jne	 $LN11@deflate_rl
  00119	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0011e	48 83 c0 01	 add	 rax, 1
  00122	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00127	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0012c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012f	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00133	0f 85 83 01 00
	00		 jne	 $LN11@deflate_rl

; 1768 :                 strend = s->window + s->strstart + MAX_MATCH;

  00139	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00141	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00147	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00153	48 8d 84 08 02
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+258]
  0015b	48 89 44 24 38	 mov	 QWORD PTR strend$[rsp], rax
$LN10@deflate_rl:

; 1769 :                 do {
; 1770 :                 } while (prev == *++scan && prev == *++scan &&
; 1771 :                          prev == *++scan && prev == *++scan &&
; 1772 :                          prev == *++scan && prev == *++scan &&
; 1773 :                          prev == *++scan && prev == *++scan &&
; 1774 :                          scan < strend);

  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00165	48 83 c0 01	 add	 rax, 1
  00169	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  0016e	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00173	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00176	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  0017a	0f 85 e0 00 00
	00		 jne	 $LN7@deflate_rl
  00180	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00185	48 83 c0 01	 add	 rax, 1
  00189	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  0018e	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00193	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00196	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  0019a	0f 85 c0 00 00
	00		 jne	 $LN7@deflate_rl
  001a0	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001a5	48 83 c0 01	 add	 rax, 1
  001a9	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001ae	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b6	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001ba	0f 85 a0 00 00
	00		 jne	 $LN7@deflate_rl
  001c0	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001c5	48 83 c0 01	 add	 rax, 1
  001c9	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001ce	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d6	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001da	0f 85 80 00 00
	00		 jne	 $LN7@deflate_rl
  001e0	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001e5	48 83 c0 01	 add	 rax, 1
  001e9	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001ee	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f6	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001fa	75 64		 jne	 SHORT $LN7@deflate_rl
  001fc	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00201	48 83 c0 01	 add	 rax, 1
  00205	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  0020a	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0020f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00212	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00216	75 48		 jne	 SHORT $LN7@deflate_rl
  00218	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0021d	48 83 c0 01	 add	 rax, 1
  00221	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00226	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0022b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0022e	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00232	75 2c		 jne	 SHORT $LN7@deflate_rl
  00234	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00239	48 83 c0 01	 add	 rax, 1
  0023d	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00242	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00247	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0024a	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  0024e	75 10		 jne	 SHORT $LN7@deflate_rl
  00250	48 8b 44 24 38	 mov	 rax, QWORD PTR strend$[rsp]
  00255	48 39 44 24 28	 cmp	 QWORD PTR scan$[rsp], rax
  0025a	0f 82 00 ff ff
	ff		 jb	 $LN10@deflate_rl
$LN7@deflate_rl:

; 1775 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  00260	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scan$[rsp]
  00265	48 8b 44 24 38	 mov	 rax, QWORD PTR strend$[rsp]
  0026a	48 2b c1	 sub	 rax, rcx
  0026d	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00272	2b c8		 sub	 ecx, eax
  00274	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0027c	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 1776 :                 if (s->match_length > s->lookahead)

  00282	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0028a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00292	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00298	39 81 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], eax
  0029e	76 1c		 jbe	 SHORT $LN6@deflate_rl

; 1777 :                     s->match_length = s->lookahead;

  002a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b0	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  002b6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN6@deflate_rl:
$LN11@deflate_rl:
$LN12@deflate_rl:

; 1778 :             }
; 1779 :         }
; 1780 : 
; 1781 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1782 :         if (s->match_length >= MIN_MATCH) {

  002bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c4	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  002cb	0f 82 02 02 00
	00		 jb	 $LN5@deflate_rl

; 1783 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1784 : 
; 1785 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  002d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002d9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002df	83 e8 03	 sub	 eax, 3
  002e2	88 44 24 40	 mov	 BYTE PTR len$78820[rsp], al
  002e6	b8 01 00 00 00	 mov	 eax, 1
  002eb	66 89 44 24 44	 mov	 WORD PTR dist$78821[rsp], ax
  002f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f8	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  002fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00306	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  0030d	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$78821[rsp]
  00312	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00316	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0031e	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00324	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00333	0f b6 44 24 40	 movzx	 eax, BYTE PTR len$78820[rsp]
  00338	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0033b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00343	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00349	83 c1 01	 add	 ecx, 1
  0034c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00354	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  0035a	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$78821[rsp]
  0035f	66 83 e8 01	 sub	 ax, 1
  00363	66 89 44 24 44	 mov	 WORD PTR dist$78821[rsp], ax
  00368	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR len$78820[rsp]
  0036d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  00374	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00378	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0037d	48 63 c8	 movsxd	 rcx, eax
  00380	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00388	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00390	66 83 c2 01	 add	 dx, 1
  00394	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR len$78820[rsp]
  00399	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  003a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003a4	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003a9	48 63 c8	 movsxd	 rcx, eax
  003ac	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003b4	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  003bc	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$78821[rsp]
  003c1	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  003c6	7d 16		 jge	 SHORT $LN20@deflate_rl
  003c8	0f b7 4c 24 44	 movzx	 ecx, WORD PTR dist$78821[rsp]
  003cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  003d4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003d8	89 44 24 4c	 mov	 DWORD PTR tv219[rsp], eax
  003dc	eb 1f		 jmp	 SHORT $LN21@deflate_rl
$LN20@deflate_rl:
  003de	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$78821[rsp]
  003e3	c1 f8 07	 sar	 eax, 7
  003e6	05 00 01 00 00	 add	 eax, 256		; 00000100H
  003eb	48 63 c8	 movsxd	 rcx, eax
  003ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  003f5	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003f9	89 44 24 4c	 mov	 DWORD PTR tv219[rsp], eax
$LN21@deflate_rl:
  003fd	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR tv219[rsp]
  00402	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0040a	0f b7 94 88 b0
	09 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+2480]
  00412	66 83 c2 01	 add	 dx, 1
  00416	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR tv219[rsp]
  0041b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00423	66 89 94 88 b0
	09 00 00	 mov	 WORD PTR [rax+rcx*4+2480], dx
  0042b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00433	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00439	83 e9 01	 sub	 ecx, 1
  0043c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00444	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  0044a	75 0a		 jne	 SHORT $LN22@deflate_rl
  0044c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv236[rsp], 1
  00454	eb 08		 jmp	 SHORT $LN23@deflate_rl
$LN22@deflate_rl:
  00456	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN23@deflate_rl:
  0045e	8b 44 24 50	 mov	 eax, DWORD PTR tv236[rsp]
  00462	89 44 24 30	 mov	 DWORD PTR bflush$[rsp], eax

; 1786 : 
; 1787 :             s->lookahead -= s->match_length;

  00466	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0046e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00476	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0047c	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00482	2b c8		 sub	 ecx, eax
  00484	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0048c	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1788 :             s->strstart += s->match_length;

  00492	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0049a	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  004a0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004a8	03 88 88 00 00
	00		 add	 ecx, DWORD PTR [rax+136]
  004ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b6	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1789 :             s->match_length = 0;

  004bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004c4	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1790 :         } else {

  004ce	e9 30 01 00 00	 jmp	 $LN4@deflate_rl
$LN5@deflate_rl:

; 1791 :             /* No match, output a literal byte */
; 1792 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1793 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  004d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004db	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  004e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004e9	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  004ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004f1	88 44 24 48	 mov	 BYTE PTR cc$78823[rsp], al
  004f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004fd	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00503	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0050b	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00512	33 c0		 xor	 eax, eax
  00514	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00518	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00520	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00526	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0052e	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00535	0f b6 44 24 48	 movzx	 eax, BYTE PTR cc$78823[rsp]
  0053a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0053d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00545	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  0054b	83 c1 01	 add	 ecx, 1
  0054e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00556	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  0055c	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR cc$78823[rsp]
  00561	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00569	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00571	66 83 c2 01	 add	 dx, 1
  00575	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR cc$78823[rsp]
  0057a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00582	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  0058a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00592	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00598	83 e9 01	 sub	 ecx, 1
  0059b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005a3	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  005a9	75 0a		 jne	 SHORT $LN24@deflate_rl
  005ab	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv279[rsp], 1
  005b3	eb 08		 jmp	 SHORT $LN25@deflate_rl
$LN24@deflate_rl:
  005b5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv279[rsp], 0
$LN25@deflate_rl:
  005bd	8b 44 24 54	 mov	 eax, DWORD PTR tv279[rsp]
  005c1	89 44 24 30	 mov	 DWORD PTR bflush$[rsp], eax

; 1794 :             s->lookahead--;

  005c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005cd	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  005d3	83 e9 01	 sub	 ecx, 1
  005d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005de	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1795 :             s->strstart++;

  005e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ec	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  005f2	83 c1 01	 add	 ecx, 1
  005f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fd	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
$LN4@deflate_rl:

; 1796 :         }
; 1797 :         if (bflush) FLUSH_BLOCK(s, 0);

  00603	83 7c 24 30 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00608	0f 84 b5 00 00
	00		 je	 $LN3@deflate_rl
  0060e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00616	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0061d	7c 21		 jl	 SHORT $LN26@deflate_rl
  0061f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00627	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0062d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00635	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00639	48 89 44 24 58	 mov	 QWORD PTR tv300[rsp], rax
  0063e	eb 09		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  00640	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv300[rsp], 0
$LN27@deflate_rl:
  00649	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00651	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00659	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0065f	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00666	44 2b c0	 sub	 r8d, eax
  00669	45 33 c9	 xor	 r9d, r9d
  0066c	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv300[rsp]
  00671	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00679	e8 00 00 00 00	 call	 _tr_flush_block
  0067e	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  00686	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0068e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00694	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  0069b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006a6	e8 00 00 00 00	 call	 flush_pending
  006ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006b6	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006ba	75 07		 jne	 SHORT $LN2@deflate_rl
  006bc	33 c0		 xor	 eax, eax
  006be	e9 13 01 00 00	 jmp	 $LN18@deflate_rl
$LN2@deflate_rl:
$LN3@deflate_rl:

; 1798 :     }

  006c3	e9 48 f9 ff ff	 jmp	 $LN17@deflate_rl
$LN16@deflate_rl:

; 1799 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  006c8	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  006d0	75 0a		 jne	 SHORT $LN28@deflate_rl
  006d2	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv309[rsp], 1
  006da	eb 08		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  006dc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv309[rsp], 0
$LN29@deflate_rl:
  006e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ec	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  006f3	7c 21		 jl	 SHORT $LN30@deflate_rl
  006f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006fd	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00703	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0070b	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0070f	48 89 44 24 68	 mov	 QWORD PTR tv321[rsp], rax
  00714	eb 09		 jmp	 SHORT $LN31@deflate_rl
$LN30@deflate_rl:
  00716	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv321[rsp], 0
$LN31@deflate_rl:
  0071f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00727	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0072f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00735	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0073c	44 2b c0	 sub	 r8d, eax
  0073f	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv309[rsp]
  00744	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv321[rsp]
  00749	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00751	e8 00 00 00 00	 call	 _tr_flush_block
  00756	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  0075e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00766	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0076c	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00773	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0077b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0077e	e8 00 00 00 00	 call	 flush_pending
  00783	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0078b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0078e	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00792	75 22		 jne	 SHORT $LN1@deflate_rl
  00794	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0079c	75 0a		 jne	 SHORT $LN32@deflate_rl
  0079e	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv330[rsp], 2
  007a6	eb 08		 jmp	 SHORT $LN33@deflate_rl
$LN32@deflate_rl:
  007a8	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN33@deflate_rl:
  007b0	8b 44 24 70	 mov	 eax, DWORD PTR tv330[rsp]
  007b4	eb 20		 jmp	 SHORT $LN18@deflate_rl
$LN1@deflate_rl:

; 1800 :     return flush == Z_FINISH ? finish_done : block_done;

  007b6	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  007be	75 0a		 jne	 SHORT $LN34@deflate_rl
  007c0	c7 44 24 74 03
	00 00 00	 mov	 DWORD PTR tv332[rsp], 3
  007c8	eb 08		 jmp	 SHORT $LN35@deflate_rl
$LN34@deflate_rl:
  007ca	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv332[rsp], 1
$LN35@deflate_rl:
  007d2	8b 44 24 74	 mov	 eax, DWORD PTR tv332[rsp]
$LN18@deflate_rl:

; 1801 : }

  007d6	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  007dd	c3		 ret	 0
deflate_rle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+3086
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_slow
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
max_insert$78763 = 40
len$78764 = 44
dist$78765 = 48
cc$78780 = 52
cc$78790 = 53
tv242 = 56
tv259 = 60
tv335 = 64
tv379 = 72
tv392 = 80
tv453 = 88
tv456 = 92
tv468 = 96
tv477 = 104
tv479 = 108
s$ = 128
flush$ = 136
deflate_slow PROC					; COMDAT

; 1619 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN23@deflate_sl:

; 1620 :     IPos hash_head;          /* head of hash chain */
; 1621 :     int bflush;              /* set if current block must be flushed */
; 1622 : 
; 1623 :     /* Process the input block. */
; 1624 :     for (;;) {
; 1625 :         /* Make sure that we always have enough lookahead, except
; 1626 :          * at the end of the input file. We need MAX_MATCH bytes
; 1627 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1628 :          * string following the next match.
; 1629 :          */
; 1630 :         if (s->lookahead < MIN_LOOKAHEAD) {

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00015	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  0001f	73 49		 jae	 SHORT $LN21@deflate_sl

; 1631 :             fill_window(s);

  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 fill_window

; 1632 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  0002e	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  00036	41 81 bb 9c 00
	00 00 06 01 00
	00		 cmp	 DWORD PTR [r11+156], 262 ; 00000106H
  00041	73 11		 jae	 SHORT $LN20@deflate_sl
  00043	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004b	75 07		 jne	 SHORT $LN20@deflate_sl

; 1633 :                 return need_more;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 b5 0b 00 00	 jmp	 $LN24@deflate_sl
$LN20@deflate_sl:

; 1634 :             }
; 1635 :             if (s->lookahead == 0) break; /* flush the current block */

  00054	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005c	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00063	75 05		 jne	 SHORT $LN19@deflate_sl
  00065	e9 73 09 00 00	 jmp	 $LN22@deflate_sl
$LN19@deflate_sl:
$LN21@deflate_sl:

; 1636 :         }
; 1637 : 
; 1638 :         /* Insert the string window[strstart .. strstart+2] in the
; 1639 :          * dictionary, and set hash_head to the head of the hash chain:
; 1640 :          */
; 1641 :         hash_head = NIL;

  0006a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1642 :         if (s->lookahead >= MIN_MATCH) {

  00072	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007a	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00081	0f 82 fd 00 00
	00		 jb	 $LN18@deflate_sl

; 1643 :             INSERT_STRING(s, s->strstart, hash_head);

  00087	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0008f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00095	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009d	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  000a0	d3 e2		 shl	 edx, cl
  000a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000aa	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000b0	83 c0 02	 add	 eax, 2
  000b3	8b c8		 mov	 ecx, eax
  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c5	8b ca		 mov	 ecx, edx
  000c7	33 c8		 xor	 ecx, eax
  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d1	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  000d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000dc	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  000df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e7	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  000eb	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  000f3	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  000f7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00107	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0010a	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00110	23 c1		 and	 eax, ecx
  00112	8b d0		 mov	 edx, eax
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0011c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00120	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00125	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00129	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00131	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00139	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0013c	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00142	23 c1		 and	 eax, ecx
  00144	8b c8		 mov	 ecx, eax
  00146	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00152	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00156	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  0015a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00162	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00165	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00171	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00179	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  00180	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN18@deflate_sl:

; 1644 :         }
; 1645 : 
; 1646 :         /* Find the longest match, discarding those <= prev_length.
; 1647 :          */
; 1648 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  00184	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0018c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00194	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0019a	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b0	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  001b6	89 81 8c 00 00
	00		 mov	 DWORD PTR [rcx+140], eax

; 1649 :         s->match_length = MIN_MATCH-1;

  001bc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c4	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1650 : 
; 1651 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1652 :             s->strstart - hash_head <= MAX_DIST(s)) {

  001ce	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  001d3	0f 84 db 00 00
	00		 je	 $LN17@deflate_sl
  001d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e9	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  001ef	39 81 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], eax
  001f5	0f 83 b9 00 00
	00		 jae	 $LN17@deflate_sl
  001fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00203	8b 44 24 24	 mov	 eax, DWORD PTR hash_head$[rsp]
  00207	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0020d	2b c8		 sub	 ecx, eax
  0020f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00217	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0021a	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0021f	3b c8		 cmp	 ecx, eax
  00221	0f 87 8d 00 00
	00		 ja	 $LN17@deflate_sl

; 1653 :             /* To simplify the code, we prevent matches with the string
; 1654 :              * of window index 0 (in particular we have to avoid a match
; 1655 :              * of the string with itself at the start of the input file).
; 1656 :              */
; 1657 :             s->match_length = longest_match (s, hash_head);

  00227	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0022b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00233	e8 00 00 00 00	 call	 longest_match
  00238	44 8b d8	 mov	 r11d, eax
  0023b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00243	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d

; 1658 :             /* longest_match() sets match_start */
; 1659 : 
; 1660 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1661 : #if TOO_FAR <= 32767
; 1662 :                 || (s->match_length == MIN_MATCH &&
; 1663 :                     s->strstart - s->match_start > TOO_FAR)
; 1664 : #endif
; 1665 :                 )) {

  0024a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00252	83 b8 88 00 00
	00 05		 cmp	 DWORD PTR [rax+136], 5
  00259	77 59		 ja	 SHORT $LN16@deflate_sl
  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00263	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [rax+176], 1
  0026a	74 36		 je	 SHORT $LN15@deflate_sl
  0026c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00274	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  0027b	75 37		 jne	 SHORT $LN16@deflate_sl
  0027d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00285	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0028d	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [rax+152]
  00293	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00299	2b c1		 sub	 eax, ecx
  0029b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002a0	76 12		 jbe	 SHORT $LN16@deflate_sl
$LN15@deflate_sl:

; 1666 : 
; 1667 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1668 :                  * but we will ignore the current match anyway.
; 1669 :                  */
; 1670 :                 s->match_length = MIN_MATCH-1;

  002a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002aa	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2
$LN16@deflate_sl:
$LN17@deflate_sl:

; 1671 :             }
; 1672 :         }
; 1673 :         /* If there was a match at the previous step and the current
; 1674 :          * match is not better, output the previous match:
; 1675 :          */
; 1676 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002bc	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  002c3	0f 82 b3 04 00
	00		 jb	 $LN14@deflate_sl
  002c9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002d9	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  002df	39 81 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], eax
  002e5	0f 87 91 04 00
	00		 ja	 $LN14@deflate_sl

; 1677 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  002eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f3	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  002f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00301	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00307	8d 44 01 fd	 lea	 eax, DWORD PTR [rcx+rax-3]
  0030b	89 44 24 28	 mov	 DWORD PTR max_insert$78763[rsp], eax

; 1678 :             /* Do not insert strings in hash table beyond this. */
; 1679 : 
; 1680 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1681 : 
; 1682 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1683 :                            s->prev_length - MIN_MATCH, bflush);

  0030f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00317	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  0031d	83 e8 03	 sub	 eax, 3
  00320	88 44 24 2c	 mov	 BYTE PTR len$78764[rsp], al
  00324	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0032c	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00332	83 e8 01	 sub	 eax, 1
  00335	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0033d	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [rcx+140]
  00343	66 89 44 24 30	 mov	 WORD PTR dist$78765[rsp], ax
  00348	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00350	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00356	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035e	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00365	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78765[rsp]
  0036a	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0036e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00376	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  0037c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00384	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  0038b	0f b6 44 24 2c	 movzx	 eax, BYTE PTR len$78764[rsp]
  00390	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00393	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0039b	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  003a1	83 c1 01	 add	 ecx, 1
  003a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ac	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  003b2	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78765[rsp]
  003b7	66 83 e8 01	 sub	 ax, 1
  003bb	66 89 44 24 30	 mov	 WORD PTR dist$78765[rsp], ax
  003c0	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$78764[rsp]
  003c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  003cc	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003d0	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003d5	48 63 c8	 movsxd	 rcx, eax
  003d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003e0	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  003e8	66 83 c2 01	 add	 dx, 1
  003ec	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$78764[rsp]
  003f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  003f8	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003fc	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00401	48 63 c8	 movsxd	 rcx, eax
  00404	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0040c	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  00414	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78765[rsp]
  00419	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0041e	7d 16		 jge	 SHORT $LN26@deflate_sl
  00420	0f b7 4c 24 30	 movzx	 ecx, WORD PTR dist$78765[rsp]
  00425	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  0042c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00430	89 44 24 38	 mov	 DWORD PTR tv242[rsp], eax
  00434	eb 1f		 jmp	 SHORT $LN27@deflate_sl
$LN26@deflate_sl:
  00436	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78765[rsp]
  0043b	c1 f8 07	 sar	 eax, 7
  0043e	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00443	48 63 c8	 movsxd	 rcx, eax
  00446	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  0044d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00451	89 44 24 38	 mov	 DWORD PTR tv242[rsp], eax
$LN27@deflate_sl:
  00455	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tv242[rsp]
  0045a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00462	0f b7 94 88 b0
	09 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+2480]
  0046a	66 83 c2 01	 add	 dx, 1
  0046e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tv242[rsp]
  00473	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0047b	66 89 94 88 b0
	09 00 00	 mov	 WORD PTR [rax+rcx*4+2480], dx
  00483	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0048b	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00491	83 e9 01	 sub	 ecx, 1
  00494	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0049c	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  004a2	75 0a		 jne	 SHORT $LN28@deflate_sl
  004a4	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv259[rsp], 1
  004ac	eb 08		 jmp	 SHORT $LN29@deflate_sl
$LN28@deflate_sl:
  004ae	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv259[rsp], 0
$LN29@deflate_sl:
  004b6	8b 44 24 3c	 mov	 eax, DWORD PTR tv259[rsp]
  004ba	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1684 : 
; 1685 :             /* Insert in hash table all strings up to the end of the match.
; 1686 :              * strstart-1 and strstart are already inserted. If there is not
; 1687 :              * enough lookahead, the last two strings are not inserted in
; 1688 :              * the hash table.
; 1689 :              */
; 1690 :             s->lookahead -= s->prev_length-1;

  004be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004c6	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [rax+160]
  004cc	83 ea 01	 sub	 edx, 1
  004cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d7	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  004dd	2b ca		 sub	 ecx, edx
  004df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004e7	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1691 :             s->prev_length -= 2;

  004ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004f5	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  004fb	83 e9 02	 sub	 ecx, 2
  004fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00506	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
$LN13@deflate_sl:

; 1692 :             do {
; 1693 :                 if (++s->strstart <= max_insert) {

  0050c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00514	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0051a	83 c1 01	 add	 ecx, 1
  0051d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00525	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
  0052b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00533	8b 44 24 28	 mov	 eax, DWORD PTR max_insert$78763[rsp]
  00537	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  0053d	0f 87 fd 00 00
	00		 ja	 $LN10@deflate_sl

; 1694 :                     INSERT_STRING(s, s->strstart, hash_head);

  00543	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0054b	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00551	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00559	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  0055c	d3 e2		 shl	 edx, cl
  0055e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00566	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0056c	83 c0 02	 add	 eax, 2
  0056f	8b c8		 mov	 ecx, eax
  00571	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00579	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0057d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00581	8b ca		 mov	 ecx, edx
  00583	33 c8		 xor	 ecx, eax
  00585	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0058d	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  00590	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00598	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  0059b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005a3	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  005a7	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  005af	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  005b3	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005c3	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  005c6	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  005cc	23 c1		 and	 eax, ecx
  005ce	8b d0		 mov	 edx, eax
  005d0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d8	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  005dc	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  005e1	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  005e5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005f5	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  005f8	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  005fe	23 c1		 and	 eax, ecx
  00600	8b c8		 mov	 ecx, eax
  00602	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0060a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0060e	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00612	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00616	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061e	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00621	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00629	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0062d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00635	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  0063c	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN10@deflate_sl:

; 1695 :                 }
; 1696 :             } while (--s->prev_length != 0);

  00640	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00648	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  0064e	83 e9 01	 sub	 ecx, 1
  00651	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00659	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  0065f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00667	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  0066e	0f 85 98 fe ff
	ff		 jne	 $LN13@deflate_sl

; 1697 :             s->match_available = 0;

  00674	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0067c	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1698 :             s->match_length = MIN_MATCH-1;

  00686	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0068e	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1699 :             s->strstart++;

  00698	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006a0	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  006a6	83 c1 01	 add	 ecx, 1
  006a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b1	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1700 : 
; 1701 :             if (bflush) FLUSH_BLOCK(s, 0);

  006b7	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  006bc	0f 84 b5 00 00
	00		 je	 $LN9@deflate_sl
  006c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ca	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  006d1	7c 21		 jl	 SHORT $LN30@deflate_sl
  006d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006db	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  006e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e9	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  006ed	48 89 44 24 40	 mov	 QWORD PTR tv335[rsp], rax
  006f2	eb 09		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  006f4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv335[rsp], 0
$LN31@deflate_sl:
  006fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00705	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0070d	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00713	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0071a	44 2b c0	 sub	 r8d, eax
  0071d	45 33 c9	 xor	 r9d, r9d
  00720	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv335[rsp]
  00725	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0072d	e8 00 00 00 00	 call	 _tr_flush_block
  00732	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  0073a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00742	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00748	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  0074f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00757	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0075a	e8 00 00 00 00	 call	 flush_pending
  0075f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00767	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0076a	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0076e	75 07		 jne	 SHORT $LN8@deflate_sl
  00770	33 c0		 xor	 eax, eax
  00772	e9 92 04 00 00	 jmp	 $LN24@deflate_sl
$LN8@deflate_sl:
$LN9@deflate_sl:
  00777	e9 5c 02 00 00	 jmp	 $LN7@deflate_sl
$LN14@deflate_sl:

; 1702 : 
; 1703 :         } else if (s->match_available) {

  0077c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00784	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  0078b	0f 84 f7 01 00
	00		 je	 $LN6@deflate_sl

; 1704 :             /* If there was no match at the previous position, output a
; 1705 :              * single literal. If there was a match but the current match
; 1706 :              * is longer, truncate the previous match to a single literal.
; 1707 :              */
; 1708 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1709 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00791	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00799	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0079f	83 e8 01	 sub	 eax, 1
  007a2	8b c8		 mov	 ecx, eax
  007a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007ac	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  007b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b4	88 44 24 34	 mov	 BYTE PTR cc$78780[rsp], al
  007b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c0	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  007c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ce	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  007d5	33 c0		 xor	 eax, eax
  007d7	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  007db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e3	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  007e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007f1	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  007f8	0f b6 44 24 34	 movzx	 eax, BYTE PTR cc$78780[rsp]
  007fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00800	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00808	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  0080e	83 c1 01	 add	 ecx, 1
  00811	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00819	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  0081f	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$78780[rsp]
  00824	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0082c	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00834	66 83 c2 01	 add	 dx, 1
  00838	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$78780[rsp]
  0083d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00845	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  0084d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00855	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  0085b	83 e9 01	 sub	 ecx, 1
  0085e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00866	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  0086c	75 0a		 jne	 SHORT $LN32@deflate_sl
  0086e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv379[rsp], 1
  00876	eb 08		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  00878	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv379[rsp], 0
$LN33@deflate_sl:
  00880	8b 44 24 48	 mov	 eax, DWORD PTR tv379[rsp]
  00884	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1710 :             if (bflush) {

  00888	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  0088d	0f 84 9d 00 00
	00		 je	 $LN5@deflate_sl

; 1711 :                 FLUSH_BLOCK_ONLY(s, 0);

  00893	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0089b	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  008a2	7c 21		 jl	 SHORT $LN34@deflate_sl
  008a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008ac	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008ba	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  008be	48 89 44 24 50	 mov	 QWORD PTR tv392[rsp], rax
  008c3	eb 09		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  008c5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv392[rsp], 0
$LN35@deflate_sl:
  008ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008de	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008e4	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  008eb	44 2b c0	 sub	 r8d, eax
  008ee	45 33 c9	 xor	 r9d, r9d
  008f1	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv392[rsp]
  008f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008fe	e8 00 00 00 00	 call	 _tr_flush_block
  00903	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  0090b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00913	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00919	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00920	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00928	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0092b	e8 00 00 00 00	 call	 flush_pending
$LN5@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;

  00930	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00938	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0093e	83 c1 01	 add	 ecx, 1
  00941	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00949	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1714 :             s->lookahead--;

  0094f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00957	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  0095d	83 e9 01	 sub	 ecx, 1
  00960	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00968	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1715 :             if (s->strm->avail_out == 0) return need_more;

  0096e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00976	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00979	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0097d	75 07		 jne	 SHORT $LN4@deflate_sl
  0097f	33 c0		 xor	 eax, eax
  00981	e9 83 02 00 00	 jmp	 $LN24@deflate_sl
$LN4@deflate_sl:

; 1716 :         } else {

  00986	eb 50		 jmp	 SHORT $LN3@deflate_sl
$LN6@deflate_sl:

; 1717 :             /* There is no previous match to compare with, wait for
; 1718 :              * the next step to decide.
; 1719 :              */
; 1720 :             s->match_available = 1;

  00988	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00990	c7 80 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+144], 1

; 1721 :             s->strstart++;

  0099a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009a2	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  009a8	83 c1 01	 add	 ecx, 1
  009ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009b3	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1722 :             s->lookahead--;

  009b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009c1	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  009c7	83 e9 01	 sub	 ecx, 1
  009ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009d2	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx
$LN3@deflate_sl:
$LN7@deflate_sl:

; 1723 :         }
; 1724 :     }

  009d8	e9 30 f6 ff ff	 jmp	 $LN23@deflate_sl
$LN22@deflate_sl:

; 1725 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1726 :     if (s->match_available) {

  009dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009e5	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  009ec	0f 84 09 01 00
	00		 je	 $LN2@deflate_sl

; 1727 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1728 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  009f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009fa	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00a00	83 e8 01	 sub	 eax, 1
  00a03	8b c8		 mov	 ecx, eax
  00a05	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a0d	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00a11	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a15	88 44 24 35	 mov	 BYTE PTR cc$78790[rsp], al
  00a19	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a21	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00a27	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a2f	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00a36	33 c0		 xor	 eax, eax
  00a38	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00a3c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a44	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00a4a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a52	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00a59	0f b6 44 24 35	 movzx	 eax, BYTE PTR cc$78790[rsp]
  00a5e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00a61	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a69	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00a6f	83 c1 01	 add	 ecx, 1
  00a72	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a7a	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  00a80	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$78790[rsp]
  00a85	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a8d	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00a95	66 83 c2 01	 add	 dx, 1
  00a99	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$78790[rsp]
  00a9e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aa6	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  00aae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ab6	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00abc	83 e9 01	 sub	 ecx, 1
  00abf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ac7	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  00acd	75 0a		 jne	 SHORT $LN36@deflate_sl
  00acf	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv453[rsp], 1
  00ad7	eb 08		 jmp	 SHORT $LN37@deflate_sl
$LN36@deflate_sl:
  00ad9	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv453[rsp], 0
$LN37@deflate_sl:
  00ae1	8b 44 24 58	 mov	 eax, DWORD PTR tv453[rsp]
  00ae5	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1729 :         s->match_available = 0;

  00ae9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00af1	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0
$LN2@deflate_sl:

; 1730 :     }
; 1731 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00afb	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00b03	75 0a		 jne	 SHORT $LN38@deflate_sl
  00b05	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv456[rsp], 1
  00b0d	eb 08		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  00b0f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv456[rsp], 0
$LN39@deflate_sl:
  00b17	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b1f	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00b26	7c 21		 jl	 SHORT $LN40@deflate_sl
  00b28	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b30	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00b36	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b3e	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00b42	48 89 44 24 60	 mov	 QWORD PTR tv468[rsp], rax
  00b47	eb 09		 jmp	 SHORT $LN41@deflate_sl
$LN40@deflate_sl:
  00b49	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv468[rsp], 0
$LN41@deflate_sl:
  00b52	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b5a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b62	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00b68	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00b6f	44 2b c0	 sub	 r8d, eax
  00b72	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR tv456[rsp]
  00b77	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv468[rsp]
  00b7c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b84	e8 00 00 00 00	 call	 _tr_flush_block
  00b89	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  00b91	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b99	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00b9f	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00ba6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bae	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00bb1	e8 00 00 00 00	 call	 flush_pending
  00bb6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bbe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bc1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00bc5	75 22		 jne	 SHORT $LN1@deflate_sl
  00bc7	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00bcf	75 0a		 jne	 SHORT $LN42@deflate_sl
  00bd1	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv477[rsp], 2
  00bd9	eb 08		 jmp	 SHORT $LN43@deflate_sl
$LN42@deflate_sl:
  00bdb	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv477[rsp], 0
$LN43@deflate_sl:
  00be3	8b 44 24 68	 mov	 eax, DWORD PTR tv477[rsp]
  00be7	eb 20		 jmp	 SHORT $LN24@deflate_sl
$LN1@deflate_sl:

; 1732 :     return flush == Z_FINISH ? finish_done : block_done;

  00be9	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00bf1	75 0a		 jne	 SHORT $LN44@deflate_sl
  00bf3	c7 44 24 6c 03
	00 00 00	 mov	 DWORD PTR tv479[rsp], 3
  00bfb	eb 08		 jmp	 SHORT $LN45@deflate_sl
$LN44@deflate_sl:
  00bfd	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv479[rsp], 1
$LN45@deflate_sl:
  00c05	8b 44 24 6c	 mov	 eax, DWORD PTR tv479[rsp]
$LN24@deflate_sl:

; 1733 : }

  00c09	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00c0d	c3		 ret	 0
deflate_slow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+2012
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_fast
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
len$78722 = 40
dist$78723 = 44
cc$78731 = 48
tv215 = 52
tv232 = 56
tv355 = 60
tv376 = 64
tv385 = 72
tv397 = 80
tv406 = 88
tv408 = 92
s$ = 112
flush$ = 120
deflate_fast PROC					; COMDAT

; 1523 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN17@deflate_fa:

; 1524 :     IPos hash_head;       /* head of the hash chain */
; 1525 :     int bflush;           /* set if current block must be flushed */
; 1526 : 
; 1527 :     for (;;) {
; 1528 :         /* Make sure that we always have enough lookahead, except
; 1529 :          * at the end of the input file. We need MAX_MATCH bytes
; 1530 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1531 :          * string following the next match.
; 1532 :          */
; 1533 :         if (s->lookahead < MIN_LOOKAHEAD) {

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00012	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  0001c	73 3d		 jae	 SHORT $LN15@deflate_fa

; 1534 :             fill_window(s);

  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 fill_window

; 1535 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00028	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  0002d	41 81 bb 9c 00
	00 00 06 01 00
	00		 cmp	 DWORD PTR [r11+156], 262 ; 00000106H
  00038	73 0e		 jae	 SHORT $LN14@deflate_fa
  0003a	83 7c 24 78 00	 cmp	 DWORD PTR flush$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN14@deflate_fa

; 1536 :                 return need_more;

  00041	33 c0		 xor	 eax, eax
  00043	e9 8f 07 00 00	 jmp	 $LN18@deflate_fa
$LN14@deflate_fa:

; 1537 :             }
; 1538 :             if (s->lookahead == 0) break; /* flush the current block */

  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0004d	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00054	75 05		 jne	 SHORT $LN13@deflate_fa
  00056	e9 95 06 00 00	 jmp	 $LN16@deflate_fa
$LN13@deflate_fa:
$LN15@deflate_fa:

; 1539 :         }
; 1540 : 
; 1541 :         /* Insert the string window[strstart .. strstart+2] in the
; 1542 :          * dictionary, and set hash_head to the head of the hash chain:
; 1543 :          */
; 1544 :         hash_head = NIL;

  0005b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1545 :         if (s->lookahead >= MIN_MATCH) {

  00063	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00068	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0006f	0f 82 ca 00 00
	00		 jb	 $LN12@deflate_fa

; 1546 :             INSERT_STRING(s, s->strstart, hash_head);

  00075	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0007a	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00085	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0008f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00095	83 c0 02	 add	 eax, 2
  00098	8b c8		 mov	 ecx, eax
  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0009f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000a3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a7	8b ca		 mov	 ecx, edx
  000a9	33 c8		 xor	 ecx, eax
  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b0	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  000b3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b8	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000c0	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  000c4	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  000c9	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  000cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  000d2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000d7	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000da	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  000e0	23 c1		 and	 eax, ecx
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ed	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  000f2	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  000f6	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00100	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00103	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00109	23 c1		 and	 eax, ecx
  0010b	8b c8		 mov	 ecx, eax
  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00112	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00116	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0011a	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00123	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0012f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00134	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  0013b	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN12@deflate_fa:

; 1547 :         }
; 1548 : 
; 1549 :         /* Find the longest match, discarding those <= prev_length.
; 1550 :          * At this point we have always match_length < MIN_MATCH
; 1551 :          */
; 1552 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  0013f	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  00144	74 3f		 je	 SHORT $LN11@deflate_fa
  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0014b	8b 44 24 24	 mov	 eax, DWORD PTR hash_head$[rsp]
  0014f	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00155	2b c8		 sub	 ecx, eax
  00157	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0015c	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0015f	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00164	3b c8		 cmp	 ecx, eax
  00166	77 1d		 ja	 SHORT $LN11@deflate_fa

; 1553 :             /* To simplify the code, we prevent matches with the string
; 1554 :              * of window index 0 (in particular we have to avoid a match
; 1555 :              * of the string with itself at the start of the input file).
; 1556 :              */
; 1557 :             s->match_length = longest_match (s, hash_head);

  00168	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0016c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00171	e8 00 00 00 00	 call	 longest_match
  00176	44 8b d8	 mov	 r11d, eax
  00179	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0017e	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d
$LN11@deflate_fa:

; 1558 :             /* longest_match() sets match_start */
; 1559 :         }
; 1560 :         if (s->match_length >= MIN_MATCH) {

  00185	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0018a	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  00191	0f 82 b2 03 00
	00		 jb	 $LN10@deflate_fa

; 1561 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1562 : 
; 1563 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1564 :                            s->match_length - MIN_MATCH, bflush);

  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0019c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001a2	83 e8 03	 sub	 eax, 3
  001a5	88 44 24 28	 mov	 BYTE PTR len$78722[rsp], al
  001a9	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  001ae	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001b3	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [rax+152]
  001b9	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  001bf	2b c1		 sub	 eax, ecx
  001c1	66 89 44 24 2c	 mov	 WORD PTR dist$78723[rsp], ax
  001c6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001cb	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  001d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001d6	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  001dd	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78723[rsp]
  001e2	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  001e6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001eb	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  001f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001f6	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  001fd	0f b6 44 24 28	 movzx	 eax, BYTE PTR len$78722[rsp]
  00202	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00205	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0020a	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00210	83 c1 01	 add	 ecx, 1
  00213	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00218	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  0021e	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78723[rsp]
  00223	66 83 e8 01	 sub	 ax, 1
  00227	66 89 44 24 2c	 mov	 WORD PTR dist$78723[rsp], ax
  0022c	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$78722[rsp]
  00231	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  00238	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0023c	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00241	48 63 c8	 movsxd	 rcx, eax
  00244	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00249	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00251	66 83 c2 01	 add	 dx, 1
  00255	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$78722[rsp]
  0025a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  00261	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00265	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0026a	48 63 c8	 movsxd	 rcx, eax
  0026d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00272	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  0027a	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78723[rsp]
  0027f	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00284	7d 16		 jge	 SHORT $LN20@deflate_fa
  00286	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR dist$78723[rsp]
  0028b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  00292	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00296	89 44 24 34	 mov	 DWORD PTR tv215[rsp], eax
  0029a	eb 1f		 jmp	 SHORT $LN21@deflate_fa
$LN20@deflate_fa:
  0029c	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78723[rsp]
  002a1	c1 f8 07	 sar	 eax, 7
  002a4	05 00 01 00 00	 add	 eax, 256		; 00000100H
  002a9	48 63 c8	 movsxd	 rcx, eax
  002ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  002b3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002b7	89 44 24 34	 mov	 DWORD PTR tv215[rsp], eax
$LN21@deflate_fa:
  002bb	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR tv215[rsp]
  002c0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002c5	0f b7 94 88 b0
	09 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+2480]
  002cd	66 83 c2 01	 add	 dx, 1
  002d1	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR tv215[rsp]
  002d6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002db	66 89 94 88 b0
	09 00 00	 mov	 WORD PTR [rax+rcx*4+2480], dx
  002e3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002e8	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  002ee	83 e9 01	 sub	 ecx, 1
  002f1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002f6	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  002fc	75 0a		 jne	 SHORT $LN22@deflate_fa
  002fe	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv232[rsp], 1
  00306	eb 08		 jmp	 SHORT $LN23@deflate_fa
$LN22@deflate_fa:
  00308	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
$LN23@deflate_fa:
  00310	8b 44 24 38	 mov	 eax, DWORD PTR tv232[rsp]
  00314	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1565 : 
; 1566 :             s->lookahead -= s->match_length;

  00318	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0031d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00322	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00328	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  0032e	2b c8		 sub	 ecx, eax
  00330	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00335	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1567 : 
; 1568 :             /* Insert new strings in the hash table only if the match length
; 1569 :              * is not too large. This saves time but degrades compression.
; 1570 :              */
; 1571 : #ifndef FASTEST
; 1572 :             if (s->match_length <= s->max_insert_length &&
; 1573 :                 s->lookahead >= MIN_MATCH) {

  0033b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00340	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00345	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  0034b	39 81 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], eax
  00351	0f 87 57 01 00
	00		 ja	 $LN9@deflate_fa
  00357	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0035c	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00363	0f 82 45 01 00
	00		 jb	 $LN9@deflate_fa

; 1574 :                 s->match_length--; /* string at strstart already in table */

  00369	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0036e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00374	83 e9 01	 sub	 ecx, 1
  00377	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0037c	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN8@deflate_fa:

; 1575 :                 do {
; 1576 :                     s->strstart++;

  00382	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00387	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0038d	83 c1 01	 add	 ecx, 1
  00390	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00395	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1577 :                     INSERT_STRING(s, s->strstart, hash_head);

  0039b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003a0	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  003a6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003ab	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  003ae	d3 e2		 shl	 edx, cl
  003b0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003b5	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  003bb	83 c0 02	 add	 eax, 2
  003be	8b c8		 mov	 ecx, eax
  003c0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003c5	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  003c9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003cd	8b ca		 mov	 ecx, edx
  003cf	33 c8		 xor	 ecx, eax
  003d1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003d6	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  003d9	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003de	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  003e1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003e6	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  003ea	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  003ef	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  003f3	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  003f8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003fd	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00400	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00406	23 c1		 and	 eax, ecx
  00408	8b d0		 mov	 edx, eax
  0040a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0040f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00413	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00418	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0041c	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00421	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00426	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00429	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  0042f	23 c1		 and	 eax, ecx
  00431	8b c8		 mov	 ecx, eax
  00433	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00438	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0043c	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00440	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00444	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00449	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  0044c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00451	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00455	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0045a	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  00461	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1578 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1579 :                      * always MIN_MATCH bytes ahead.
; 1580 :                      */
; 1581 :                 } while (--s->match_length != 0);

  00465	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0046a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00470	83 e9 01	 sub	 ecx, 1
  00473	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00478	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
  0047e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00483	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0048a	0f 85 f2 fe ff
	ff		 jne	 $LN8@deflate_fa

; 1582 :                 s->strstart++;

  00490	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00495	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0049b	83 c1 01	 add	 ecx, 1
  0049e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004a3	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1583 :             } else

  004a9	e9 96 00 00 00	 jmp	 $LN5@deflate_fa
$LN9@deflate_fa:

; 1584 : #endif
; 1585 :             {
; 1586 :                 s->strstart += s->match_length;

  004ae	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004b3	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  004b9	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004be	03 88 88 00 00
	00		 add	 ecx, DWORD PTR [rax+136]
  004c4	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004c9	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1587 :                 s->match_length = 0;

  004cf	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004d4	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1588 :                 s->ins_h = s->window[s->strstart];

  004de	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004e3	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  004e9	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004ee	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  004f2	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  004f6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004fb	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1589 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  004fe	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00503	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00509	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0050e	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00511	d3 e2		 shl	 edx, cl
  00513	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00518	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0051e	83 c0 01	 add	 eax, 1
  00521	8b c8		 mov	 ecx, eax
  00523	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00528	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0052c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00530	8b ca		 mov	 ecx, edx
  00532	33 c8		 xor	 ecx, eax
  00534	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00539	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  0053c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00541	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN5@deflate_fa:

; 1590 : #if MIN_MATCH != 3
; 1591 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1592 : #endif
; 1593 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1594 :                  * matter since it will be recomputed at next deflate call.
; 1595 :                  */
; 1596 :             }
; 1597 :         } else {

  00544	e9 00 01 00 00	 jmp	 $LN4@deflate_fa
$LN10@deflate_fa:

; 1598 :             /* No match, output a literal byte */
; 1599 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1600 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00549	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0054e	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00554	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00559	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0055d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00561	88 44 24 30	 mov	 BYTE PTR cc$78731[rsp], al
  00565	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0056a	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00570	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00575	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  0057c	33 c0		 xor	 eax, eax
  0057e	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00582	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00587	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  0058d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00592	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00599	0f b6 44 24 30	 movzx	 eax, BYTE PTR cc$78731[rsp]
  0059e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005a1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005a6	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  005ac	83 c1 01	 add	 ecx, 1
  005af	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005b4	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  005ba	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$78731[rsp]
  005bf	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005c4	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  005cc	66 83 c2 01	 add	 dx, 1
  005d0	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$78731[rsp]
  005d5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005da	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  005e2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005e7	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  005ed	83 e9 01	 sub	 ecx, 1
  005f0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005f5	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  005fb	75 0a		 jne	 SHORT $LN24@deflate_fa
  005fd	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv355[rsp], 1
  00605	eb 08		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00607	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv355[rsp], 0
$LN25@deflate_fa:
  0060f	8b 44 24 3c	 mov	 eax, DWORD PTR tv355[rsp]
  00613	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1601 :             s->lookahead--;

  00617	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0061c	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00622	83 e9 01	 sub	 ecx, 1
  00625	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0062a	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1602 :             s->strstart++;

  00630	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00635	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0063b	83 c1 01	 add	 ecx, 1
  0063e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00643	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
$LN4@deflate_fa:

; 1603 :         }
; 1604 :         if (bflush) FLUSH_BLOCK(s, 0);

  00649	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  0064e	0f 84 97 00 00
	00		 je	 $LN3@deflate_fa
  00654	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00659	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00660	7c 1b		 jl	 SHORT $LN26@deflate_fa
  00662	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00667	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0066d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00672	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00676	48 89 44 24 40	 mov	 QWORD PTR tv376[rsp], rax
  0067b	eb 09		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  0067d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv376[rsp], 0
$LN27@deflate_fa:
  00686	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0068b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00690	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00696	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0069d	44 2b c0	 sub	 r8d, eax
  006a0	45 33 c9	 xor	 r9d, r9d
  006a3	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv376[rsp]
  006a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  006ad	e8 00 00 00 00	 call	 _tr_flush_block
  006b2	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  006b7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006bc	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  006c2	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  006c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  006ce	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006d1	e8 00 00 00 00	 call	 flush_pending
  006d6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006de	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006e2	75 07		 jne	 SHORT $LN2@deflate_fa
  006e4	33 c0		 xor	 eax, eax
  006e6	e9 ec 00 00 00	 jmp	 $LN18@deflate_fa
$LN2@deflate_fa:
$LN3@deflate_fa:

; 1605 :     }

  006eb	e9 1d f9 ff ff	 jmp	 $LN17@deflate_fa
$LN16@deflate_fa:

; 1606 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  006f0	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  006f5	75 0a		 jne	 SHORT $LN28@deflate_fa
  006f7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv385[rsp], 1
  006ff	eb 08		 jmp	 SHORT $LN29@deflate_fa
$LN28@deflate_fa:
  00701	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv385[rsp], 0
$LN29@deflate_fa:
  00709	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0070e	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00715	7c 1b		 jl	 SHORT $LN30@deflate_fa
  00717	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0071c	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00722	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00727	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0072b	48 89 44 24 50	 mov	 QWORD PTR tv397[rsp], rax
  00730	eb 09		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  00732	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv397[rsp], 0
$LN31@deflate_fa:
  0073b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00740	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00745	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0074b	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00752	44 2b c0	 sub	 r8d, eax
  00755	44 8b 4c 24 48	 mov	 r9d, DWORD PTR tv385[rsp]
  0075a	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv397[rsp]
  0075f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00764	e8 00 00 00 00	 call	 _tr_flush_block
  00769	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  0076e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00773	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00779	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00780	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00785	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00788	e8 00 00 00 00	 call	 flush_pending
  0078d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00792	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00795	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00799	75 1f		 jne	 SHORT $LN1@deflate_fa
  0079b	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  007a0	75 0a		 jne	 SHORT $LN32@deflate_fa
  007a2	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv406[rsp], 2
  007aa	eb 08		 jmp	 SHORT $LN33@deflate_fa
$LN32@deflate_fa:
  007ac	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv406[rsp], 0
$LN33@deflate_fa:
  007b4	8b 44 24 58	 mov	 eax, DWORD PTR tv406[rsp]
  007b8	eb 1d		 jmp	 SHORT $LN18@deflate_fa
$LN1@deflate_fa:

; 1607 :     return flush == Z_FINISH ? finish_done : block_done;

  007ba	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  007bf	75 0a		 jne	 SHORT $LN34@deflate_fa
  007c1	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR tv408[rsp], 3
  007c9	eb 08		 jmp	 SHORT $LN35@deflate_fa
$LN34@deflate_fa:
  007cb	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
$LN35@deflate_fa:
  007d3	8b 44 24 5c	 mov	 eax, DWORD PTR tv408[rsp]
$LN18@deflate_fa:

; 1608 : }

  007d7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  007db	c3		 ret	 0
deflate_fast ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+858
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_stored
_TEXT	SEGMENT
max_start$ = 32
max_block_size$ = 36
tv135 = 40
tv160 = 48
tv169 = 56
tv181 = 64
tv190 = 72
tv192 = 76
s$ = 96
flush$ = 104
deflate_stored PROC					; COMDAT

; 1465 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1466 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1467 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1468 :      */
; 1469 :     ulg max_block_size = 0xffff;

  0000d	c7 44 24 24 ff
	ff 00 00	 mov	 DWORD PTR max_block_size$[rsp], 65535 ; 0000ffffH

; 1470 :     ulg max_start;
; 1471 : 
; 1472 :     if (max_block_size > s->pending_buf_size - 5) {

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001d	83 e8 05	 sub	 eax, 5
  00020	39 44 24 24	 cmp	 DWORD PTR max_block_size$[rsp], eax
  00024	76 0f		 jbe	 SHORT $LN12@deflate_st

; 1473 :         max_block_size = s->pending_buf_size - 5;

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002e	83 e8 05	 sub	 eax, 5
  00031	89 44 24 24	 mov	 DWORD PTR max_block_size$[rsp], eax
$LN12@deflate_st:
$LN11@deflate_st:

; 1474 :     }
; 1475 : 
; 1476 :     /* Copy as much as possible from input to output: */
; 1477 :     for (;;) {
; 1478 :         /* Fill the window as much as possible: */
; 1479 :         if (s->lookahead <= 1) {

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  00041	77 3a		 ja	 SHORT $LN9@deflate_st

; 1480 : 
; 1481 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1482 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1483 : 
; 1484 :             fill_window(s);

  00043	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 fill_window

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  0004d	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00052	41 83 bb 9c 00
	00 00 00	 cmp	 DWORD PTR [r11+156], 0
  0005a	75 0e		 jne	 SHORT $LN8@deflate_st
  0005c	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00061	75 07		 jne	 SHORT $LN8@deflate_st
  00063	33 c0		 xor	 eax, eax
  00065	e9 eb 02 00 00	 jmp	 $LN13@deflate_st
$LN8@deflate_st:

; 1486 : 
; 1487 :             if (s->lookahead == 0) break; /* flush the current block */

  0006a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0006f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00076	75 05		 jne	 SHORT $LN7@deflate_st
  00078	e9 f1 01 00 00	 jmp	 $LN10@deflate_st
$LN7@deflate_st:
$LN9@deflate_st:

; 1488 :         }
; 1489 :         Assert(s->block_start >= 0L, "block gone");
; 1490 : 
; 1491 :         s->strstart += s->lookahead;

  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00082	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0008d	03 88 9c 00 00
	00		 add	 ecx, DWORD PTR [rax+156]
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00098	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1492 :         s->lookahead = 0;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1493 : 
; 1494 :         /* Emit a stored block if pending_buf will be full: */
; 1495 :         max_start = s->block_start + max_block_size;

  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b2	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  000b8	03 44 24 24	 add	 eax, DWORD PTR max_block_size$[rsp]
  000bc	89 44 24 20	 mov	 DWORD PTR max_start$[rsp], eax

; 1496 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  000c0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c5	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000cc	74 15		 je	 SHORT $LN5@deflate_st
  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000d3	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  000d7	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  000dd	0f 82 c2 00 00
	00		 jb	 $LN6@deflate_st
$LN5@deflate_st:

; 1497 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1498 :             s->lookahead = (uInt)(s->strstart - max_start);

  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  000ec	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000f2	2b c8		 sub	 ecx, eax
  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f9	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1499 :             s->strstart = (uInt)max_start;

  000ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00104	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  00108	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1500 :             FLUSH_BLOCK(s, 0);

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00113	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0011a	7c 1b		 jl	 SHORT $LN15@deflate_st
  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00121	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00130	48 89 44 24 28	 mov	 QWORD PTR tv135[rsp], rax
  00135	eb 09		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:
  00137	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv135[rsp], 0
$LN16@deflate_st:
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0014a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00150	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00157	44 2b c0	 sub	 r8d, eax
  0015a	45 33 c9	 xor	 r9d, r9d
  0015d	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv135[rsp]
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00167	e8 00 00 00 00	 call	 _tr_flush_block
  0016c	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00171	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00176	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0017c	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00188	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0018b	e8 00 00 00 00	 call	 flush_pending
  00190	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00195	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00198	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0019c	75 07		 jne	 SHORT $LN4@deflate_st
  0019e	33 c0		 xor	 eax, eax
  001a0	e9 b0 01 00 00	 jmp	 $LN13@deflate_st
$LN4@deflate_st:
$LN6@deflate_st:

; 1501 :         }
; 1502 :         /* Flush if we may have to slide, otherwise block_start may become
; 1503 :          * negative and the data will be gone:
; 1504 :          */
; 1505 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001af	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001b5	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  001bb	2b c8		 sub	 ecx, eax
  001bd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001c2	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001c5	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  001ca	3b c8		 cmp	 ecx, eax
  001cc	0f 82 97 00 00
	00		 jb	 $LN3@deflate_st

; 1506 :             FLUSH_BLOCK(s, 0);

  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001d7	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  001de	7c 1b		 jl	 SHORT $LN17@deflate_st
  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f0	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  001f4	48 89 44 24 30	 mov	 QWORD PTR tv160[rsp], rax
  001f9	eb 09		 jmp	 SHORT $LN18@deflate_st
$LN17@deflate_st:
  001fb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv160[rsp], 0
$LN18@deflate_st:
  00204	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00209	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0020e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00214	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0021b	44 2b c0	 sub	 r8d, eax
  0021e	45 33 c9	 xor	 r9d, r9d
  00221	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv160[rsp]
  00226	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0022b	e8 00 00 00 00	 call	 _tr_flush_block
  00230	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00240	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0024c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024f	e8 00 00 00 00	 call	 flush_pending
  00254	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00259	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00260	75 07		 jne	 SHORT $LN2@deflate_st
  00262	33 c0		 xor	 eax, eax
  00264	e9 ec 00 00 00	 jmp	 $LN13@deflate_st
$LN2@deflate_st:
$LN3@deflate_st:

; 1507 :         }
; 1508 :     }

  00269	e9 c7 fd ff ff	 jmp	 $LN11@deflate_st
$LN10@deflate_st:

; 1509 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0026e	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  00273	75 0a		 jne	 SHORT $LN19@deflate_st
  00275	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  0027d	eb 08		 jmp	 SHORT $LN20@deflate_st
$LN19@deflate_st:
  0027f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN20@deflate_st:
  00287	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0028c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00293	7c 1b		 jl	 SHORT $LN21@deflate_st
  00295	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  002a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002a5	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  002a9	48 89 44 24 40	 mov	 QWORD PTR tv181[rsp], rax
  002ae	eb 09		 jmp	 SHORT $LN22@deflate_st
$LN21@deflate_st:
  002b0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv181[rsp], 0
$LN22@deflate_st:
  002b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002c3	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  002c9	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  002d0	44 2b c0	 sub	 r8d, eax
  002d3	44 8b 4c 24 38	 mov	 r9d, DWORD PTR tv169[rsp]
  002d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv181[rsp]
  002dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002e2	e8 00 00 00 00	 call	 _tr_flush_block
  002e7	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  002ec	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002f1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002f7	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  002fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00303	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00306	e8 00 00 00 00	 call	 flush_pending
  0030b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00310	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00313	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00317	75 1f		 jne	 SHORT $LN1@deflate_st
  00319	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0031e	75 0a		 jne	 SHORT $LN23@deflate_st
  00320	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
  00328	eb 08		 jmp	 SHORT $LN24@deflate_st
$LN23@deflate_st:
  0032a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN24@deflate_st:
  00332	8b 44 24 48	 mov	 eax, DWORD PTR tv190[rsp]
  00336	eb 1d		 jmp	 SHORT $LN13@deflate_st
$LN1@deflate_st:

; 1510 :     return flush == Z_FINISH ? finish_done : block_done;

  00338	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0033d	75 0a		 jne	 SHORT $LN25@deflate_st
  0033f	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv192[rsp], 3
  00347	eb 08		 jmp	 SHORT $LN26@deflate_st
$LN25@deflate_st:
  00349	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
$LN26@deflate_st:
  00351	8b 44 24 4c	 mov	 eax, DWORD PTR tv192[rsp]
$LN13@deflate_st:

; 1511 : }

  00355	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00359	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN110
	DD	imagerel $LN110+4983
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate
_TEXT	SEGMENT
s$ = 32
old_flush$ = 40
level_flags$78421 = 44
header$78420 = 48
beg$78435 = 52
beg$78447 = 56
val$78448 = 60
beg$78460 = 64
val$78461 = 68
bstate$78487 = 72
tv199 = 76
tv198 = 80
tv219 = 84
tv223 = 88
tv228 = 92
tv233 = 96
tv238 = 100
tv302 = 104
tv301 = 108
tv686 = 112
tv685 = 116
tv833 = 120
strm$ = 144
flush$ = 152
deflate	PROC						; COMDAT

; 585  : {

$LN110:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 586  :     int old_flush; /* value of flush param for previous deflate call */
; 587  :     deflate_state *s;
; 588  : 
; 589  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 590  :         flush > Z_BLOCK || flush < 0) {

  00010	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 23		 je	 SHORT $LN82@deflate
  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 14		 je	 SHORT $LN82@deflate
  0002a	83 bc 24 98 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  00032	7f 0a		 jg	 SHORT $LN82@deflate
  00034	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0003c	7d 0a		 jge	 SHORT $LN83@deflate
$LN82@deflate:

; 591  :         return Z_STREAM_ERROR;

  0003e	b8 fe ff ff ff	 mov	 eax, -2
  00043	e9 27 13 00 00	 jmp	 $LN84@deflate
$LN83@deflate:

; 592  :     }
; 593  :     s = strm->state;

  00048	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 594  : 
; 595  :     if (strm->next_out == Z_NULL ||
; 596  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 597  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  00059	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00061	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00066	74 34		 je	 SHORT $LN80@deflate
  00068	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00074	75 0e		 jne	 SHORT $LN79@deflate
  00076	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00082	75 18		 jne	 SHORT $LN80@deflate
$LN79@deflate:
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00089	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00090	75 27		 jne	 SHORT $LN81@deflate
  00092	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0009a	74 1d		 je	 SHORT $LN81@deflate
$LN80@deflate:

; 598  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0009c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  000a4	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  000ab	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  000af	b8 fe ff ff ff	 mov	 eax, -2
  000b4	e9 b6 12 00 00	 jmp	 $LN84@deflate
$LN81@deflate:

; 599  :     }
; 600  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  000b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000c5	75 1d		 jne	 SHORT $LN78@deflate
  000c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  000cf	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  000d6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  000da	b8 fb ff ff ff	 mov	 eax, -5
  000df	e9 8b 12 00 00	 jmp	 $LN84@deflate
$LN78@deflate:

; 601  : 
; 602  :     s->strm = strm; /* just in case */

  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000f1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 603  :     old_flush = s->last_flush;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000f9	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000fc	89 44 24 28	 mov	 DWORD PTR old_flush$[rsp], eax

; 604  :     s->last_flush = flush;

  00100	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00105	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR flush$[rsp]
  0010c	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 605  : 
; 606  :     /* Write the header */
; 607  :     if (s->status == INIT_STATE) {

  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00114	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00118	0f 85 c9 06 00
	00		 jne	 $LN77@deflate

; 608  : #ifdef GZIP
; 609  :         if (s->wrap == 2) {

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00123	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00127	0f 85 84 05 00
	00		 jne	 $LN76@deflate

; 610  :             strm->adler = crc32(0L, Z_NULL, 0);

  0012d	45 33 c0	 xor	 r8d, r8d
  00130	33 d2		 xor	 edx, edx
  00132	33 c9		 xor	 ecx, ecx
  00134	e8 00 00 00 00	 call	 crc32
  00139	44 8b d8	 mov	 r11d, eax
  0013c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00144	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 611  :             put_byte(s, 31);

  00148	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0014d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00155	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00159	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00162	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00165	83 c1 01	 add	 ecx, 1
  00168	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0016d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 612  :             put_byte(s, 139);

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00175	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00178	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0017d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00181	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  00185	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0018a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0018d	83 c1 01	 add	 ecx, 1
  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00195	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 613  :             put_byte(s, 8);

  00198	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0019d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001a5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001a9	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b2	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001b5	83 c1 01	 add	 ecx, 1
  001b8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001bd	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 614  :             if (s->gzhead == Z_NULL) {

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001c5	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  001ca	0f 85 7b 01 00
	00		 jne	 $LN75@deflate

; 615  :                 put_byte(s, 0);

  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d5	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001dd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e1	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  001e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ea	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001ed	83 c1 01	 add	 ecx, 1
  001f0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f5	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 616  :                 put_byte(s, 0);

  001f8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001fd	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00200	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00205	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00209	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0020d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00212	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00215	83 c1 01	 add	 ecx, 1
  00218	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0021d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 617  :                 put_byte(s, 0);

  00220	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00225	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00228	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00231	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00235	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0023a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0023d	83 c1 01	 add	 ecx, 1
  00240	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00245	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 618  :                 put_byte(s, 0);

  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0024d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00250	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00255	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00259	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0025d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00262	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00265	83 c1 01	 add	 ecx, 1
  00268	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0026d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 619  :                 put_byte(s, 0);

  00270	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00275	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00278	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0027d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00281	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00285	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0028a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0028d	83 c1 01	 add	 ecx, 1
  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00295	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 620  :                 put_byte(s, s->level == 9 ? 2 :
; 621  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 622  :                              4 : 0));

  00298	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0029d	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  002a4	75 0a		 jne	 SHORT $LN88@deflate
  002a6	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
  002ae	eb 36		 jmp	 SHORT $LN89@deflate
$LN88@deflate:
  002b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b5	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  002bc	7d 18		 jge	 SHORT $LN86@deflate
  002be	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002c3	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  002ca	7c 0a		 jl	 SHORT $LN86@deflate
  002cc	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  002d6	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv198[rsp], 4
$LN87@deflate:
  002de	8b 44 24 50	 mov	 eax, DWORD PTR tv198[rsp]
  002e2	89 44 24 4c	 mov	 DWORD PTR tv199[rsp], eax
$LN89@deflate:
  002e6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002eb	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  002ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002f3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002f7	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv199[rsp]
  002fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002ff	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00304	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00307	83 c1 01	 add	 ecx, 1
  0030a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0030f	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 623  :                 put_byte(s, OS_CODE);

  00312	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00317	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0031a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0031f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00323	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11
  00327	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0032c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0032f	83 c1 01	 add	 ecx, 1
  00332	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00337	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 624  :                 s->status = BUSY_STATE;

  0033a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0033f	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 625  :             }
; 626  :             else {

  00346	e9 61 03 00 00	 jmp	 $LN74@deflate
$LN75@deflate:

; 627  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 628  :                             (s->gzhead->hcrc ? 2 : 0) +
; 629  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 630  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 631  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 632  :                         );

  0034b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00350	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00354	83 38 00	 cmp	 DWORD PTR [rax], 0
  00357	74 0a		 je	 SHORT $LN90@deflate
  00359	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv219[rsp], 1
  00361	eb 08		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  00363	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN91@deflate:
  0036b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00370	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00374	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00378	74 0a		 je	 SHORT $LN92@deflate
  0037a	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv223[rsp], 2
  00382	eb 08		 jmp	 SHORT $LN93@deflate
$LN92@deflate:
  00384	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv223[rsp], 0
$LN93@deflate:
  0038c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00391	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00395	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0039a	75 0a		 jne	 SHORT $LN94@deflate
  0039c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
  003a4	eb 08		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  003a6	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv228[rsp], 4
$LN95@deflate:
  003ae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003b3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003b7	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  003bc	75 0a		 jne	 SHORT $LN96@deflate
  003be	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
  003c6	eb 08		 jmp	 SHORT $LN97@deflate
$LN96@deflate:
  003c8	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR tv233[rsp], 8
$LN97@deflate:
  003d0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003d5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003d9	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  003de	75 0a		 jne	 SHORT $LN98@deflate
  003e0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  003e8	eb 08		 jmp	 SHORT $LN99@deflate
$LN98@deflate:
  003ea	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv238[rsp], 16
$LN99@deflate:
  003f2	8b 44 24 58	 mov	 eax, DWORD PTR tv223[rsp]
  003f6	8b 54 24 54	 mov	 edx, DWORD PTR tv219[rsp]
  003fa	03 d0		 add	 edx, eax
  003fc	03 54 24 5c	 add	 edx, DWORD PTR tv228[rsp]
  00400	03 54 24 60	 add	 edx, DWORD PTR tv233[rsp]
  00404	03 54 24 64	 add	 edx, DWORD PTR tv238[rsp]
  00408	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0040d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00410	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00415	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00419	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0041c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00421	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00424	83 c1 01	 add	 ecx, 1
  00427	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0042c	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 633  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  0042f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00434	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00438	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0043b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00441	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00446	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00449	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0044e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00452	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00455	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0045a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0045d	83 c1 01	 add	 ecx, 1
  00460	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00465	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 634  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00468	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0046d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00471	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  00474	c1 ea 08	 shr	 edx, 8
  00477	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0047d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00482	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00485	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0048a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0048e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00491	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00496	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00499	83 c1 01	 add	 ecx, 1
  0049c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004a1	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 635  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  004a4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004a9	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  004ad	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  004b0	c1 ea 10	 shr	 edx, 16
  004b3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004be	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004c1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004ca	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  004cd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004d2	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004d5	83 c1 01	 add	 ecx, 1
  004d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004dd	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 636  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  004e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004e5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  004e9	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  004ec	c1 ea 18	 shr	 edx, 24
  004ef	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004f5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004fa	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004fd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00502	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00506	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00509	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0050e	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00511	83 c1 01	 add	 ecx, 1
  00514	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00519	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 637  :                 put_byte(s, s->level == 9 ? 2 :
; 638  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 639  :                              4 : 0));

  0051c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00521	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  00528	75 0a		 jne	 SHORT $LN102@deflate
  0052a	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv302[rsp], 2
  00532	eb 36		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  00534	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00539	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00540	7d 18		 jge	 SHORT $LN100@deflate
  00542	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00547	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  0054e	7c 0a		 jl	 SHORT $LN100@deflate
  00550	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
  00558	eb 08		 jmp	 SHORT $LN101@deflate
$LN100@deflate:
  0055a	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv301[rsp], 4
$LN101@deflate:
  00562	8b 44 24 6c	 mov	 eax, DWORD PTR tv301[rsp]
  00566	89 44 24 68	 mov	 DWORD PTR tv302[rsp], eax
$LN103@deflate:
  0056a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0056f	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00572	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00577	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0057b	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv302[rsp]
  00580	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00583	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00588	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0058b	83 c1 01	 add	 ecx, 1
  0058e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00593	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 640  :                 put_byte(s, s->gzhead->os & 0xff);

  00596	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0059b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0059f	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  005a2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005ad	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005b9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  005bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005c1	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005c4	83 c1 01	 add	 ecx, 1
  005c7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005cc	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 641  :                 if (s->gzhead->extra != Z_NULL) {

  005cf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005d4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005d8	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  005dd	74 75		 je	 SHORT $LN73@deflate

; 642  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  005df	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005e4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005e8	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  005eb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005f1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005f9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005fe	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00602	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00605	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0060a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0060d	83 c1 01	 add	 ecx, 1
  00610	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00615	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 643  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  00618	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0061d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00621	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  00624	c1 ea 08	 shr	 edx, 8
  00627	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0062d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00632	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00635	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0063a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0063e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00641	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00646	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00649	83 c1 01	 add	 ecx, 1
  0064c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00651	89 48 28	 mov	 DWORD PTR [rax+40], ecx
$LN73@deflate:

; 644  :                 }
; 645  :                 if (s->gzhead->hcrc)

  00654	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00659	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0065d	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00661	74 31		 je	 SHORT $LN72@deflate

; 646  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 647  :                                         s->pending);

  00663	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00668	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0066c	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00671	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00675	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0067d	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00680	e8 00 00 00 00	 call	 crc32
  00685	44 8b d8	 mov	 r11d, eax
  00688	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00690	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN72@deflate:

; 648  :                 s->gzindex = 0;

  00694	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00699	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 649  :                 s->status = EXTRA_STATE;

  006a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006a5	c7 40 08 45 00
	00 00		 mov	 DWORD PTR [rax+8], 69	; 00000045H
$LN74@deflate:

; 650  :             }
; 651  :         }
; 652  :         else

  006ac	e9 36 01 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 653  : #endif
; 654  :         {
; 655  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  006b1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006b6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006b9	83 e8 08	 sub	 eax, 8
  006bc	c1 e0 04	 shl	 eax, 4
  006bf	83 c0 08	 add	 eax, 8
  006c2	c1 e0 08	 shl	 eax, 8
  006c5	89 44 24 30	 mov	 DWORD PTR header$78420[rsp], eax

; 656  :             uInt level_flags;
; 657  : 
; 658  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  006c9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006ce	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  006d5	7d 0e		 jge	 SHORT $LN69@deflate
  006d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006dc	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  006e3	7d 0a		 jge	 SHORT $LN70@deflate
$LN69@deflate:

; 659  :                 level_flags = 0;

  006e5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR level_flags$78421[rsp], 0
  006ed	eb 38		 jmp	 SHORT $LN68@deflate
$LN70@deflate:

; 660  :             else if (s->level < 6)

  006ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006f4	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  006fb	7d 0a		 jge	 SHORT $LN67@deflate

; 661  :                 level_flags = 1;

  006fd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR level_flags$78421[rsp], 1
  00705	eb 20		 jmp	 SHORT $LN66@deflate
$LN67@deflate:

; 662  :             else if (s->level == 6)

  00707	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0070c	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  00713	75 0a		 jne	 SHORT $LN65@deflate

; 663  :                 level_flags = 2;

  00715	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR level_flags$78421[rsp], 2

; 664  :             else

  0071d	eb 08		 jmp	 SHORT $LN64@deflate
$LN65@deflate:

; 665  :                 level_flags = 3;

  0071f	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR level_flags$78421[rsp], 3
$LN64@deflate:
$LN66@deflate:
$LN68@deflate:

; 666  :             header |= (level_flags << 6);

  00727	8b 4c 24 2c	 mov	 ecx, DWORD PTR level_flags$78421[rsp]
  0072b	c1 e1 06	 shl	 ecx, 6
  0072e	8b 44 24 30	 mov	 eax, DWORD PTR header$78420[rsp]
  00732	0b c1		 or	 eax, ecx
  00734	89 44 24 30	 mov	 DWORD PTR header$78420[rsp], eax

; 667  :             if (s->strstart != 0) header |= PRESET_DICT;

  00738	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0073d	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00744	74 0b		 je	 SHORT $LN63@deflate
  00746	8b 44 24 30	 mov	 eax, DWORD PTR header$78420[rsp]
  0074a	83 c8 20	 or	 eax, 32			; 00000020H
  0074d	89 44 24 30	 mov	 DWORD PTR header$78420[rsp], eax
$LN63@deflate:

; 668  :             header += 31 - (header % 31);

  00751	33 d2		 xor	 edx, edx
  00753	8b 44 24 30	 mov	 eax, DWORD PTR header$78420[rsp]
  00757	b9 1f 00 00 00	 mov	 ecx, 31
  0075c	f7 f1		 div	 ecx
  0075e	b9 1f 00 00 00	 mov	 ecx, 31
  00763	2b ca		 sub	 ecx, edx
  00765	8b 44 24 30	 mov	 eax, DWORD PTR header$78420[rsp]
  00769	03 c1		 add	 eax, ecx
  0076b	89 44 24 30	 mov	 DWORD PTR header$78420[rsp], eax

; 669  : 
; 670  :             s->status = BUSY_STATE;

  0076f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00774	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 671  :             putShortMSB(s, header);

  0077b	8b 54 24 30	 mov	 edx, DWORD PTR header$78420[rsp]
  0077f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00784	e8 00 00 00 00	 call	 putShortMSB

; 672  : 
; 673  :             /* Save the adler32 of the preset dictionary: */
; 674  :             if (s->strstart != 0) {

  00789	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0078e	41 83 bb 94 00
	00 00 00	 cmp	 DWORD PTR [r11+148], 0
  00796	74 34		 je	 SHORT $LN62@deflate

; 675  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  00798	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  007a0	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  007a3	c1 ea 10	 shr	 edx, 16
  007a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  007ab	e8 00 00 00 00	 call	 putShortMSB

; 676  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  007b0	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  007b8	41 8b 53 4c	 mov	 edx, DWORD PTR [r11+76]
  007bc	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  007c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  007c7	e8 00 00 00 00	 call	 putShortMSB
$LN62@deflate:

; 677  :             }
; 678  :             strm->adler = adler32(0L, Z_NULL, 0);

  007cc	45 33 c0	 xor	 r8d, r8d
  007cf	33 d2		 xor	 edx, edx
  007d1	33 c9		 xor	 ecx, ecx
  007d3	e8 00 00 00 00	 call	 adler32
  007d8	44 8b d8	 mov	 r11d, eax
  007db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  007e3	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN71@deflate:
$LN77@deflate:

; 679  :         }
; 680  :     }
; 681  : #ifdef GZIP
; 682  :     if (s->status == EXTRA_STATE) {

  007e7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007ec	83 78 08 45	 cmp	 DWORD PTR [rax+8], 69	; 00000045H
  007f0	0f 85 cc 01 00
	00		 jne	 $LN61@deflate

; 683  :         if (s->gzhead->extra != Z_NULL) {

  007f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007fb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  007ff	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00804	0f 84 ac 01 00
	00		 je	 $LN60@deflate

; 684  :             uInt beg = s->pending;  /* start of bytes to update crc */

  0080a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0080f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00812	89 44 24 34	 mov	 DWORD PTR beg$78435[rsp], eax
$LN59@deflate:

; 685  : 
; 686  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  00816	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0081b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0081f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00822	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00828	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0082d	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  00830	0f 83 f7 00 00
	00		 jae	 $LN58@deflate

; 687  :                 if (s->pending == s->pending_buf_size) {

  00836	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0083b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00840	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00843	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00846	0f 85 87 00 00
	00		 jne	 $LN57@deflate

; 688  :                     if (s->gzhead->hcrc && s->pending > beg)

  0084c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00851	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00855	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00859	74 4a		 je	 SHORT $LN56@deflate
  0085b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00860	8b 44 24 34	 mov	 eax, DWORD PTR beg$78435[rsp]
  00864	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00867	76 3c		 jbe	 SHORT $LN56@deflate

; 689  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 690  :                                             s->pending - beg);

  00869	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0086e	8b 44 24 34	 mov	 eax, DWORD PTR beg$78435[rsp]
  00872	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00876	44 2b c0	 sub	 r8d, eax
  00879	8b 54 24 34	 mov	 edx, DWORD PTR beg$78435[rsp]
  0087d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00882	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00886	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0088e	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00891	e8 00 00 00 00	 call	 crc32
  00896	44 8b d8	 mov	 r11d, eax
  00899	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  008a1	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN56@deflate:

; 691  :                     flush_pending(strm);

  008a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  008ad	e8 00 00 00 00	 call	 flush_pending

; 692  :                     beg = s->pending;

  008b2	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  008b7	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  008bb	89 44 24 34	 mov	 DWORD PTR beg$78435[rsp], eax

; 693  :                     if (s->pending == s->pending_buf_size)

  008bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008c4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008c9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008cc	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  008cf	75 02		 jne	 SHORT $LN55@deflate

; 694  :                         break;

  008d1	eb 5a		 jmp	 SHORT $LN58@deflate
$LN55@deflate:
$LN57@deflate:

; 695  :                 }
; 696  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  008d3	4c 8b 44 24 20	 mov	 r8, QWORD PTR s$[rsp]
  008d8	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  008dc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008e1	44 8b 48 38	 mov	 r9d, DWORD PTR [rax+56]
  008e5	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  008e9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008ee	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  008f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008f6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  008fa	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  008ff	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00902	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00907	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0090a	83 c1 01	 add	 ecx, 1
  0090d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00912	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 697  :                 s->gzindex++;

  00915	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0091a	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  0091d	83 c1 01	 add	 ecx, 1
  00920	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00925	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 698  :             }

  00928	e9 e9 fe ff ff	 jmp	 $LN59@deflate
$LN58@deflate:

; 699  :             if (s->gzhead->hcrc && s->pending > beg)

  0092d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00932	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00936	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0093a	74 4a		 je	 SHORT $LN54@deflate
  0093c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00941	8b 44 24 34	 mov	 eax, DWORD PTR beg$78435[rsp]
  00945	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00948	76 3c		 jbe	 SHORT $LN54@deflate

; 700  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 701  :                                     s->pending - beg);

  0094a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0094f	8b 44 24 34	 mov	 eax, DWORD PTR beg$78435[rsp]
  00953	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00957	44 2b c0	 sub	 r8d, eax
  0095a	8b 54 24 34	 mov	 edx, DWORD PTR beg$78435[rsp]
  0095e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00963	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00967	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0096f	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00972	e8 00 00 00 00	 call	 crc32
  00977	44 8b d8	 mov	 r11d, eax
  0097a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00982	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN54@deflate:

; 702  :             if (s->gzindex == s->gzhead->extra_len) {

  00986	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0098b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0098f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00994	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00997	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  0099a	75 18		 jne	 SHORT $LN53@deflate

; 703  :                 s->gzindex = 0;

  0099c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009a1	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 704  :                 s->status = NAME_STATE;

  009a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ad	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN53@deflate:

; 705  :             }
; 706  :         }
; 707  :         else

  009b4	eb 0c		 jmp	 SHORT $LN52@deflate
$LN60@deflate:

; 708  :             s->status = NAME_STATE;

  009b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009bb	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN52@deflate:
$LN61@deflate:

; 709  :     }
; 710  :     if (s->status == NAME_STATE) {

  009c2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009c7	83 78 08 49	 cmp	 DWORD PTR [rax+8], 73	; 00000049H
  009cb	0f 85 b2 01 00
	00		 jne	 $LN51@deflate

; 711  :         if (s->gzhead->name != Z_NULL) {

  009d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009d6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  009da	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  009df	0f 84 92 01 00
	00		 je	 $LN50@deflate

; 712  :             uInt beg = s->pending;  /* start of bytes to update crc */

  009e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ea	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  009ed	89 44 24 38	 mov	 DWORD PTR beg$78447[rsp], eax
$LN49@deflate:

; 713  :             int val;
; 714  : 
; 715  :             do {
; 716  :                 if (s->pending == s->pending_buf_size) {

  009f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  009f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009fb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009fe	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a01	0f 85 8f 00 00
	00		 jne	 $LN46@deflate

; 717  :                     if (s->gzhead->hcrc && s->pending > beg)

  00a07	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a0c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00a10	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00a14	74 4a		 je	 SHORT $LN45@deflate
  00a16	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a1b	8b 44 24 38	 mov	 eax, DWORD PTR beg$78447[rsp]
  00a1f	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a22	76 3c		 jbe	 SHORT $LN45@deflate

; 718  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 719  :                                             s->pending - beg);

  00a24	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a29	8b 44 24 38	 mov	 eax, DWORD PTR beg$78447[rsp]
  00a2d	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00a31	44 2b c0	 sub	 r8d, eax
  00a34	8b 54 24 38	 mov	 edx, DWORD PTR beg$78447[rsp]
  00a38	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a3d	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00a41	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a49	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00a4c	e8 00 00 00 00	 call	 crc32
  00a51	44 8b d8	 mov	 r11d, eax
  00a54	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a5c	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN45@deflate:

; 720  :                     flush_pending(strm);

  00a60	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00a68	e8 00 00 00 00	 call	 flush_pending

; 721  :                     beg = s->pending;

  00a6d	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  00a72	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  00a76	89 44 24 38	 mov	 DWORD PTR beg$78447[rsp], eax

; 722  :                     if (s->pending == s->pending_buf_size) {

  00a7a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a7f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a84	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a87	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a8a	75 0a		 jne	 SHORT $LN44@deflate

; 723  :                         val = 1;

  00a8c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR val$78448[rsp], 1

; 724  :                         break;

  00a94	eb 67		 jmp	 SHORT $LN47@deflate
$LN44@deflate:
$LN46@deflate:

; 725  :                     }
; 726  :                 }
; 727  :                 val = s->gzhead->name[s->gzindex++];

  00a96	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00a9b	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00a9f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aa4	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00aa7	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00aab	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00aaf	89 44 24 3c	 mov	 DWORD PTR val$78448[rsp], eax
  00ab3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ab8	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00abb	83 c1 01	 add	 ecx, 1
  00abe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ac3	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 728  :                 put_byte(s, val);

  00ac6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00acb	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00ace	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ad3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ad7	0f b6 44 24 3c	 movzx	 eax, BYTE PTR val$78448[rsp]
  00adc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00adf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ae4	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00ae7	83 c1 01	 add	 ecx, 1
  00aea	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aef	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 729  :             } while (val != 0);

  00af2	83 7c 24 3c 00	 cmp	 DWORD PTR val$78448[rsp], 0
  00af7	0f 85 f4 fe ff
	ff		 jne	 $LN49@deflate
$LN47@deflate:

; 730  :             if (s->gzhead->hcrc && s->pending > beg)

  00afd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b02	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b06	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00b0a	74 4a		 je	 SHORT $LN43@deflate
  00b0c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00b11	8b 44 24 38	 mov	 eax, DWORD PTR beg$78447[rsp]
  00b15	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00b18	76 3c		 jbe	 SHORT $LN43@deflate

; 731  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 732  :                                     s->pending - beg);

  00b1a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00b1f	8b 44 24 38	 mov	 eax, DWORD PTR beg$78447[rsp]
  00b23	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00b27	44 2b c0	 sub	 r8d, eax
  00b2a	8b 54 24 38	 mov	 edx, DWORD PTR beg$78447[rsp]
  00b2e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b33	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00b37	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00b3f	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00b42	e8 00 00 00 00	 call	 crc32
  00b47	44 8b d8	 mov	 r11d, eax
  00b4a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00b52	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN43@deflate:

; 733  :             if (val == 0) {

  00b56	83 7c 24 3c 00	 cmp	 DWORD PTR val$78448[rsp], 0
  00b5b	75 18		 jne	 SHORT $LN42@deflate

; 734  :                 s->gzindex = 0;

  00b5d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b62	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 735  :                 s->status = COMMENT_STATE;

  00b69	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b6e	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN42@deflate:

; 736  :             }
; 737  :         }
; 738  :         else

  00b75	eb 0c		 jmp	 SHORT $LN41@deflate
$LN50@deflate:

; 739  :             s->status = COMMENT_STATE;

  00b77	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b7c	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN41@deflate:
$LN51@deflate:

; 740  :     }
; 741  :     if (s->status == COMMENT_STATE) {

  00b83	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b88	83 78 08 5b	 cmp	 DWORD PTR [rax+8], 91	; 0000005bH
  00b8c	0f 85 a6 01 00
	00		 jne	 $LN40@deflate

; 742  :         if (s->gzhead->comment != Z_NULL) {

  00b92	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b97	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b9b	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00ba0	0f 84 86 01 00
	00		 je	 $LN39@deflate

; 743  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00ba6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bab	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00bae	89 44 24 40	 mov	 DWORD PTR beg$78460[rsp], eax
$LN38@deflate:

; 744  :             int val;
; 745  : 
; 746  :             do {
; 747  :                 if (s->pending == s->pending_buf_size) {

  00bb2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bb7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bbc	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00bbf	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00bc2	0f 85 8f 00 00
	00		 jne	 $LN35@deflate

; 748  :                     if (s->gzhead->hcrc && s->pending > beg)

  00bc8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bcd	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00bd1	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00bd5	74 4a		 je	 SHORT $LN34@deflate
  00bd7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bdc	8b 44 24 40	 mov	 eax, DWORD PTR beg$78460[rsp]
  00be0	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00be3	76 3c		 jbe	 SHORT $LN34@deflate

; 749  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 750  :                                             s->pending - beg);

  00be5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bea	8b 44 24 40	 mov	 eax, DWORD PTR beg$78460[rsp]
  00bee	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00bf2	44 2b c0	 sub	 r8d, eax
  00bf5	8b 54 24 40	 mov	 edx, DWORD PTR beg$78460[rsp]
  00bf9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bfe	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00c02	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c0a	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00c0d	e8 00 00 00 00	 call	 crc32
  00c12	44 8b d8	 mov	 r11d, eax
  00c15	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c1d	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN34@deflate:

; 751  :                     flush_pending(strm);

  00c21	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c29	e8 00 00 00 00	 call	 flush_pending

; 752  :                     beg = s->pending;

  00c2e	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  00c33	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  00c37	89 44 24 40	 mov	 DWORD PTR beg$78460[rsp], eax

; 753  :                     if (s->pending == s->pending_buf_size) {

  00c3b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c40	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c45	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00c48	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00c4b	75 0a		 jne	 SHORT $LN33@deflate

; 754  :                         val = 1;

  00c4d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR val$78461[rsp], 1

; 755  :                         break;

  00c55	eb 67		 jmp	 SHORT $LN36@deflate
$LN33@deflate:
$LN35@deflate:

; 756  :                     }
; 757  :                 }
; 758  :                 val = s->gzhead->comment[s->gzindex++];

  00c57	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00c5c	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00c60	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c65	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00c68	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00c6c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c70	89 44 24 44	 mov	 DWORD PTR val$78461[rsp], eax
  00c74	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c79	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00c7c	83 c1 01	 add	 ecx, 1
  00c7f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c84	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 759  :                 put_byte(s, val);

  00c87	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c8c	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00c8f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c94	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00c98	0f b6 44 24 44	 movzx	 eax, BYTE PTR val$78461[rsp]
  00c9d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ca0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ca5	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00ca8	83 c1 01	 add	 ecx, 1
  00cab	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cb0	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 760  :             } while (val != 0);

  00cb3	83 7c 24 44 00	 cmp	 DWORD PTR val$78461[rsp], 0
  00cb8	0f 85 f4 fe ff
	ff		 jne	 $LN38@deflate
$LN36@deflate:

; 761  :             if (s->gzhead->hcrc && s->pending > beg)

  00cbe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cc3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00cc7	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00ccb	74 4a		 je	 SHORT $LN32@deflate
  00ccd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00cd2	8b 44 24 40	 mov	 eax, DWORD PTR beg$78460[rsp]
  00cd6	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00cd9	76 3c		 jbe	 SHORT $LN32@deflate

; 762  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 763  :                                     s->pending - beg);

  00cdb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ce0	8b 44 24 40	 mov	 eax, DWORD PTR beg$78460[rsp]
  00ce4	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00ce8	44 2b c0	 sub	 r8d, eax
  00ceb	8b 54 24 40	 mov	 edx, DWORD PTR beg$78460[rsp]
  00cef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cf4	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00cf8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d00	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00d03	e8 00 00 00 00	 call	 crc32
  00d08	44 8b d8	 mov	 r11d, eax
  00d0b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d13	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN32@deflate:

; 764  :             if (val == 0)

  00d17	83 7c 24 44 00	 cmp	 DWORD PTR val$78461[rsp], 0
  00d1c	75 0c		 jne	 SHORT $LN31@deflate

; 765  :                 s->status = HCRC_STATE;

  00d1e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d23	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN31@deflate:

; 766  :         }
; 767  :         else

  00d2a	eb 0c		 jmp	 SHORT $LN30@deflate
$LN39@deflate:

; 768  :             s->status = HCRC_STATE;

  00d2c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d31	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN30@deflate:
$LN40@deflate:

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  00d38	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d3d	83 78 08 67	 cmp	 DWORD PTR [rax+8], 103	; 00000067H
  00d41	0f 85 f6 00 00
	00		 jne	 $LN29@deflate

; 771  :         if (s->gzhead->hcrc) {

  00d47	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d4c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d50	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00d54	0f 84 d7 00 00
	00		 je	 $LN28@deflate

; 772  :             if (s->pending + 2 > s->pending_buf_size)

  00d5a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d5f	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00d62	83 c1 02	 add	 ecx, 2
  00d65	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d6a	3b 48 18	 cmp	 ecx, DWORD PTR [rax+24]
  00d6d	76 0d		 jbe	 SHORT $LN27@deflate

; 773  :                 flush_pending(strm);

  00d6f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00d77	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate:

; 774  :             if (s->pending + 2 <= s->pending_buf_size) {

  00d7c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d81	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00d84	83 c1 02	 add	 ecx, 2
  00d87	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d8c	3b 48 18	 cmp	 ecx, DWORD PTR [rax+24]
  00d8f	0f 87 9a 00 00
	00		 ja	 $LN26@deflate

; 775  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  00d95	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d9d	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  00da0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00da6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dab	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00db3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00db7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00dba	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dbf	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dc2	83 c1 01	 add	 ecx, 1
  00dc5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dca	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 776  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00dcd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00dd5	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  00dd8	c1 ea 08	 shr	 edx, 8
  00ddb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00de1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00de6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00de9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dee	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00df2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00df5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dfa	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dfd	83 c1 01	 add	 ecx, 1
  00e00	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e05	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 777  :                 strm->adler = crc32(0L, Z_NULL, 0);

  00e08	45 33 c0	 xor	 r8d, r8d
  00e0b	33 d2		 xor	 edx, edx
  00e0d	33 c9		 xor	 ecx, ecx
  00e0f	e8 00 00 00 00	 call	 crc32
  00e14	44 8b d8	 mov	 r11d, eax
  00e17	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e1f	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 778  :                 s->status = BUSY_STATE;

  00e23	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e28	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN26@deflate:

; 779  :             }
; 780  :         }
; 781  :         else

  00e2f	eb 0c		 jmp	 SHORT $LN25@deflate
$LN28@deflate:

; 782  :             s->status = BUSY_STATE;

  00e31	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e36	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN25@deflate:
$LN29@deflate:

; 783  :     }
; 784  : #endif
; 785  : 
; 786  :     /* Flush as much pending output as possible */
; 787  :     if (s->pending != 0) {

  00e3d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e42	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00e46	74 31		 je	 SHORT $LN24@deflate

; 788  :         flush_pending(strm);

  00e48	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e50	e8 00 00 00 00	 call	 flush_pending

; 789  :         if (strm->avail_out == 0) {

  00e55	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  00e5d	41 83 7b 18 00	 cmp	 DWORD PTR [r11+24], 0
  00e62	75 13		 jne	 SHORT $LN23@deflate

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;

  00e64	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e69	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 797  :             return Z_OK;

  00e70	33 c0		 xor	 eax, eax
  00e72	e9 f8 04 00 00	 jmp	 $LN84@deflate
$LN23@deflate:

; 798  :         }
; 799  : 
; 800  :     /* Make sure there is something to do and avoid duplicate consecutive
; 801  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 802  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 803  :      */
; 804  :     } else if (strm->avail_in == 0 && flush <= old_flush &&

  00e77	eb 42		 jmp	 SHORT $LN22@deflate
$LN24@deflate:

; 805  :                flush != Z_FINISH) {

  00e79	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e81	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00e85	75 34		 jne	 SHORT $LN21@deflate
  00e87	8b 44 24 28	 mov	 eax, DWORD PTR old_flush$[rsp]
  00e8b	39 84 24 98 00
	00 00		 cmp	 DWORD PTR flush$[rsp], eax
  00e92	7f 27		 jg	 SHORT $LN21@deflate
  00e94	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00e9c	74 1d		 je	 SHORT $LN21@deflate

; 806  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00e9e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00ea6	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00ead	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00eb1	b8 fb ff ff ff	 mov	 eax, -5
  00eb6	e9 b4 04 00 00	 jmp	 $LN84@deflate
$LN21@deflate:
$LN22@deflate:

; 807  :     }
; 808  : 
; 809  :     /* User must not provide more input after the first FINISH: */
; 810  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  00ebb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ec0	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00ec7	75 2b		 jne	 SHORT $LN20@deflate
  00ec9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ed1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ed5	74 1d		 je	 SHORT $LN20@deflate

; 811  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00ed7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00edf	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00ee6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00eea	b8 fb ff ff ff	 mov	 eax, -5
  00eef	e9 7b 04 00 00	 jmp	 $LN84@deflate
$LN20@deflate:

; 812  :     }
; 813  : 
; 814  :     /* Start a new block or continue the current one.
; 815  :      */
; 816  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  00ef4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00efc	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00f00	75 2e		 jne	 SHORT $LN18@deflate
  00f02	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f07	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00f0e	75 20		 jne	 SHORT $LN18@deflate
  00f10	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00f18	0f 84 c8 01 00
	00		 je	 $LN19@deflate
  00f1e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f23	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00f2a	0f 84 b6 01 00
	00		 je	 $LN19@deflate
$LN18@deflate:

; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 821  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 822  :                         (*(configuration_table[s->level].func))(s, flush));

  00f30	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f35	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00f3c	75 17		 jne	 SHORT $LN106@deflate
  00f3e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f45	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f4a	e8 00 00 00 00	 call	 deflate_huff
  00f4f	89 44 24 70	 mov	 DWORD PTR tv686[rsp], eax
  00f53	eb 59		 jmp	 SHORT $LN107@deflate
$LN106@deflate:
  00f55	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f5a	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  00f61	75 17		 jne	 SHORT $LN104@deflate
  00f63	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f6a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f6f	e8 00 00 00 00	 call	 deflate_rle
  00f74	89 44 24 74	 mov	 DWORD PTR tv685[rsp], eax
  00f78	eb 2c		 jmp	 SHORT $LN105@deflate
$LN104@deflate:
  00f7a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f7f	4c 63 80 ac 00
	00 00		 movsxd	 r8, DWORD PTR [rax+172]
  00f86	4d 6b c0 10	 imul	 r8, 16
  00f8a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00f91	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f98	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f9d	42 ff 54 00 08	 call	 QWORD PTR [rax+r8+8]
  00fa2	89 44 24 74	 mov	 DWORD PTR tv685[rsp], eax
$LN105@deflate:
  00fa6	8b 44 24 74	 mov	 eax, DWORD PTR tv685[rsp]
  00faa	89 44 24 70	 mov	 DWORD PTR tv686[rsp], eax
$LN107@deflate:
  00fae	8b 44 24 70	 mov	 eax, DWORD PTR tv686[rsp]
  00fb2	89 44 24 48	 mov	 DWORD PTR bstate$78487[rsp], eax

; 823  : 
; 824  :         if (bstate == finish_started || bstate == finish_done) {

  00fb6	83 7c 24 48 02	 cmp	 DWORD PTR bstate$78487[rsp], 2
  00fbb	74 07		 je	 SHORT $LN16@deflate
  00fbd	83 7c 24 48 03	 cmp	 DWORD PTR bstate$78487[rsp], 3
  00fc2	75 0c		 jne	 SHORT $LN17@deflate
$LN16@deflate:

; 825  :             s->status = FINISH_STATE;

  00fc4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00fc9	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH
$LN17@deflate:

; 826  :         }
; 827  :         if (bstate == need_more || bstate == finish_started) {

  00fd0	83 7c 24 48 00	 cmp	 DWORD PTR bstate$78487[rsp], 0
  00fd5	74 07		 je	 SHORT $LN14@deflate
  00fd7	83 7c 24 48 02	 cmp	 DWORD PTR bstate$78487[rsp], 2
  00fdc	75 21		 jne	 SHORT $LN15@deflate
$LN14@deflate:

; 828  :             if (strm->avail_out == 0) {

  00fde	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fe6	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00fea	75 0c		 jne	 SHORT $LN13@deflate

; 829  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  00fec	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ff1	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN13@deflate:

; 830  :             }
; 831  :             return Z_OK;

  00ff8	33 c0		 xor	 eax, eax
  00ffa	e9 70 03 00 00	 jmp	 $LN84@deflate
$LN15@deflate:

; 832  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 833  :              * of deflate should use the same flush parameter to make sure
; 834  :              * that the flush is complete. So we don't have to output an
; 835  :              * empty block here, this will be done at next call. This also
; 836  :              * ensures that for a very small output buffer, we emit at most
; 837  :              * one empty block.
; 838  :              */
; 839  :         }
; 840  :         if (bstate == block_done) {

  00fff	83 7c 24 48 01	 cmp	 DWORD PTR bstate$78487[rsp], 1
  01004	0f 85 dc 00 00
	00		 jne	 $LN12@deflate

; 841  :             if (flush == Z_PARTIAL_FLUSH) {

  0100a	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR flush$[rsp], 1
  01012	75 0f		 jne	 SHORT $LN11@deflate

; 842  :                 _tr_align(s);

  01014	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01019	e8 00 00 00 00	 call	 _tr_align
  0101e	e9 94 00 00 00	 jmp	 $LN10@deflate
$LN11@deflate:

; 843  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  01023	83 bc 24 98 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  0102b	0f 84 86 00 00
	00		 je	 $LN9@deflate

; 844  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  01031	45 33 c9	 xor	 r9d, r9d
  01034	45 33 c0	 xor	 r8d, r8d
  01037	33 d2		 xor	 edx, edx
  01039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0103e	e8 00 00 00 00	 call	 _tr_stored_block

; 845  :                 /* For a full flush, this empty block will be recognized
; 846  :                  * as a special marker by inflate_sync().
; 847  :                  */
; 848  :                 if (flush == Z_FULL_FLUSH) {

  01043	83 bc 24 98 00
	00 00 03	 cmp	 DWORD PTR flush$[rsp], 3
  0104b	75 6a		 jne	 SHORT $LN8@deflate

; 849  :                     CLEAR_HASH(s);             /* forget history */

  0104d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01052	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01055	83 e8 01	 sub	 eax, 1
  01058	8b d0		 mov	 edx, eax
  0105a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0105f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01063	33 c0		 xor	 eax, eax
  01065	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  01069	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0106e	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01071	83 e8 01	 sub	 eax, 1
  01074	44 8b c0	 mov	 r8d, eax
  01077	49 d1 e0	 shl	 r8, 1
  0107a	33 d2		 xor	 edx, edx
  0107c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01081	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01085	e8 00 00 00 00	 call	 memset

; 850  :                     if (s->lookahead == 0) {

  0108a	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0108f	41 83 bb 9c 00
	00 00 00	 cmp	 DWORD PTR [r11+156], 0
  01097	75 1e		 jne	 SHORT $LN7@deflate

; 851  :                         s->strstart = 0;

  01099	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0109e	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 852  :                         s->block_start = 0L;

  010a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010ad	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0
$LN7@deflate:
$LN8@deflate:
$LN9@deflate:
$LN10@deflate:

; 853  :                     }
; 854  :                 }
; 855  :             }
; 856  :             flush_pending(strm);

  010b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010bf	e8 00 00 00 00	 call	 flush_pending

; 857  :             if (strm->avail_out == 0) {

  010c4	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  010cc	41 83 7b 18 00	 cmp	 DWORD PTR [r11+24], 0
  010d1	75 13		 jne	 SHORT $LN6@deflate

; 858  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  010d3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010d8	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 859  :               return Z_OK;

  010df	33 c0		 xor	 eax, eax
  010e1	e9 89 02 00 00	 jmp	 $LN84@deflate
$LN6@deflate:
$LN12@deflate:
$LN19@deflate:

; 860  :             }
; 861  :         }
; 862  :     }
; 863  :     Assert(strm->avail_out > 0, "bug2");
; 864  : 
; 865  :     if (flush != Z_FINISH) return Z_OK;

  010e6	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  010ee	74 07		 je	 SHORT $LN5@deflate
  010f0	33 c0		 xor	 eax, eax
  010f2	e9 78 02 00 00	 jmp	 $LN84@deflate
$LN5@deflate:

; 866  :     if (s->wrap <= 0) return Z_STREAM_END;

  010f7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010fc	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  01100	7f 0a		 jg	 SHORT $LN4@deflate
  01102	b8 01 00 00 00	 mov	 eax, 1
  01107	e9 63 02 00 00	 jmp	 $LN84@deflate
$LN4@deflate:

; 867  : 
; 868  :     /* Write the trailer */
; 869  : #ifdef GZIP
; 870  :     if (s->wrap == 2) {

  0110c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01111	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  01115	0f 85 d4 01 00
	00		 jne	 $LN3@deflate

; 871  :         put_byte(s, (Byte)(strm->adler & 0xff));

  0111b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01123	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  01126	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0112c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01131	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01134	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01139	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0113d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01140	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01145	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01148	83 c1 01	 add	 ecx, 1
  0114b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01150	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 872  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  01153	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0115b	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  0115e	c1 ea 08	 shr	 edx, 8
  01161	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01167	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0116c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0116f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01174	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01178	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0117b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01180	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01183	83 c1 01	 add	 ecx, 1
  01186	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0118b	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 873  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  0118e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01196	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  01199	c1 ea 10	 shr	 edx, 16
  0119c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  011a2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011a7	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011aa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011af	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  011b3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  011b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011bb	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011be	83 c1 01	 add	 ecx, 1
  011c1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011c6	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 874  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  011c9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011d1	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  011d4	c1 ea 18	 shr	 edx, 24
  011d7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  011dd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011e2	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011ea	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  011ee	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  011f1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011f9	83 c1 01	 add	 ecx, 1
  011fc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01201	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 875  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  01204	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0120c	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  0120f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01215	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0121a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0121d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01222	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01226	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01229	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0122e	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01231	83 c1 01	 add	 ecx, 1
  01234	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01239	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 876  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  0123c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01244	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  01247	c1 ea 08	 shr	 edx, 8
  0124a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01250	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01255	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01258	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0125d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01261	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01264	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01269	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0126c	83 c1 01	 add	 ecx, 1
  0126f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01274	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 877  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  01277	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0127f	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  01282	c1 ea 10	 shr	 edx, 16
  01285	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0128b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01290	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01293	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01298	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0129c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0129f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012a4	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  012a7	83 c1 01	 add	 ecx, 1
  012aa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012af	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 878  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  012b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012ba	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  012bd	c1 ea 18	 shr	 edx, 24
  012c0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  012c6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012cb	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  012ce	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012d3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  012d7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  012da	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012df	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  012e2	83 c1 01	 add	 ecx, 1
  012e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012ea	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 879  :     }
; 880  :     else

  012ed	eb 34		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 881  : #endif
; 882  :     {
; 883  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  012ef	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012f7	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  012fa	c1 ea 10	 shr	 edx, 16
  012fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01302	e8 00 00 00 00	 call	 putShortMSB

; 884  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  01307	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  0130f	41 8b 53 4c	 mov	 edx, DWORD PTR [r11+76]
  01313	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01319	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0131e	e8 00 00 00 00	 call	 putShortMSB
$LN2@deflate:

; 885  :     }
; 886  :     flush_pending(strm);

  01323	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0132b	e8 00 00 00 00	 call	 flush_pending

; 887  :     /* If avail_out is zero, the application will call deflate again
; 888  :      * to flush the rest.
; 889  :      */
; 890  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  01330	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  01335	41 83 7b 2c 00	 cmp	 DWORD PTR [r11+44], 0
  0133a	7e 12		 jle	 SHORT $LN1@deflate
  0133c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01341	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  01344	f7 d9		 neg	 ecx
  01346	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0134b	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
$LN1@deflate:

; 891  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0134e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01353	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  01357	74 0a		 je	 SHORT $LN108@deflate
  01359	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv833[rsp], 0
  01361	eb 08		 jmp	 SHORT $LN109@deflate
$LN108@deflate:
  01363	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv833[rsp], 1
$LN109@deflate:
  0136b	8b 44 24 78	 mov	 eax, DWORD PTR tv833[rsp]
$LN84@deflate:

; 892  : }

  0136f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  01376	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
PUBLIC	deflateParams
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN11
	DD	imagerel $LN11+418
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateParams
_TEXT	SEGMENT
s$ = 32
err$ = 40
func$ = 48
strm$ = 80
level$ = 88
strategy$ = 96
deflateParams PROC					; COMDAT

; 416  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;

  00012	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR err$[rsp], 0

; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001a	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00020	74 0c		 je	 SHORT $LN7@deflatePar
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00027	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002c	75 0a		 jne	 SHORT $LN8@deflatePar
$LN7@deflatePar:
  0002e	b8 fe ff ff ff	 mov	 eax, -2
  00033	e9 65 01 00 00	 jmp	 $LN9@deflatePar
$LN8@deflatePar:

; 422  :     s = strm->state;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00041	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 423  : 
; 424  : #ifdef FASTEST
; 425  :     if (level != 0) level = 1;
; 426  : #else
; 427  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00046	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  0004b	75 08		 jne	 SHORT $LN6@deflatePar
  0004d	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN6@deflatePar:

; 428  : #endif
; 429  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00055	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  0005a	7c 15		 jl	 SHORT $LN4@deflatePar
  0005c	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  00061	7f 0e		 jg	 SHORT $LN4@deflatePar
  00063	83 7c 24 60 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00068	7c 07		 jl	 SHORT $LN4@deflatePar
  0006a	83 7c 24 60 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0006f	7e 0a		 jle	 SHORT $LN5@deflatePar
$LN4@deflatePar:

; 430  :         return Z_STREAM_ERROR;

  00071	b8 fe ff ff ff	 mov	 eax, -2
  00076	e9 22 01 00 00	 jmp	 $LN9@deflatePar
$LN5@deflatePar:

; 431  :     }
; 432  :     func = configuration_table[s->level].func;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00080	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  00087	48 6b c9 10	 imul	 rcx, 16
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00092	48 8b 44 08 08	 mov	 rax, QWORD PTR [rax+rcx+8]
  00097	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 433  : 
; 434  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 435  :         strm->total_in != 0) {

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [rax+176]
  000a7	39 44 24 60	 cmp	 DWORD PTR strategy$[rsp], eax
  000ab	75 1c		 jne	 SHORT $LN2@deflatePar
  000ad	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  000b2	48 6b c9 10	 imul	 rcx, 16
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000bd	48 8b 44 08 08	 mov	 rax, QWORD PTR [rax+rcx+8]
  000c2	48 39 44 24 30	 cmp	 QWORD PTR func$[rsp], rax
  000c7	74 1e		 je	 SHORT $LN3@deflatePar
$LN2@deflatePar:
  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000ce	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000d2	74 13		 je	 SHORT $LN3@deflatePar

; 436  :         /* Flush the last buffer: */
; 437  :         err = deflate(strm, Z_BLOCK);

  000d4	ba 05 00 00 00	 mov	 edx, 5
  000d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000de	e8 00 00 00 00	 call	 deflate
  000e3	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax
$LN3@deflatePar:

; 438  :     }
; 439  :     if (s->level != level) {

  000e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ec	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  000f0	39 81 ac 00 00
	00		 cmp	 DWORD PTR [rcx+172], eax
  000f6	0f 84 8e 00 00
	00		 je	 $LN1@deflatePar

; 440  :         s->level = level;

  000fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00101	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  00105	89 81 ac 00 00
	00		 mov	 DWORD PTR [rcx+172], eax

; 441  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  0010b	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  00110	48 6b c9 10	 imul	 rcx, 16
  00114	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0011b	0f b7 4c 08 02	 movzx	 ecx, WORD PTR [rax+rcx+2]
  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00125	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 442  :         s->good_match       = configuration_table[level].good_length;

  0012b	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  00130	48 6b c9 10	 imul	 rcx, 16
  00134	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0013b	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00144	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 443  :         s->nice_match       = configuration_table[level].nice_length;

  0014a	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  0014f	48 6b c9 10	 imul	 rcx, 16
  00153	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0015a	0f b7 4c 08 04	 movzx	 ecx, WORD PTR [rax+rcx+4]
  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00164	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 444  :         s->max_chain_length = configuration_table[level].max_chain;

  0016a	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  0016f	48 6b c9 10	 imul	 rcx, 16
  00173	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0017a	0f b7 4c 08 06	 movzx	 ecx, WORD PTR [rax+rcx+6]
  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00184	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx
$LN1@deflatePar:

; 445  :     }
; 446  :     s->strategy = strategy;

  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0018f	8b 44 24 60	 mov	 eax, DWORD PTR strategy$[rsp]
  00193	89 81 b0 00 00
	00		 mov	 DWORD PTR [rcx+176], eax

; 447  :     return err;

  00199	8b 44 24 28	 mov	 eax, DWORD PTR err$[rsp]
$LN9@deflatePar:

; 448  : }

  0019d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a1	c3		 ret	 0
deflateParams ENDP
END
