; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp_lseek:PROC
EXTRN	strcpy:PROC
EXTRN	strcat:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	gz_error
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzlib.c
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN8
	DD	imagerel $LN8+282
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 021301H
	DD	0300f3213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_error
_TEXT	SEGMENT
state$ = 48
err$ = 56
msg$ = 64
gz_error PROC						; COMDAT

; 489  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	53		 push	 rbx
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 490  :     /* free previously allocated message and clear */
; 491  :     if (state->msg != NULL) {

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 27		 je	 SHORT $LN5@gz_error

; 492  :         if (state->err != Z_MEM_ERROR)

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00024	83 78 60 fc	 cmp	 DWORD PTR [rax+96], -4
  00028	74 0f		 je	 SHORT $LN4@gz_error

; 493  :             free(state->msg);

  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0002f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gz_error:

; 494  :         state->msg = NULL;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003e	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN5@gz_error:

; 495  :     }
; 496  : 
; 497  :     /* set error code, and if no message, then done */
; 498  :     state->err = err;

  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0004b	8b 44 24 38	 mov	 eax, DWORD PTR err$[rsp]
  0004f	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 499  :     if (msg == NULL)

  00052	48 83 7c 24 40
	00		 cmp	 QWORD PTR msg$[rsp], 0
  00058	75 05		 jne	 SHORT $LN3@gz_error

; 500  :         return;

  0005a	e9 b5 00 00 00	 jmp	 $LN6@gz_error
$LN3@gz_error:

; 501  : 
; 502  :     /* for an out of memory error, save as static string */
; 503  :     if (err == Z_MEM_ERROR) {

  0005f	83 7c 24 38 fc	 cmp	 DWORD PTR err$[rsp], -4
  00064	75 13		 jne	 SHORT $LN2@gz_error

; 504  :         state->msg = (char *)msg;

  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR msg$[rsp]
  00070	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 505  :         return;

  00074	e9 9b 00 00 00	 jmp	 $LN6@gz_error
$LN2@gz_error:

; 506  :     }
; 507  : 
; 508  :     /* construct error message with path */
; 509  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0007e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00082	e8 00 00 00 00	 call	 strlen
  00087	48 8b d8	 mov	 rbx, rax
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  0008f	e8 00 00 00 00	 call	 strlen
  00094	48 8d 4c 03 03	 lea	 rcx, QWORD PTR [rbx+rax+3]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0009f	4c 8b d8	 mov	 r11, rax
  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000a7	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b0	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000b5	75 1e		 jne	 SHORT $LN1@gz_error

; 510  :         state->err = Z_MEM_ERROR;

  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000bc	c7 40 60 fc ff
	ff ff		 mov	 DWORD PTR [rax+96], -4

; 511  :         state->msg = (char *)"out of memory";

  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000cf	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 512  :         return;

  000d3	eb 3f		 jmp	 SHORT $LN6@gz_error
$LN1@gz_error:

; 513  :     }
; 514  :     strcpy(state->msg, state->path);

  000d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  000da	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000e3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000e7	e8 00 00 00 00	 call	 strcpy

; 515  :     strcat(state->msg, ": ");

  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000f8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000fc	e8 00 00 00 00	 call	 strcat

; 516  :     strcat(state->msg, msg);

  00101	48 8b 54 24 40	 mov	 rdx, QWORD PTR msg$[rsp]
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0010f	e8 00 00 00 00	 call	 strcat
$LN6@gz_error:

; 517  :     return;
; 518  : }

  00114	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00118	5b		 pop	 rbx
  00119	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
PUBLIC	gzclearerr
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclearerr DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$gzclearerr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclearerr DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzclearerr
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzclearerr PROC						; COMDAT

; 463  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 464  :     gz_statep state;
; 465  : 
; 466  :     /* get internal structure and check integrity */
; 467  :     if (file == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 02		 jne	 SHORT $LN3@gzclearerr

; 468  :         return;

  00011	eb 4e		 jmp	 SHORT $LN4@gzclearerr
$LN3@gzclearerr:

; 469  :     state = (gz_statep)file;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 470  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00022	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00028	74 0f		 je	 SHORT $LN2@gzclearerr
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0002f	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00035	74 02		 je	 SHORT $LN2@gzclearerr

; 471  :         return;

  00037	eb 28		 jmp	 SHORT $LN4@gzclearerr
$LN2@gzclearerr:

; 472  : 
; 473  :     /* clear error and end-of-file */
; 474  :     if (state->mode == GZ_READ)

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0003e	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00044	75 0c		 jne	 SHORT $LN1@gzclearerr

; 475  :         state->eof = 0;

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004b	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0
$LN1@gzclearerr:

; 476  :     gz_error(state, Z_OK, NULL);

  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0005c	e8 00 00 00 00	 call	 gz_error
$LN4@gzclearerr:

; 477  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
PUBLIC	gzerror
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzerror DD imagerel $LN8
	DD	imagerel $LN8+133
	DD	imagerel $unwind$gzerror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzerror DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzerror
_TEXT	SEGMENT
state$ = 0
tv72 = 8
file$ = 32
errnum$ = 40
gzerror	PROC						; COMDAT

; 444  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 445  :     gz_statep state;
; 446  : 
; 447  :     /* get internal structure and check integrity */
; 448  :     if (file == NULL)

  0000e	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  00014	75 04		 jne	 SHORT $LN3@gzerror

; 449  :         return NULL;

  00016	33 c0		 xor	 eax, eax
  00018	eb 66		 jmp	 SHORT $LN4@gzerror
$LN3@gzerror:

; 450  :     state = (gz_statep)file;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR file$[rsp]
  0001f	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 451  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00023	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00027	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002d	74 10		 je	 SHORT $LN2@gzerror
  0002f	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00033	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00039	74 04		 je	 SHORT $LN2@gzerror

; 452  :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 41		 jmp	 SHORT $LN4@gzerror
$LN2@gzerror:

; 453  : 
; 454  :     /* return error information */
; 455  :     if (errnum != NULL)

  0003f	48 83 7c 24 28
	00		 cmp	 QWORD PTR errnum$[rsp], 0
  00045	74 0e		 je	 SHORT $LN1@gzerror

; 456  :         *errnum = state->err;

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR errnum$[rsp]
  0004c	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00050	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00053	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@gzerror:

; 457  :     return state->msg == NULL ? "" : state->msg;

  00055	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00059	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005e	75 0e		 jne	 SHORT $LN6@gzerror
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00067	48 89 44 24 08	 mov	 QWORD PTR tv72[rsp], rax
  0006c	eb 0d		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  0006e	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00072	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00076	48 89 44 24 08	 mov	 QWORD PTR tv72[rsp], rax
$LN7@gzerror:
  0007b	48 8b 44 24 08	 mov	 rax, QWORD PTR tv72[rsp]
$LN4@gzerror:

; 458  : }

  00080	48 83 c4 18	 add	 rsp, 24
  00084	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
PUBLIC	gzeof
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzeof DD	imagerel $LN9
	DD	imagerel $LN9+145
	DD	imagerel $unwind$gzeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzeof DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzeof
_TEXT	SEGMENT
state$ = 0
tv74 = 8
tv75 = 12
file$ = 32
gzeof	PROC						; COMDAT

; 425  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 426  :     gz_statep state;
; 427  : 
; 428  :     /* get internal structure and check integrity */
; 429  :     if (file == NULL)

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 04		 jne	 SHORT $LN2@gzeof

; 430  :         return 0;

  00011	33 c0		 xor	 eax, eax
  00013	eb 77		 jmp	 SHORT $LN3@gzeof
$LN2@gzeof:

; 431  :     state = (gz_statep)file;

  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR file$[rsp]
  0001a	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 432  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001e	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00022	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00028	74 10		 je	 SHORT $LN1@gzeof
  0002a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0002e	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00034	74 04		 je	 SHORT $LN1@gzeof

; 433  :         return 0;

  00036	33 c0		 xor	 eax, eax
  00038	eb 52		 jmp	 SHORT $LN3@gzeof
$LN1@gzeof:

; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00044	75 3a		 jne	 SHORT $LN7@gzeof
  00046	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0004a	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0004e	74 1e		 je	 SHORT $LN5@gzeof
  00050	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00054	83 78 78 00	 cmp	 DWORD PTR [rax+120], 0
  00058	75 14		 jne	 SHORT $LN5@gzeof
  0005a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0005e	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00062	75 0a		 jne	 SHORT $LN5@gzeof
  00064	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0006c	eb 08		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  0006e	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN6@gzeof:
  00076	8b 44 24 08	 mov	 eax, DWORD PTR tv74[rsp]
  0007a	89 44 24 0c	 mov	 DWORD PTR tv75[rsp], eax
  0007e	eb 08		 jmp	 SHORT $LN8@gzeof
$LN7@gzeof:
  00080	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@gzeof:
  00088	8b 44 24 0c	 mov	 eax, DWORD PTR tv75[rsp]
$LN3@gzeof:

; 438  : }

  0008c	48 83 c4 18	 add	 rsp, 24
  00090	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
PUBLIC	gzoffset64
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN7
	DD	imagerel $LN7+147
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzoffset64
_TEXT	SEGMENT
offset$ = 32
state$ = 40
file$ = 64
gzoffset64 PROC						; COMDAT

; 392  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 393  :     z_off64_t offset;
; 394  :     gz_statep state;
; 395  : 
; 396  :     /* get internal structure and check integrity */
; 397  :     if (file == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN4@gzoffset64

; 398  :         return -1;

  00011	b8 ff ff ff ff	 mov	 eax, -1
  00016	eb 76		 jmp	 SHORT $LN5@gzoffset64
$LN4@gzoffset64:

; 399  :     state = (gz_statep)file;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 400  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00027	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002d	74 14		 je	 SHORT $LN3@gzoffset64
  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00034	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  0003a	74 07		 je	 SHORT $LN3@gzoffset64

; 401  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	eb 4b		 jmp	 SHORT $LN5@gzoffset64
$LN3@gzoffset64:

; 402  : 
; 403  :     /* compute and return effective offset in file */
; 404  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00043	41 b8 01 00 00
	00		 mov	 r8d, 1
  00049	33 d2		 xor	 edx, edx
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  00059	89 44 24 20	 mov	 DWORD PTR offset$[rsp], eax

; 405  :     if (offset == -1)

  0005d	83 7c 24 20 ff	 cmp	 DWORD PTR offset$[rsp], -1
  00062	75 07		 jne	 SHORT $LN2@gzoffset64

; 406  :         return -1;

  00064	b8 ff ff ff ff	 mov	 eax, -1
  00069	eb 23		 jmp	 SHORT $LN5@gzoffset64
$LN2@gzoffset64:

; 407  :     if (state->mode == GZ_READ)             /* reading */

  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00070	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00076	75 12		 jne	 SHORT $LN1@gzoffset64

; 408  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007d	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  00080	8b 44 24 20	 mov	 eax, DWORD PTR offset$[rsp]
  00084	2b c1		 sub	 eax, ecx
  00086	89 44 24 20	 mov	 DWORD PTR offset$[rsp], eax
$LN1@gzoffset64:

; 409  :     return offset;

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR offset$[rsp]
$LN5@gzoffset64:

; 410  : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
PUBLIC	gztell64
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell64 DD imagerel $LN7
	DD	imagerel $LN7+111
	DD	imagerel $unwind$gztell64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell64 DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gztell64
_TEXT	SEGMENT
state$ = 0
tv71 = 8
file$ = 32
gztell64 PROC						; COMDAT

; 365  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 366  :     gz_statep state;
; 367  : 
; 368  :     /* get internal structure and check integrity */
; 369  :     if (file == NULL)

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@gztell64

; 370  :         return -1;

  00011	b8 ff ff ff ff	 mov	 eax, -1
  00016	eb 52		 jmp	 SHORT $LN3@gztell64
$LN2@gztell64:

; 371  :     state = (gz_statep)file;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR file$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 372  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00021	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00025	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002b	74 13		 je	 SHORT $LN1@gztell64
  0002d	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00031	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00037	74 07		 je	 SHORT $LN1@gztell64

; 373  :         return -1;

  00039	b8 ff ff ff ff	 mov	 eax, -1
  0003e	eb 2a		 jmp	 SHORT $LN3@gztell64
$LN1@gztell64:

; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00040	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00044	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00048	74 0d		 je	 SHORT $LN5@gztell64
  0004a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0004e	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00051	89 44 24 08	 mov	 DWORD PTR tv71[rsp], eax
  00055	eb 08		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00057	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN6@gztell64:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00063	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00066	03 44 24 08	 add	 eax, DWORD PTR tv71[rsp]
$LN3@gztell64:

; 377  : }

  0006a	48 83 c4 18	 add	 rsp, 24
  0006e	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
PUBLIC	gzbuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzbuffer DD imagerel $LN7
	DD	imagerel $LN7+117
	DD	imagerel $unwind$gzbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzbuffer DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzbuffer
_TEXT	SEGMENT
state$ = 0
file$ = 32
size$ = 40
gzbuffer PROC						; COMDAT

; 231  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 232  :     gz_statep state;
; 233  : 
; 234  :     /* get internal structure and check integrity */
; 235  :     if (file == NULL)

  0000d	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  00013	75 07		 jne	 SHORT $LN4@gzbuffer

; 236  :         return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 54		 jmp	 SHORT $LN5@gzbuffer
$LN4@gzbuffer:

; 237  :     state = (gz_statep)file;

  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR file$[rsp]
  00021	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 238  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00025	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00029	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002f	74 13		 je	 SHORT $LN3@gzbuffer
  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  0003b	74 07		 je	 SHORT $LN3@gzbuffer

; 239  :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	eb 2c		 jmp	 SHORT $LN5@gzbuffer
$LN3@gzbuffer:

; 240  : 
; 241  :     /* make sure we haven't already allocated memory */
; 242  :     if (state->size != 0)

  00044	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00048	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0004c	74 07		 je	 SHORT $LN2@gzbuffer

; 243  :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	eb 1b		 jmp	 SHORT $LN5@gzbuffer
$LN2@gzbuffer:

; 244  : 
; 245  :     /* check and set requested size */
; 246  :     if (size == 0)

  00055	83 7c 24 28 00	 cmp	 DWORD PTR size$[rsp], 0
  0005a	75 07		 jne	 SHORT $LN1@gzbuffer

; 247  :         return -1;

  0005c	b8 ff ff ff ff	 mov	 eax, -1
  00061	eb 0d		 jmp	 SHORT $LN5@gzbuffer
$LN1@gzbuffer:

; 248  :     state->want = size;

  00063	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  00067	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0006b	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 249  :     return 0;

  0006e	33 c0		 xor	 eax, eax
$LN5@gzbuffer:

; 250  : }

  00070	48 83 c4 18	 add	 rsp, 24
  00074	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+127
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 73   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 74   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0000e	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00014	75 30		 jne	 SHORT $LN1@gz_reset

; 75   :         state->have = 0;            /* no output data available */

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0001b	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 76   :         state->eof = 0;             /* not at end of file */

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00027	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 77   :         state->how = LOOK;          /* look for gzip header */

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00033	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 78   :         state->direct = 1;          /* default for empty file */

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003f	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1
$LN1@gz_reset:

; 79   :     }
; 80   :     state->seek = 0;                /* no seek request pending */

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004b	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 81   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0005c	e8 00 00 00 00	 call	 gz_error

; 82   :     state->pos = 0;                 /* no uncompressed data yet */

  00061	4c 8b 5c 24 30	 mov	 r11, QWORD PTR state$[rsp]
  00066	41 c7 43 10 00
	00 00 00	 mov	 DWORD PTR [r11+16], 0

; 83   :     state->strm.avail_in = 0;       /* no input data yet */

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00073	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 84   : }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
gz_reset ENDP
PUBLIC	gzoffset
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$gzoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzoffset
_TEXT	SEGMENT
ret$ = 32
tv67 = 36
file$ = 64
gzoffset PROC						; COMDAT

; 415  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 416  :     z_off64_t ret;
; 417  : 
; 418  :     ret = gzoffset64(file);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0000e	e8 00 00 00 00	 call	 gzoffset64
  00013	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 419  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00017	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  0001b	39 44 24 20	 cmp	 DWORD PTR ret$[rsp], eax
  0001f	75 0a		 jne	 SHORT $LN3@gzoffset
  00021	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00025	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  00029	eb 08		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  0002b	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv67[rsp], -1
$LN4@gzoffset:
  00033	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]

; 420  : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
gzoffset ENDP
_TEXT	ENDS
PUBLIC	gztell
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$gztell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gztell
_TEXT	SEGMENT
ret$ = 32
tv67 = 36
file$ = 64
gztell	PROC						; COMDAT

; 382  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 383  :     z_off64_t ret;
; 384  : 
; 385  :     ret = gztell64(file);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0000e	e8 00 00 00 00	 call	 gztell64
  00013	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 386  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00017	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  0001b	39 44 24 20	 cmp	 DWORD PTR ret$[rsp], eax
  0001f	75 0a		 jne	 SHORT $LN3@gztell
  00021	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00025	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  00029	eb 08		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  0002b	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv67[rsp], -1
$LN4@gztell:
  00033	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]

; 387  : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
gztell	ENDP
_TEXT	ENDS
PUBLIC	gzrewind
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN7
	DD	imagerel $LN7+119
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzrewind
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzrewind PROC						; COMDAT

; 255  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 256  :     gz_statep state;
; 257  : 
; 258  :     /* get internal structure */
; 259  :     if (file == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN4@gzrewind

; 260  :         return -1;

  00011	b8 ff ff ff ff	 mov	 eax, -1
  00016	eb 5a		 jmp	 SHORT $LN5@gzrewind
$LN4@gzrewind:

; 261  :     state = (gz_statep)file;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 262  : 
; 263  :     /* check that we're reading and that there's no error */
; 264  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00027	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002d	75 0b		 jne	 SHORT $LN2@gzrewind
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00034	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00038	74 07		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:

; 265  :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	eb 31		 jmp	 SHORT $LN5@gzrewind
$LN3@gzrewind:

; 266  : 
; 267  :     /* back up and start over */
; 268  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00041	45 33 c0	 xor	 r8d, r8d
  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00049	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	75 07		 jne	 SHORT $LN1@gzrewind

; 269  :         return -1;

  0005f	b8 ff ff ff ff	 mov	 eax, -1
  00064	eb 0c		 jmp	 SHORT $LN5@gzrewind
$LN1@gzrewind:

; 270  :     gz_reset(state);

  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0006b	e8 00 00 00 00	 call	 gz_reset

; 271  :     return 0;

  00070	33 c0		 xor	 eax, eax
$LN5@gzrewind:

; 272  : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+889
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_open
_TEXT	SEGMENT
state$ = 32
tv82 = 40
tv149 = 44
tv145 = 48
tv143 = 52
path$ = 80
fd$ = 88
mode$ = 96
gz_open	PROC						; COMDAT

; 91   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     gz_statep state;
; 93   : 
; 94   :     /* allocate gzFile structure to return */
; 95   :     state = malloc(sizeof(gz_state));

  00012	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001d	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 96   :     if (state == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  00028	75 07		 jne	 SHORT $LN23@gz_open

; 97   :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 d2 02 00 00	 jmp	 $LN24@gz_open
$LN23@gz_open:

; 98   :     state->size = 0;            /* no buffers allocated yet */

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 99   :     state->want = GZBUFSIZE;    /* requested buffer size */

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00042	c7 40 18 00 20
	00 00		 mov	 DWORD PTR [rax+24], 8192 ; 00002000H

; 100  :     state->msg = NULL;          /* no error message yet */

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004e	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 101  : 
; 102  :     /* interpret mode */
; 103  :     state->mode = GZ_NONE;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 104  :     state->level = Z_DEFAULT_COMPRESSION;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00066	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 105  :     state->strategy = Z_DEFAULT_STRATEGY;

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00072	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0
$LN22@gz_open:

; 106  :     while (*mode) {

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  0007e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00081	85 c0		 test	 eax, eax
  00083	0f 84 f8 00 00
	00		 je	 $LN21@gz_open

; 107  :         if (*mode >= '0' && *mode <= '9')

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  0008e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00091	83 f8 30	 cmp	 eax, 48			; 00000030H
  00094	7c 25		 jl	 SHORT $LN20@gz_open
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  0009b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009e	83 f8 39	 cmp	 eax, 57			; 00000039H
  000a1	7f 18		 jg	 SHORT $LN20@gz_open

; 108  :             state->level = *mode - '0';

  000a3	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  000a8	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  000ab	83 e9 30	 sub	 ecx, 48			; 00000030H
  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b3	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 109  :         else

  000b6	e9 b3 00 00 00	 jmp	 $LN19@gz_open
$LN20@gz_open:

; 110  :             switch (*mode) {

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  000c0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c3	89 44 24 28	 mov	 DWORD PTR tv82[rsp], eax
  000c7	8b 44 24 28	 mov	 eax, DWORD PTR tv82[rsp]
  000cb	83 e8 2b	 sub	 eax, 43			; 0000002bH
  000ce	89 44 24 28	 mov	 DWORD PTR tv82[rsp], eax
  000d2	83 7c 24 28 4c	 cmp	 DWORD PTR tv82[rsp], 76	; 0000004cH
  000d7	0f 87 91 00 00
	00		 ja	 $LN7@gz_open
  000dd	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv82[rsp]
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000e9	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN32@gz_open[rcx+rax]
  000f1	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN33@gz_open[rcx+rax*4]
  000f8	48 03 c1	 add	 rax, rcx
  000fb	ff e0		 jmp	 rax
$LN16@gz_open:

; 111  :             case 'r':
; 112  :                 state->mode = GZ_READ;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00102	c7 00 4f 1c 00
	00		 mov	 DWORD PTR [rax], 7247	; 00001c4fH

; 113  :                 break;

  00108	eb 64		 jmp	 SHORT $LN17@gz_open
$LN15@gz_open:

; 114  : #ifndef NO_GZCOMPRESS
; 115  :             case 'w':
; 116  :                 state->mode = GZ_WRITE;

  0010a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0010f	c7 00 b1 79 00
	00		 mov	 DWORD PTR [rax], 31153	; 000079b1H

; 117  :                 break;

  00115	eb 57		 jmp	 SHORT $LN17@gz_open
$LN14@gz_open:

; 118  :             case 'a':
; 119  :                 state->mode = GZ_APPEND;

  00117	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0011c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 120  :                 break;

  00122	eb 4a		 jmp	 SHORT $LN17@gz_open
$LN13@gz_open:

; 121  : #endif
; 122  :             case '+':       /* can't read and write at the same time */
; 123  :                 free(state);

  00124	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 124  :                 return NULL;

  0012f	33 c0		 xor	 eax, eax
  00131	e9 cd 01 00 00	 jmp	 $LN24@gz_open

; 125  :             case 'b':       /* ignore -- will request binary anyway */
; 126  :                 break;

  00136	eb 36		 jmp	 SHORT $LN17@gz_open
$LN11@gz_open:

; 127  :             case 'f':
; 128  :                 state->strategy = Z_FILTERED;

  00138	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0013d	c7 40 54 01 00
	00 00		 mov	 DWORD PTR [rax+84], 1

; 129  :                 break;

  00144	eb 28		 jmp	 SHORT $LN17@gz_open
$LN10@gz_open:

; 130  :             case 'h':
; 131  :                 state->strategy = Z_HUFFMAN_ONLY;

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0014b	c7 40 54 02 00
	00 00		 mov	 DWORD PTR [rax+84], 2

; 132  :                 break;

  00152	eb 1a		 jmp	 SHORT $LN17@gz_open
$LN9@gz_open:

; 133  :             case 'R':
; 134  :                 state->strategy = Z_RLE;

  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00159	c7 40 54 03 00
	00 00		 mov	 DWORD PTR [rax+84], 3

; 135  :                 break;

  00160	eb 0c		 jmp	 SHORT $LN17@gz_open
$LN8@gz_open:

; 136  :             case 'F':
; 137  :                 state->strategy = Z_FIXED;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00167	c7 40 54 04 00
	00 00		 mov	 DWORD PTR [rax+84], 4
$LN7@gz_open:
$LN17@gz_open:
$LN19@gz_open:

; 138  :             default:        /* could consider as an error, but just ignore */
; 139  :                 ;
; 140  :             }
; 141  :         mode++;

  0016e	48 8b 44 24 60	 mov	 rax, QWORD PTR mode$[rsp]
  00173	48 83 c0 01	 add	 rax, 1
  00177	48 89 44 24 60	 mov	 QWORD PTR mode$[rsp], rax

; 142  :     }

  0017c	e9 f8 fe ff ff	 jmp	 $LN22@gz_open
$LN21@gz_open:

; 143  : 
; 144  :     /* must provide an "r", "w", or "a" */
; 145  :     if (state->mode == GZ_NONE) {

  00181	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00186	83 38 00	 cmp	 DWORD PTR [rax], 0
  00189	75 12		 jne	 SHORT $LN6@gz_open

; 146  :         free(state);

  0018b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 147  :         return NULL;

  00196	33 c0		 xor	 eax, eax
  00198	e9 66 01 00 00	 jmp	 $LN24@gz_open
$LN6@gz_open:

; 148  :     }
; 149  : 
; 150  :     /* save the path name for error messages */
; 151  :     state->path = malloc(strlen(path) + 1);

  0019d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp]
  001a2	e8 00 00 00 00	 call	 strlen
  001a7	48 8b c8	 mov	 rcx, rax
  001aa	48 83 c1 01	 add	 rcx, 1
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001b4	4c 8b d8	 mov	 r11, rax
  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001bc	4c 89 58 08	 mov	 QWORD PTR [rax+8], r11

; 152  :     if (state->path == NULL) {

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001c5	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001ca	75 12		 jne	 SHORT $LN5@gz_open

; 153  :         free(state);

  001cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 154  :         return NULL;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 25 01 00 00	 jmp	 $LN24@gz_open
$LN5@gz_open:

; 155  :     }
; 156  :     strcpy(state->path, path);

  001de	48 8b 54 24 50	 mov	 rdx, QWORD PTR path$[rsp]
  001e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001e8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001ec	e8 00 00 00 00	 call	 strcpy

; 157  : 
; 158  :     /* open the file with the appropriate mode (or just use fd) */
; 159  :     state->fd = fd != -1 ? fd :
; 160  :         open(path,
; 161  : #ifdef O_LARGEFILE
; 162  :             O_LARGEFILE |
; 163  : #endif
; 164  : #ifdef O_BINARY
; 165  :             O_BINARY |
; 166  : #endif
; 167  :             (state->mode == GZ_READ ?
; 168  :                 O_RDONLY :
; 169  :                 (O_WRONLY | O_CREAT | (
; 170  :                     state->mode == GZ_WRITE ?
; 171  :                         O_TRUNC :
; 172  :                         O_APPEND))),
; 173  :             0666);

  001f1	83 7c 24 58 ff	 cmp	 DWORD PTR fd$[rsp], -1
  001f6	74 0a		 je	 SHORT $LN30@gz_open
  001f8	8b 44 24 58	 mov	 eax, DWORD PTR fd$[rsp]
  001fc	89 44 24 2c	 mov	 DWORD PTR tv149[rsp], eax
  00200	eb 62		 jmp	 SHORT $LN31@gz_open
$LN30@gz_open:
  00202	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00207	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0020d	75 0a		 jne	 SHORT $LN28@gz_open
  0020f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
  00217	eb 2c		 jmp	 SHORT $LN29@gz_open
$LN28@gz_open:
  00219	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0021e	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00224	75 0a		 jne	 SHORT $LN26@gz_open
  00226	c7 44 24 34 00
	02 00 00	 mov	 DWORD PTR tv143[rsp], 512 ; 00000200H
  0022e	eb 08		 jmp	 SHORT $LN27@gz_open
$LN26@gz_open:
  00230	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR tv143[rsp], 8
$LN27@gz_open:
  00238	8b 44 24 34	 mov	 eax, DWORD PTR tv143[rsp]
  0023c	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  00241	89 44 24 30	 mov	 DWORD PTR tv145[rsp], eax
$LN29@gz_open:
  00245	8b 54 24 30	 mov	 edx, DWORD PTR tv145[rsp]
  00249	81 ca 00 80 00
	00		 or	 edx, 32768		; 00008000H
  0024f	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00255	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  00260	89 44 24 2c	 mov	 DWORD PTR tv149[rsp], eax
$LN31@gz_open:
  00264	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00269	8b 44 24 2c	 mov	 eax, DWORD PTR tv149[rsp]
  0026d	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 174  :     if (state->fd == -1) {

  00270	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00275	83 78 04 ff	 cmp	 DWORD PTR [rax+4], -1
  00279	75 1e		 jne	 SHORT $LN4@gz_open

; 175  :         free(state->path);

  0027b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00280	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 176  :         free(state);

  0028a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 177  :         return NULL;

  00295	33 c0		 xor	 eax, eax
  00297	eb 6a		 jmp	 SHORT $LN24@gz_open
$LN4@gz_open:

; 178  :     }
; 179  :     if (state->mode == GZ_APPEND)

  00299	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0029e	83 38 01	 cmp	 DWORD PTR [rax], 1
  002a1	75 0b		 jne	 SHORT $LN3@gz_open

; 180  :         state->mode = GZ_WRITE;         /* simplify later checks */

  002a3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002a8	c7 00 b1 79 00
	00		 mov	 DWORD PTR [rax], 31153	; 000079b1H
$LN3@gz_open:

; 181  : 
; 182  :     /* save the current position for rewinding (only if reading) */
; 183  :     if (state->mode == GZ_READ) {

  002ae	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002b3	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  002b9	75 39		 jne	 SHORT $LN2@gz_open

; 184  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  002bb	41 b8 01 00 00
	00		 mov	 r8d, 1
  002c1	33 d2		 xor	 edx, edx
  002c3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002c8	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  002d1	44 8b d8	 mov	 r11d, eax
  002d4	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002d9	44 89 58 40	 mov	 DWORD PTR [rax+64], r11d

; 185  :         if (state->start == -1) state->start = 0;

  002dd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002e2	83 78 40 ff	 cmp	 DWORD PTR [rax+64], -1
  002e6	75 0c		 jne	 SHORT $LN1@gz_open
  002e8	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002ed	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0
$LN1@gz_open:
$LN2@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  002f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  002f9	e8 00 00 00 00	 call	 gz_reset

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  002fe	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
$LN24@gz_open:

; 193  : }

  00303	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00307	c3		 ret	 0
$LN33@gz_open:
  00308	00 00 00 00	 DD	 $LN13@gz_open
  0030c	00 00 00 00	 DD	 $LN8@gz_open
  00310	00 00 00 00	 DD	 $LN9@gz_open
  00314	00 00 00 00	 DD	 $LN14@gz_open
  00318	00 00 00 00	 DD	 $LN11@gz_open
  0031c	00 00 00 00	 DD	 $LN10@gz_open
  00320	00 00 00 00	 DD	 $LN16@gz_open
  00324	00 00 00 00	 DD	 $LN15@gz_open
  00328	00 00 00 00	 DD	 $LN7@gz_open
$LN32@gz_open:
  0032c	00		 DB	 0
  0032d	08		 DB	 8
  0032e	08		 DB	 8
  0032f	08		 DB	 8
  00330	08		 DB	 8
  00331	08		 DB	 8
  00332	08		 DB	 8
  00333	08		 DB	 8
  00334	08		 DB	 8
  00335	08		 DB	 8
  00336	08		 DB	 8
  00337	08		 DB	 8
  00338	08		 DB	 8
  00339	08		 DB	 8
  0033a	08		 DB	 8
  0033b	08		 DB	 8
  0033c	08		 DB	 8
  0033d	08		 DB	 8
  0033e	08		 DB	 8
  0033f	08		 DB	 8
  00340	08		 DB	 8
  00341	08		 DB	 8
  00342	08		 DB	 8
  00343	08		 DB	 8
  00344	08		 DB	 8
  00345	08		 DB	 8
  00346	08		 DB	 8
  00347	01		 DB	 1
  00348	08		 DB	 8
  00349	08		 DB	 8
  0034a	08		 DB	 8
  0034b	08		 DB	 8
  0034c	08		 DB	 8
  0034d	08		 DB	 8
  0034e	08		 DB	 8
  0034f	08		 DB	 8
  00350	08		 DB	 8
  00351	08		 DB	 8
  00352	08		 DB	 8
  00353	02		 DB	 2
  00354	08		 DB	 8
  00355	08		 DB	 8
  00356	08		 DB	 8
  00357	08		 DB	 8
  00358	08		 DB	 8
  00359	08		 DB	 8
  0035a	08		 DB	 8
  0035b	08		 DB	 8
  0035c	08		 DB	 8
  0035d	08		 DB	 8
  0035e	08		 DB	 8
  0035f	08		 DB	 8
  00360	08		 DB	 8
  00361	08		 DB	 8
  00362	03		 DB	 3
  00363	08		 DB	 8
  00364	08		 DB	 8
  00365	08		 DB	 8
  00366	08		 DB	 8
  00367	04		 DB	 4
  00368	08		 DB	 8
  00369	05		 DB	 5
  0036a	08		 DB	 8
  0036b	08		 DB	 8
  0036c	08		 DB	 8
  0036d	08		 DB	 8
  0036e	08		 DB	 8
  0036f	08		 DB	 8
  00370	08		 DB	 8
  00371	08		 DB	 8
  00372	08		 DB	 8
  00373	06		 DB	 6
  00374	08		 DB	 8
  00375	08		 DB	 8
  00376	08		 DB	 8
  00377	08		 DB	 8
  00378	07		 DB	 7
gz_open	ENDP
PUBLIC	gzseek64
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN21
	DD	imagerel $LN21+703
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzseek64
_TEXT	SEGMENT
n$ = 32
ret$ = 36
state$ = 40
tv152 = 48
file$ = 80
offset$ = 88
whence$ = 96
gzseek64 PROC						; COMDAT

; 279  : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 280  :     unsigned n;
; 281  :     z_off64_t ret;
; 282  :     gz_statep state;
; 283  : 
; 284  :     /* get internal structure and check integrity */
; 285  :     if (file == NULL)

  00012	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00018	75 0a		 jne	 SHORT $LN15@gzseek64

; 286  :         return -1;

  0001a	b8 ff ff ff ff	 mov	 eax, -1
  0001f	e9 96 02 00 00	 jmp	 $LN16@gzseek64
$LN15@gzseek64:

; 287  :     state = (gz_statep)file;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 288  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00033	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00039	74 17		 je	 SHORT $LN14@gzseek64
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00040	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00046	74 0a		 je	 SHORT $LN14@gzseek64

; 289  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	e9 68 02 00 00	 jmp	 $LN16@gzseek64
$LN14@gzseek64:

; 290  : 
; 291  :     /* check that there's no error */
; 292  :     if (state->err != Z_OK)

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00057	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0005b	74 0a		 je	 SHORT $LN13@gzseek64

; 293  :         return -1;

  0005d	b8 ff ff ff ff	 mov	 eax, -1
  00062	e9 53 02 00 00	 jmp	 $LN16@gzseek64
$LN13@gzseek64:

; 294  : 
; 295  :     /* can only seek from start or relative to current position */
; 296  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00067	83 7c 24 60 00	 cmp	 DWORD PTR whence$[rsp], 0
  0006c	74 11		 je	 SHORT $LN12@gzseek64
  0006e	83 7c 24 60 01	 cmp	 DWORD PTR whence$[rsp], 1
  00073	74 0a		 je	 SHORT $LN12@gzseek64

; 297  :         return -1;

  00075	b8 ff ff ff ff	 mov	 eax, -1
  0007a	e9 3b 02 00 00	 jmp	 $LN16@gzseek64
$LN12@gzseek64:

; 298  : 
; 299  :     /* normalize offset to a SEEK_CUR specification */
; 300  :     if (whence == SEEK_SET)

  0007f	83 7c 24 60 00	 cmp	 DWORD PTR whence$[rsp], 0
  00084	75 14		 jne	 SHORT $LN11@gzseek64

; 301  :         offset -= state->pos;

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0008b	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0008e	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  00092	2b c1		 sub	 eax, ecx
  00094	89 44 24 58	 mov	 DWORD PTR offset$[rsp], eax
  00098	eb 1d		 jmp	 SHORT $LN10@gzseek64
$LN11@gzseek64:

; 302  :     else if (state->seek)

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009f	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  000a3	74 12		 je	 SHORT $LN9@gzseek64

; 303  :         offset += state->skip;

  000a5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000aa	8b 48 58	 mov	 ecx, DWORD PTR [rax+88]
  000ad	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  000b1	03 c1		 add	 eax, ecx
  000b3	89 44 24 58	 mov	 DWORD PTR offset$[rsp], eax
$LN9@gzseek64:
$LN10@gzseek64:

; 304  :     state->seek = 0;

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000bc	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 305  : 
; 306  :     /* if within raw area while reading, just go there */
; 307  :     if (state->mode == GZ_READ && state->how == COPY &&
; 308  :         state->pos + offset >= state->raw) {

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c8	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  000ce	0f 85 c1 00 00
	00		 jne	 $LN8@gzseek64
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d9	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  000dd	0f 85 b2 00 00
	00		 jne	 $LN8@gzseek64
  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e8	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000eb	03 4c 24 58	 add	 ecx, DWORD PTR offset$[rsp]
  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000f4	3b 48 44	 cmp	 ecx, DWORD PTR [rax+68]
  000f7	0f 8c 98 00 00
	00		 jl	 $LN8@gzseek64

; 309  :         ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);

  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00102	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00105	8b 54 24 58	 mov	 edx, DWORD PTR offset$[rsp]
  00109	2b d0		 sub	 edx, eax
  0010b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00111	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00116	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  0011f	89 44 24 24	 mov	 DWORD PTR ret$[rsp], eax

; 310  :         if (ret == -1)

  00123	83 7c 24 24 ff	 cmp	 DWORD PTR ret$[rsp], -1
  00128	75 0a		 jne	 SHORT $LN7@gzseek64

; 311  :             return -1;

  0012a	b8 ff ff ff ff	 mov	 eax, -1
  0012f	e9 86 01 00 00	 jmp	 $LN16@gzseek64
$LN7@gzseek64:

; 312  :         state->have = 0;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00139	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 313  :         state->eof = 0;

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00145	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 314  :         state->seek = 0;

  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00151	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 315  :         gz_error(state, Z_OK, NULL);

  00158	45 33 c0	 xor	 r8d, r8d
  0015b	33 d2		 xor	 edx, edx
  0015d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00162	e8 00 00 00 00	 call	 gz_error

; 316  :         state->strm.avail_in = 0;

  00167	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  0016c	41 c7 43 78 00
	00 00 00	 mov	 DWORD PTR [r11+120], 0

; 317  :         state->pos += offset;

  00174	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00179	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0017c	03 4c 24 58	 add	 ecx, DWORD PTR offset$[rsp]
  00180	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00185	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 318  :         return state->pos;

  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0018d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00190	e9 25 01 00 00	 jmp	 $LN16@gzseek64
$LN8@gzseek64:

; 319  :     }
; 320  : 
; 321  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 322  :     if (offset < 0) {

  00195	83 7c 24 58 00	 cmp	 DWORD PTR offset$[rsp], 0
  0019a	7d 53		 jge	 SHORT $LN6@gzseek64

; 323  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  0019c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001a1	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  001a7	74 0a		 je	 SHORT $LN5@gzseek64

; 324  :             return -1;

  001a9	b8 ff ff ff ff	 mov	 eax, -1
  001ae	e9 07 01 00 00	 jmp	 $LN16@gzseek64
$LN5@gzseek64:

; 325  :         offset += state->pos;

  001b3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001b8	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  001bb	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  001bf	03 c1		 add	 eax, ecx
  001c1	89 44 24 58	 mov	 DWORD PTR offset$[rsp], eax

; 326  :         if (offset < 0)                     /* before start of file! */

  001c5	83 7c 24 58 00	 cmp	 DWORD PTR offset$[rsp], 0
  001ca	7d 0a		 jge	 SHORT $LN4@gzseek64

; 327  :             return -1;

  001cc	b8 ff ff ff ff	 mov	 eax, -1
  001d1	e9 e4 00 00 00	 jmp	 $LN16@gzseek64
$LN4@gzseek64:

; 328  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  001d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  001db	e8 00 00 00 00	 call	 gzrewind
  001e0	83 f8 ff	 cmp	 eax, -1
  001e3	75 0a		 jne	 SHORT $LN3@gzseek64

; 329  :             return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	e9 cb 00 00 00	 jmp	 $LN16@gzseek64
$LN3@gzseek64:
$LN6@gzseek64:

; 330  :     }
; 331  : 
; 332  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 333  :     if (state->mode == GZ_READ) {

  001ef	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001f4	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  001fa	0f 85 8f 00 00
	00		 jne	 $LN2@gzseek64

; 334  :         n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?
; 335  :             (unsigned)offset : state->have;

  00200	33 c0		 xor	 eax, eax
  00202	83 f8 01	 cmp	 eax, 1
  00205	74 0e		 je	 SHORT $LN18@gzseek64
  00207	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0020c	81 78 38 ff ff
	ff 7f		 cmp	 DWORD PTR [rax+56], 2147483647 ; 7fffffffH
  00213	77 1c		 ja	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  00215	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0021a	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  0021e	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  00221	7f 0e		 jg	 SHORT $LN19@gzseek64
  00223	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00228	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0022b	89 44 24 30	 mov	 DWORD PTR tv152[rsp], eax
  0022f	eb 08		 jmp	 SHORT $LN20@gzseek64
$LN19@gzseek64:
  00231	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  00235	89 44 24 30	 mov	 DWORD PTR tv152[rsp], eax
$LN20@gzseek64:
  00239	8b 44 24 30	 mov	 eax, DWORD PTR tv152[rsp]
  0023d	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 336  :         state->have -= n;

  00241	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00246	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0024a	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  0024d	2b c8		 sub	 ecx, eax
  0024f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00254	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 337  :         state->next += n;

  00257	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  0025b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00260	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  00264	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00269	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 338  :         state->pos += n;

  0026d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00272	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00275	03 4c 24 20	 add	 ecx, DWORD PTR n$[rsp]
  00279	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0027e	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 339  :         offset -= n;

  00281	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00285	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  00289	2b c1		 sub	 eax, ecx
  0028b	89 44 24 58	 mov	 DWORD PTR offset$[rsp], eax
$LN2@gzseek64:

; 340  :     }
; 341  : 
; 342  :     /* request skip (if not zero) */
; 343  :     if (offset) {

  0028f	83 7c 24 58 00	 cmp	 DWORD PTR offset$[rsp], 0
  00294	74 18		 je	 SHORT $LN1@gzseek64

; 344  :         state->seek = 1;

  00296	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0029b	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [rax+92], 1

; 345  :         state->skip = offset;

  002a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  002a7	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  002ab	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN1@gzseek64:

; 346  :     }
; 347  :     return state->pos + offset;

  002ae	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  002b3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  002b6	03 44 24 58	 add	 eax, DWORD PTR offset$[rsp]
$LN16@gzseek64:

; 348  : }

  002ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002be	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
PUBLIC	gzdopen
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzdopen
_TEXT	SEGMENT
gz$ = 32
path$ = 40
fd$ = 64
mode$ = 72
gzdopen	PROC						; COMDAT

; 215  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 216  :     char *path;         /* identifier for error messages */
; 217  :     gzFile gz;
; 218  : 
; 219  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  0000d	83 7c 24 40 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00012	74 18		 je	 SHORT $LN1@gzdopen
  00014	b9 13 00 00 00	 mov	 ecx, 19
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001f	48 89 44 24 28	 mov	 QWORD PTR path$[rsp], rax
  00024	48 83 7c 24 28
	00		 cmp	 QWORD PTR path$[rsp], 0
  0002a	75 04		 jne	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 220  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 3f		 jmp	 SHORT $LN3@gzdopen
$LN2@gzdopen:

; 221  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  00030	44 8b 44 24 40	 mov	 r8d, DWORD PTR fd$[rsp]
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR path$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 222  :     gz = gz_open(path, fd, mode);

  00047	4c 8b 44 24 48	 mov	 r8, QWORD PTR mode$[rsp]
  0004c	8b 54 24 40	 mov	 edx, DWORD PTR fd$[rsp]
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR path$[rsp]
  00055	e8 00 00 00 00	 call	 gz_open
  0005a	48 89 44 24 20	 mov	 QWORD PTR gz$[rsp], rax

; 223  :     free(path);

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR path$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 224  :     return gz;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR gz$[rsp]
$LN3@gzdopen:

; 225  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
PUBLIC	gzopen
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzopen DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$gzopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzopen DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 48
mode$ = 56
gzopen	PROC						; COMDAT

; 199  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 200  :     return gz_open(path, -1, mode);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR mode$[rsp]
  00013	ba ff ff ff ff	 mov	 edx, -1
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001d	e8 00 00 00 00	 call	 gz_open

; 201  : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
gzopen	ENDP
PUBLIC	gzseek
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$gzseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzseek
_TEXT	SEGMENT
ret$ = 32
tv69 = 36
file$ = 64
offset$ = 72
whence$ = 80
gzseek	PROC						; COMDAT

; 355  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 356  :     z_off64_t ret;
; 357  : 
; 358  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00012	44 8b 44 24 50	 mov	 r8d, DWORD PTR whence$[rsp]
  00017	8b 54 24 48	 mov	 edx, DWORD PTR offset$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00020	e8 00 00 00 00	 call	 gzseek64
  00025	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 359  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00029	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  0002d	39 44 24 20	 cmp	 DWORD PTR ret$[rsp], eax
  00031	75 0a		 jne	 SHORT $LN3@gzseek
  00033	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00037	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  0003b	eb 08		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  0003d	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv69[rsp], -1
$LN4@gzseek:
  00045	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]

; 360  : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
gzseek	ENDP
END
