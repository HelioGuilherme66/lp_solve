; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp_memchr:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_close:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
PUBLIC	gzclose_r
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzread.c
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN8
	DD	imagerel $LN8+209
	DD	imagerel $unwind$gzclose_r
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzclose_r
_TEXT	SEGMENT
ret$ = 32
state$ = 40
tv84 = 48
file$ = 80
gzclose_r PROC						; COMDAT

; 629  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 630  :     int ret;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN3@gzclose_r

; 635  :         return Z_STREAM_ERROR;

  00011	b8 fe ff ff ff	 mov	 eax, -2
  00016	e9 b1 00 00 00	 jmp	 $LN4@gzclose_r
$LN3@gzclose_r:

; 636  :     state = (gz_statep)file;

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0002a	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00030	74 0a		 je	 SHORT $LN2@gzclose_r

; 640  :         return Z_STREAM_ERROR;

  00032	b8 fe ff ff ff	 mov	 eax, -2
  00037	e9 90 00 00 00	 jmp	 $LN4@gzclose_r
$LN2@gzclose_r:

; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00041	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00045	74 2c		 je	 SHORT $LN1@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0004c	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00050	e8 00 00 00 00	 call	 inflateEnd

; 645  :         free(state->out);

  00055	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0005a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 646  :         free(state->in);

  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00069	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@gzclose_r:

; 647  :     }
; 648  :     gz_error(state, Z_OK, NULL);

  00073	45 33 c0	 xor	 r8d, r8d
  00076	33 d2		 xor	 edx, edx
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0007d	e8 00 00 00 00	 call	 gz_error

; 649  :     free(state->path);

  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00087	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 650  :     ret = close(state->fd);

  00091	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  00096	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  000a0	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 651  :     free(state);

  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 652  :     return ret ? Z_ERRNO : Z_OK;

  000af	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000b4	74 0a		 je	 SHORT $LN6@gzclose_r
  000b6	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR tv84[rsp], -1
  000be	eb 08		 jmp	 SHORT $LN7@gzclose_r
$LN6@gzclose_r:
  000c0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN7@gzclose_r:
  000c8	8b 44 24 30	 mov	 eax, DWORD PTR tv84[rsp]
$LN4@gzclose_r:

; 653  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+195
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_load
_TEXT	SEGMENT
ret$ = 32
state$ = 64
buf$ = 72
len$ = 80
have$ = 88
gz_load	PROC						; COMDAT

; 26   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 27   :     int ret;
; 28   : 
; 29   :     *have = 0;

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN6@gz_load:

; 30   :     do {
; 31   :         ret = read(state->fd, buf + *have, len - *have);

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  0002f	44 2b c0	 sub	 r8d, eax
  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00037	8b 00		 mov	 eax, DWORD PTR [rax]
  00039	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  0003e	48 03 d0	 add	 rdx, rax
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0004f	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 32   :         if (ret <= 0)

  00053	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  00058	7f 02		 jg	 SHORT $LN3@gz_load

; 33   :             break;

  0005a	eb 1f		 jmp	 SHORT $LN4@gz_load
$LN3@gz_load:

; 34   :         *have += ret;

  0005c	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00061	8b 08		 mov	 ecx, DWORD PTR [rax]
  00063	03 4c 24 20	 add	 ecx, DWORD PTR ret$[rsp]
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  0006c	89 08		 mov	 DWORD PTR [rax], ecx

; 35   :     } while (*have < len);

  0006e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR have$[rsp]
  00073	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00077	39 01		 cmp	 DWORD PTR [rcx], eax
  00079	72 a8		 jb	 SHORT $LN6@gz_load
$LN4@gz_load:

; 36   :     if (ret < 0) {

  0007b	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  00080	7d 27		 jge	 SHORT $LN2@gz_load

; 37   :         gz_error(state, Z_ERRNO, zstrerror());

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00088	8b 08		 mov	 ecx, DWORD PTR [rax]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00090	4c 8b c0	 mov	 r8, rax
  00093	ba ff ff ff ff	 mov	 edx, -1
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0009d	e8 00 00 00 00	 call	 gz_error

; 38   :         return -1;

  000a2	b8 ff ff ff ff	 mov	 eax, -1
  000a7	eb 15		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 39   :     }
; 40   :     if (ret == 0)

  000a9	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000ae	75 0c		 jne	 SHORT $LN1@gz_load

; 41   :         state->eof = 1;

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000b5	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [rax+60], 1
$LN1@gz_load:

; 42   :     return 0;

  000bc	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 43   : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
gz_load	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+125
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_avail
_TEXT	SEGMENT
strm$ = 32
state$ = 64
gz_avail PROC						; COMDAT

; 52   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 53   :     z_streamp strm = &(state->strm);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00012	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 54   : 
; 55   :     if (state->err != Z_OK)

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0001c	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00020	74 07		 je	 SHORT $LN3@gz_avail

; 56   :         return -1;

  00022	b8 ff ff ff ff	 mov	 eax, -1
  00027	eb 4f		 jmp	 SHORT $LN4@gz_avail
$LN3@gz_avail:

; 57   :     if (state->eof == 0) {

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0002e	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00032	75 42		 jne	 SHORT $LN2@gz_avail

; 58   :         if (gz_load(state, state->in, state->size,
; 59   :                 (unsigned *)&(strm->avail_in)) == -1)

  00034	4c 8b 4c 24 20	 mov	 r9, QWORD PTR strm$[rsp]
  00039	49 83 c1 08	 add	 r9, 8
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00042	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR state$[rsp]
  0004b	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00054	e8 00 00 00 00	 call	 gz_load
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 07		 jne	 SHORT $LN1@gz_avail

; 60   :             return -1;

  0005e	b8 ff ff ff ff	 mov	 eax, -1
  00063	eb 13		 jmp	 SHORT $LN4@gz_avail
$LN1@gz_avail:

; 61   :         strm->next_in = state->in;

  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0006f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00073	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN2@gz_avail:

; 62   :     }
; 63   :     return 0;

  00076	33 c0		 xor	 eax, eax
$LN4@gz_avail:

; 64   : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
gz_avail ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_head DD imagerel gz_head
	DD	imagerel gz_head+3159
	DD	imagerel $unwind$gz_head
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_head DD 020c01H
	DD	017010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_head
_TEXT	SEGMENT
flags$ = 32
len$ = 36
strm$ = 40
tv192 = 48
tv191 = 52
tv212 = 56
tv211 = 60
tv233 = 64
tv232 = 68
tv249 = 72
tv248 = 76
tv265 = 80
tv264 = 84
tv281 = 88
tv280 = 92
tv297 = 96
tv296 = 100
tv313 = 104
tv312 = 108
tv331 = 112
tv330 = 116
tv347 = 120
tv346 = 124
tv367 = 128
tv366 = 132
tv386 = 136
tv385 = 140
tv405 = 144
tv404 = 148
tv424 = 152
tv423 = 156
tv440 = 160
tv439 = 164
state$ = 192
gz_head	PROC						; COMDAT

; 106  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 107  :     z_streamp strm = &(state->strm);

  0000c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00014	48 83 c0 70	 add	 rax, 112		; 00000070H
  00018	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 108  :     int flags;
; 109  :     unsigned len;
; 110  : 
; 111  :     /* allocate read buffers and inflate memory */
; 112  :     if (state->size == 0) {

  0001d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00025	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00029	0f 85 b3 01 00
	00		 jne	 $LN27@gz_head

; 113  :         /* allocate buffers */
; 114  :         state->in = malloc(state->want);

  0002f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00037	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00040	4c 8b d8	 mov	 r11, rax
  00043	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0004b	4c 89 58 20	 mov	 QWORD PTR [rax+32], r11

; 115  :         state->out = malloc(state->want << 1);

  0004f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00057	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0005a	d1 e0		 shl	 eax, 1
  0005c	8b c8		 mov	 ecx, eax
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00064	4c 8b d8	 mov	 r11, rax
  00067	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0006f	4c 89 58 28	 mov	 QWORD PTR [rax+40], r11

; 116  :         if (state->in == NULL || state->out == NULL) {

  00073	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0007b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00080	74 0f		 je	 SHORT $LN25@gz_head
  00082	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0008a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0008f	75 65		 jne	 SHORT $LN26@gz_head
$LN25@gz_head:

; 117  :             if (state->out != NULL)

  00091	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00099	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0009e	74 12		 je	 SHORT $LN24@gz_head

; 118  :                 free(state->out);

  000a0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000a8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@gz_head:

; 119  :             if (state->in != NULL)

  000b2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000ba	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000bf	74 12		 je	 SHORT $LN23@gz_head

; 120  :                 free(state->in);

  000c1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000c9	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@gz_head:

; 121  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000da	ba fc ff ff ff	 mov	 edx, -4
  000df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	e8 00 00 00 00	 call	 gz_error

; 122  :             return -1;

  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	e9 59 0b 00 00	 jmp	 $LN28@gz_head
$LN26@gz_head:

; 123  :         }
; 124  :         state->size = state->want;

  000f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000fe	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00106	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00109	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 125  : 
; 126  :         /* allocate inflate memory */
; 127  :         state->strm.zalloc = Z_NULL;

  0010c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00114	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 128  :         state->strm.zfree = Z_NULL;

  0011f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00127	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 129  :         state->strm.opaque = Z_NULL;

  00132	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0013a	48 c7 80 b0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+176], 0

; 130  :         state->strm.avail_in = 0;

  00145	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0014d	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 131  :         state->strm.next_in = Z_NULL;

  00154	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0015c	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 132  :         if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */

  00164	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0016c	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00170	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00176	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@
  0017d	ba f1 ff ff ff	 mov	 edx, -15
  00182	e8 00 00 00 00	 call	 inflateInit2_
  00187	85 c0		 test	 eax, eax
  00189	74 57		 je	 SHORT $LN22@gz_head

; 133  :             free(state->out);

  0018b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00193	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 134  :             free(state->in);

  0019d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  001a5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 135  :             state->size = 0;

  001af	4c 8b 9c 24 c0
	00 00 00	 mov	 r11, QWORD PTR state$[rsp]
  001b7	41 c7 43 14 00
	00 00 00	 mov	 DWORD PTR [r11+20], 0

; 136  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  001bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  001c6	ba fc ff ff ff	 mov	 edx, -4
  001cb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  001d3	e8 00 00 00 00	 call	 gz_error

; 137  :             return -1;

  001d8	b8 ff ff ff ff	 mov	 eax, -1
  001dd	e9 6d 0a 00 00	 jmp	 $LN28@gz_head
$LN22@gz_head:
$LN27@gz_head:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     /* get some data in the input buffer */
; 142  :     if (strm->avail_in == 0) {

  001e2	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  001e7	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001eb	75 2e		 jne	 SHORT $LN21@gz_head

; 143  :         if (gz_avail(state) == -1)

  001ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  001f5	e8 00 00 00 00	 call	 gz_avail
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 0a		 jne	 SHORT $LN20@gz_head

; 144  :             return -1;

  001ff	b8 ff ff ff ff	 mov	 eax, -1
  00204	e9 46 0a 00 00	 jmp	 $LN28@gz_head
$LN20@gz_head:

; 145  :         if (strm->avail_in == 0)

  00209	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0020e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00212	75 07		 jne	 SHORT $LN19@gz_head

; 146  :             return 0;

  00214	33 c0		 xor	 eax, eax
  00216	e9 34 0a 00 00	 jmp	 $LN28@gz_head
$LN19@gz_head:
$LN21@gz_head:

; 147  :     }
; 148  : 
; 149  :     /* look for the gzip magic header bytes 31 and 139 */
; 150  :     if (strm->next_in[0] == 31) {

  0021b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00226	83 f8 1f	 cmp	 eax, 31
  00229	0f 85 6f 09 00
	00		 jne	 $LN18@gz_head

; 151  :         strm->avail_in--;

  0022f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00234	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00237	83 e9 01	 sub	 ecx, 1
  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0023f	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 152  :         strm->next_in++;

  00242	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00247	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024a	48 83 c1 01	 add	 rcx, 1
  0024e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00253	48 89 08	 mov	 QWORD PTR [rax], rcx

; 153  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00256	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0025b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0025f	75 1c		 jne	 SHORT $LN17@gz_head
  00261	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00269	e8 00 00 00 00	 call	 gz_avail
  0026e	83 f8 ff	 cmp	 eax, -1
  00271	75 0a		 jne	 SHORT $LN17@gz_head

; 154  :             return -1;

  00273	b8 ff ff ff ff	 mov	 eax, -1
  00278	e9 d2 09 00 00	 jmp	 $LN28@gz_head
$LN17@gz_head:

; 155  :         if (strm->avail_in && strm->next_in[0] == 139) {

  0027d	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00282	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00286	0f 84 f4 08 00
	00		 je	 $LN16@gz_head
  0028c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00291	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00294	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00297	3d 8b 00 00 00	 cmp	 eax, 139		; 0000008bH
  0029c	0f 85 de 08 00
	00		 jne	 $LN16@gz_head

; 156  :             /* we have a gzip header, woo hoo! */
; 157  :             strm->avail_in--;

  002a2	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  002a7	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  002aa	83 e9 01	 sub	 ecx, 1
  002ad	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  002b2	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 158  :             strm->next_in++;

  002b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  002ba	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002bd	48 83 c1 01	 add	 rcx, 1
  002c1	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  002c6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 159  : 
; 160  :             /* skip rest of header */
; 161  :             if (NEXT() != 8) {      /* compression method */

  002c9	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  002ce	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002d2	75 1c		 jne	 SHORT $LN30@gz_head
  002d4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  002dc	e8 00 00 00 00	 call	 gz_avail
  002e1	83 f8 ff	 cmp	 eax, -1
  002e4	75 0a		 jne	 SHORT $LN30@gz_head
  002e6	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR tv192[rsp], -1
  002ee	eb 53		 jmp	 SHORT $LN33@gz_head
$LN30@gz_head:
  002f0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  002f5	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002f9	75 0a		 jne	 SHORT $LN31@gz_head
  002fb	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv191[rsp], -1
  00303	eb 36		 jmp	 SHORT $LN32@gz_head
$LN31@gz_head:
  00305	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0030a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0030d	83 e9 01	 sub	 ecx, 1
  00310	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00315	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00318	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0031d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00320	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00323	89 44 24 34	 mov	 DWORD PTR tv191[rsp], eax
  00327	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0032c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0032f	48 83 c1 01	 add	 rcx, 1
  00333	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00338	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN32@gz_head:
  0033b	8b 44 24 34	 mov	 eax, DWORD PTR tv191[rsp]
  0033f	89 44 24 30	 mov	 DWORD PTR tv192[rsp], eax
$LN33@gz_head:
  00343	83 7c 24 30 08	 cmp	 DWORD PTR tv192[rsp], 8
  00348	74 23		 je	 SHORT $LN15@gz_head

; 162  :                 gz_error(state, Z_DATA_ERROR, "unknown compression method");

  0034a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  00351	ba fd ff ff ff	 mov	 edx, -3
  00356	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0035e	e8 00 00 00 00	 call	 gz_error

; 163  :                 return -1;

  00363	b8 ff ff ff ff	 mov	 eax, -1
  00368	e9 e2 08 00 00	 jmp	 $LN28@gz_head
$LN15@gz_head:

; 164  :             }
; 165  :             flags = NEXT();

  0036d	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00372	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00376	75 1c		 jne	 SHORT $LN34@gz_head
  00378	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00380	e8 00 00 00 00	 call	 gz_avail
  00385	83 f8 ff	 cmp	 eax, -1
  00388	75 0a		 jne	 SHORT $LN34@gz_head
  0038a	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR tv212[rsp], -1
  00392	eb 53		 jmp	 SHORT $LN37@gz_head
$LN34@gz_head:
  00394	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00399	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0039d	75 0a		 jne	 SHORT $LN35@gz_head
  0039f	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR tv211[rsp], -1
  003a7	eb 36		 jmp	 SHORT $LN36@gz_head
$LN35@gz_head:
  003a9	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  003ae	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  003b1	83 e9 01	 sub	 ecx, 1
  003b4	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  003b9	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  003bc	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  003c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003c7	89 44 24 3c	 mov	 DWORD PTR tv211[rsp], eax
  003cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  003d0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003d3	48 83 c1 01	 add	 rcx, 1
  003d7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  003dc	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN36@gz_head:
  003df	8b 44 24 3c	 mov	 eax, DWORD PTR tv211[rsp]
  003e3	89 44 24 38	 mov	 DWORD PTR tv212[rsp], eax
$LN37@gz_head:
  003e7	8b 44 24 38	 mov	 eax, DWORD PTR tv212[rsp]
  003eb	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 166  :             if (flags & 0xe0) {     /* reserved flag bits */

  003ef	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  003f3	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  003f8	85 c0		 test	 eax, eax
  003fa	74 23		 je	 SHORT $LN14@gz_head

; 167  :                 gz_error(state, Z_DATA_ERROR, "unknown header flags set");

  003fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  00403	ba fd ff ff ff	 mov	 edx, -3
  00408	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00410	e8 00 00 00 00	 call	 gz_error

; 168  :                 return -1;

  00415	b8 ff ff ff ff	 mov	 eax, -1
  0041a	e9 30 08 00 00	 jmp	 $LN28@gz_head
$LN14@gz_head:

; 169  :             }
; 170  :             NEXT();                 /* modification time */

  0041f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00424	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00428	75 1c		 jne	 SHORT $LN38@gz_head
  0042a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00432	e8 00 00 00 00	 call	 gz_avail
  00437	83 f8 ff	 cmp	 eax, -1
  0043a	75 0a		 jne	 SHORT $LN38@gz_head
  0043c	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv233[rsp], -1
  00444	eb 53		 jmp	 SHORT $LN41@gz_head
$LN38@gz_head:
  00446	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0044b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0044f	75 0a		 jne	 SHORT $LN39@gz_head
  00451	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv232[rsp], -1
  00459	eb 36		 jmp	 SHORT $LN40@gz_head
$LN39@gz_head:
  0045b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00460	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00463	83 e9 01	 sub	 ecx, 1
  00466	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0046b	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  0046e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00473	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00476	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00479	89 44 24 44	 mov	 DWORD PTR tv232[rsp], eax
  0047d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00482	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00485	48 83 c1 01	 add	 rcx, 1
  00489	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0048e	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN40@gz_head:
  00491	8b 44 24 44	 mov	 eax, DWORD PTR tv232[rsp]
  00495	89 44 24 40	 mov	 DWORD PTR tv233[rsp], eax
$LN41@gz_head:

; 171  :             NEXT();

  00499	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0049e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  004a2	75 1c		 jne	 SHORT $LN42@gz_head
  004a4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  004ac	e8 00 00 00 00	 call	 gz_avail
  004b1	83 f8 ff	 cmp	 eax, -1
  004b4	75 0a		 jne	 SHORT $LN42@gz_head
  004b6	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR tv249[rsp], -1
  004be	eb 53		 jmp	 SHORT $LN45@gz_head
$LN42@gz_head:
  004c0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  004c5	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  004c9	75 0a		 jne	 SHORT $LN43@gz_head
  004cb	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR tv248[rsp], -1
  004d3	eb 36		 jmp	 SHORT $LN44@gz_head
$LN43@gz_head:
  004d5	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  004da	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  004dd	83 e9 01	 sub	 ecx, 1
  004e0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  004e5	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  004e8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  004ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004f3	89 44 24 4c	 mov	 DWORD PTR tv248[rsp], eax
  004f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  004fc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004ff	48 83 c1 01	 add	 rcx, 1
  00503	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00508	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN44@gz_head:
  0050b	8b 44 24 4c	 mov	 eax, DWORD PTR tv248[rsp]
  0050f	89 44 24 48	 mov	 DWORD PTR tv249[rsp], eax
$LN45@gz_head:

; 172  :             NEXT();

  00513	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00518	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0051c	75 1c		 jne	 SHORT $LN46@gz_head
  0051e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00526	e8 00 00 00 00	 call	 gz_avail
  0052b	83 f8 ff	 cmp	 eax, -1
  0052e	75 0a		 jne	 SHORT $LN46@gz_head
  00530	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR tv265[rsp], -1
  00538	eb 53		 jmp	 SHORT $LN49@gz_head
$LN46@gz_head:
  0053a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0053f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00543	75 0a		 jne	 SHORT $LN47@gz_head
  00545	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR tv264[rsp], -1
  0054d	eb 36		 jmp	 SHORT $LN48@gz_head
$LN47@gz_head:
  0054f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00554	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00557	83 e9 01	 sub	 ecx, 1
  0055a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0055f	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00562	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00567	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0056a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0056d	89 44 24 54	 mov	 DWORD PTR tv264[rsp], eax
  00571	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00576	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00579	48 83 c1 01	 add	 rcx, 1
  0057d	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00582	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN48@gz_head:
  00585	8b 44 24 54	 mov	 eax, DWORD PTR tv264[rsp]
  00589	89 44 24 50	 mov	 DWORD PTR tv265[rsp], eax
$LN49@gz_head:

; 173  :             NEXT();

  0058d	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00592	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00596	75 1c		 jne	 SHORT $LN50@gz_head
  00598	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  005a0	e8 00 00 00 00	 call	 gz_avail
  005a5	83 f8 ff	 cmp	 eax, -1
  005a8	75 0a		 jne	 SHORT $LN50@gz_head
  005aa	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR tv281[rsp], -1
  005b2	eb 53		 jmp	 SHORT $LN53@gz_head
$LN50@gz_head:
  005b4	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  005b9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  005bd	75 0a		 jne	 SHORT $LN51@gz_head
  005bf	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR tv280[rsp], -1
  005c7	eb 36		 jmp	 SHORT $LN52@gz_head
$LN51@gz_head:
  005c9	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  005ce	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  005d1	83 e9 01	 sub	 ecx, 1
  005d4	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  005d9	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  005dc	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  005e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005e7	89 44 24 5c	 mov	 DWORD PTR tv280[rsp], eax
  005eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  005f0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005f3	48 83 c1 01	 add	 rcx, 1
  005f7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  005fc	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN52@gz_head:
  005ff	8b 44 24 5c	 mov	 eax, DWORD PTR tv280[rsp]
  00603	89 44 24 58	 mov	 DWORD PTR tv281[rsp], eax
$LN53@gz_head:

; 174  :             NEXT();                 /* extra flags */

  00607	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0060c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00610	75 1c		 jne	 SHORT $LN54@gz_head
  00612	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0061a	e8 00 00 00 00	 call	 gz_avail
  0061f	83 f8 ff	 cmp	 eax, -1
  00622	75 0a		 jne	 SHORT $LN54@gz_head
  00624	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR tv297[rsp], -1
  0062c	eb 53		 jmp	 SHORT $LN57@gz_head
$LN54@gz_head:
  0062e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00633	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00637	75 0a		 jne	 SHORT $LN55@gz_head
  00639	c7 44 24 64 ff
	ff ff ff	 mov	 DWORD PTR tv296[rsp], -1
  00641	eb 36		 jmp	 SHORT $LN56@gz_head
$LN55@gz_head:
  00643	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00648	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0064b	83 e9 01	 sub	 ecx, 1
  0064e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00653	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00656	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0065b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0065e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00661	89 44 24 64	 mov	 DWORD PTR tv296[rsp], eax
  00665	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0066a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0066d	48 83 c1 01	 add	 rcx, 1
  00671	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00676	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN56@gz_head:
  00679	8b 44 24 64	 mov	 eax, DWORD PTR tv296[rsp]
  0067d	89 44 24 60	 mov	 DWORD PTR tv297[rsp], eax
$LN57@gz_head:

; 175  :             NEXT();                 /* operating system */

  00681	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00686	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0068a	75 1c		 jne	 SHORT $LN58@gz_head
  0068c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00694	e8 00 00 00 00	 call	 gz_avail
  00699	83 f8 ff	 cmp	 eax, -1
  0069c	75 0a		 jne	 SHORT $LN58@gz_head
  0069e	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR tv313[rsp], -1
  006a6	eb 53		 jmp	 SHORT $LN61@gz_head
$LN58@gz_head:
  006a8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  006ad	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  006b1	75 0a		 jne	 SHORT $LN59@gz_head
  006b3	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR tv312[rsp], -1
  006bb	eb 36		 jmp	 SHORT $LN60@gz_head
$LN59@gz_head:
  006bd	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  006c2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  006c5	83 e9 01	 sub	 ecx, 1
  006c8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  006cd	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  006d0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  006d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006db	89 44 24 6c	 mov	 DWORD PTR tv312[rsp], eax
  006df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  006e4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006e7	48 83 c1 01	 add	 rcx, 1
  006eb	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  006f0	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN60@gz_head:
  006f3	8b 44 24 6c	 mov	 eax, DWORD PTR tv312[rsp]
  006f7	89 44 24 68	 mov	 DWORD PTR tv313[rsp], eax
$LN61@gz_head:

; 176  :             if (flags & 4) {        /* extra field */

  006fb	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  006ff	83 e0 04	 and	 eax, 4
  00702	85 c0		 test	 eax, eax
  00704	0f 84 be 01 00
	00		 je	 $LN13@gz_head

; 177  :                 len = (unsigned)NEXT();

  0070a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0070f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00713	75 1c		 jne	 SHORT $LN62@gz_head
  00715	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0071d	e8 00 00 00 00	 call	 gz_avail
  00722	83 f8 ff	 cmp	 eax, -1
  00725	75 0a		 jne	 SHORT $LN62@gz_head
  00727	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR tv331[rsp], -1
  0072f	eb 53		 jmp	 SHORT $LN65@gz_head
$LN62@gz_head:
  00731	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00736	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0073a	75 0a		 jne	 SHORT $LN63@gz_head
  0073c	c7 44 24 74 ff
	ff ff ff	 mov	 DWORD PTR tv330[rsp], -1
  00744	eb 36		 jmp	 SHORT $LN64@gz_head
$LN63@gz_head:
  00746	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0074b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0074e	83 e9 01	 sub	 ecx, 1
  00751	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00756	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00759	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0075e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00761	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00764	89 44 24 74	 mov	 DWORD PTR tv330[rsp], eax
  00768	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0076d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00770	48 83 c1 01	 add	 rcx, 1
  00774	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00779	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN64@gz_head:
  0077c	8b 44 24 74	 mov	 eax, DWORD PTR tv330[rsp]
  00780	89 44 24 70	 mov	 DWORD PTR tv331[rsp], eax
$LN65@gz_head:
  00784	8b 44 24 70	 mov	 eax, DWORD PTR tv331[rsp]
  00788	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 178  :                 len += (unsigned)NEXT() << 8;

  0078c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00791	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00795	75 1c		 jne	 SHORT $LN66@gz_head
  00797	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0079f	e8 00 00 00 00	 call	 gz_avail
  007a4	83 f8 ff	 cmp	 eax, -1
  007a7	75 0a		 jne	 SHORT $LN66@gz_head
  007a9	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR tv347[rsp], -1
  007b1	eb 53		 jmp	 SHORT $LN69@gz_head
$LN66@gz_head:
  007b3	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  007b8	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  007bc	75 0a		 jne	 SHORT $LN67@gz_head
  007be	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR tv346[rsp], -1
  007c6	eb 36		 jmp	 SHORT $LN68@gz_head
$LN67@gz_head:
  007c8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  007cd	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  007d0	83 e9 01	 sub	 ecx, 1
  007d3	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  007d8	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  007db	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  007e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007e3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007e6	89 44 24 7c	 mov	 DWORD PTR tv346[rsp], eax
  007ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  007ef	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007f2	48 83 c1 01	 add	 rcx, 1
  007f6	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  007fb	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN68@gz_head:
  007fe	8b 44 24 7c	 mov	 eax, DWORD PTR tv346[rsp]
  00802	89 44 24 78	 mov	 DWORD PTR tv347[rsp], eax
$LN69@gz_head:
  00806	8b 4c 24 78	 mov	 ecx, DWORD PTR tv347[rsp]
  0080a	c1 e1 08	 shl	 ecx, 8
  0080d	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00811	03 c1		 add	 eax, ecx
  00813	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
$LN12@gz_head:

; 179  :                 while (len--)

  00817	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  0081b	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  0081f	83 e8 01	 sub	 eax, 1
  00822	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
  00826	85 c9		 test	 ecx, ecx
  00828	0f 84 9a 00 00
	00		 je	 $LN11@gz_head

; 180  :                     if (NEXT() < 0)

  0082e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00833	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00837	75 1f		 jne	 SHORT $LN70@gz_head
  00839	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00841	e8 00 00 00 00	 call	 gz_avail
  00846	83 f8 ff	 cmp	 eax, -1
  00849	75 0d		 jne	 SHORT $LN70@gz_head
  0084b	c7 84 24 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv367[rsp], -1
  00856	eb 5f		 jmp	 SHORT $LN73@gz_head
$LN70@gz_head:
  00858	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0085d	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00861	75 0d		 jne	 SHORT $LN71@gz_head
  00863	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv366[rsp], -1
  0086e	eb 39		 jmp	 SHORT $LN72@gz_head
$LN71@gz_head:
  00870	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00875	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00878	83 e9 01	 sub	 ecx, 1
  0087b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00880	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00883	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00888	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0088b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0088e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv366[rsp], eax
  00895	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0089a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0089d	48 83 c1 01	 add	 rcx, 1
  008a1	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  008a6	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN72@gz_head:
  008a9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv366[rsp]
  008b0	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
$LN73@gz_head:
  008b7	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv367[rsp], 0
  008bf	7d 02		 jge	 SHORT $LN10@gz_head

; 181  :                         break;

  008c1	eb 05		 jmp	 SHORT $LN11@gz_head
$LN10@gz_head:

; 182  :             }

  008c3	e9 4f ff ff ff	 jmp	 $LN12@gz_head
$LN11@gz_head:
$LN13@gz_head:

; 183  :             if (flags & 8)          /* file name */

  008c8	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  008cc	83 e0 08	 and	 eax, 8
  008cf	85 c0		 test	 eax, eax
  008d1	0f 84 98 00 00
	00		 je	 $LN9@gz_head
$LN8@gz_head:

; 184  :                 while (NEXT() > 0)

  008d7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  008dc	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  008e0	75 1f		 jne	 SHORT $LN74@gz_head
  008e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  008ea	e8 00 00 00 00	 call	 gz_avail
  008ef	83 f8 ff	 cmp	 eax, -1
  008f2	75 0d		 jne	 SHORT $LN74@gz_head
  008f4	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv386[rsp], -1
  008ff	eb 5f		 jmp	 SHORT $LN77@gz_head
$LN74@gz_head:
  00901	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00906	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0090a	75 0d		 jne	 SHORT $LN75@gz_head
  0090c	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv385[rsp], -1
  00917	eb 39		 jmp	 SHORT $LN76@gz_head
$LN75@gz_head:
  00919	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0091e	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00921	83 e9 01	 sub	 ecx, 1
  00924	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00929	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  0092c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00931	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00934	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00937	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv385[rsp], eax
  0093e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00943	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00946	48 83 c1 01	 add	 rcx, 1
  0094a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0094f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN76@gz_head:
  00952	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv385[rsp]
  00959	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv386[rsp], eax
$LN77@gz_head:
  00960	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv386[rsp], 0
  00968	7e 05		 jle	 SHORT $LN7@gz_head

; 185  :                     ;

  0096a	e9 68 ff ff ff	 jmp	 $LN8@gz_head
$LN7@gz_head:
$LN9@gz_head:

; 186  :             if (flags & 16)         /* comment */

  0096f	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00973	83 e0 10	 and	 eax, 16
  00976	85 c0		 test	 eax, eax
  00978	0f 84 98 00 00
	00		 je	 $LN6@gz_head
$LN5@gz_head:

; 187  :                 while (NEXT() > 0)

  0097e	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00983	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00987	75 1f		 jne	 SHORT $LN78@gz_head
  00989	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00991	e8 00 00 00 00	 call	 gz_avail
  00996	83 f8 ff	 cmp	 eax, -1
  00999	75 0d		 jne	 SHORT $LN78@gz_head
  0099b	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv405[rsp], -1
  009a6	eb 5f		 jmp	 SHORT $LN81@gz_head
$LN78@gz_head:
  009a8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  009ad	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  009b1	75 0d		 jne	 SHORT $LN79@gz_head
  009b3	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv404[rsp], -1
  009be	eb 39		 jmp	 SHORT $LN80@gz_head
$LN79@gz_head:
  009c0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  009c5	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  009c8	83 e9 01	 sub	 ecx, 1
  009cb	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  009d0	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  009d3	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  009d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009de	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv404[rsp], eax
  009e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  009ea	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  009ed	48 83 c1 01	 add	 rcx, 1
  009f1	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  009f6	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN80@gz_head:
  009f9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv404[rsp]
  00a00	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
$LN81@gz_head:
  00a07	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv405[rsp], 0
  00a0f	7e 05		 jle	 SHORT $LN4@gz_head

; 188  :                     ;

  00a11	e9 68 ff ff ff	 jmp	 $LN5@gz_head
$LN4@gz_head:
$LN6@gz_head:

; 189  :             if (flags & 2) {        /* header crc */

  00a16	8b 44 24 20	 mov	 eax, DWORD PTR flags$[rsp]
  00a1a	83 e0 02	 and	 eax, 2
  00a1d	85 c0		 test	 eax, eax
  00a1f	0f 84 12 01 00
	00		 je	 $LN3@gz_head

; 190  :                 NEXT();

  00a25	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a2a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00a2e	75 1f		 jne	 SHORT $LN82@gz_head
  00a30	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00a38	e8 00 00 00 00	 call	 gz_avail
  00a3d	83 f8 ff	 cmp	 eax, -1
  00a40	75 0d		 jne	 SHORT $LN82@gz_head
  00a42	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv424[rsp], -1
  00a4d	eb 5f		 jmp	 SHORT $LN85@gz_head
$LN82@gz_head:
  00a4f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a54	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00a58	75 0d		 jne	 SHORT $LN83@gz_head
  00a5a	c7 84 24 9c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv423[rsp], -1
  00a65	eb 39		 jmp	 SHORT $LN84@gz_head
$LN83@gz_head:
  00a67	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a6c	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00a6f	83 e9 01	 sub	 ecx, 1
  00a72	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a77	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00a7a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a7f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a82	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a85	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv423[rsp], eax
  00a8c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00a91	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a94	48 83 c1 01	 add	 rcx, 1
  00a98	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00a9d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN84@gz_head:
  00aa0	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv423[rsp]
  00aa7	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv424[rsp], eax
$LN85@gz_head:

; 191  :                 NEXT();

  00aae	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00ab3	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ab7	75 1f		 jne	 SHORT $LN86@gz_head
  00ab9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00ac1	e8 00 00 00 00	 call	 gz_avail
  00ac6	83 f8 ff	 cmp	 eax, -1
  00ac9	75 0d		 jne	 SHORT $LN86@gz_head
  00acb	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv440[rsp], -1
  00ad6	eb 5f		 jmp	 SHORT $LN89@gz_head
$LN86@gz_head:
  00ad8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00add	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ae1	75 0d		 jne	 SHORT $LN87@gz_head
  00ae3	c7 84 24 a4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv439[rsp], -1
  00aee	eb 39		 jmp	 SHORT $LN88@gz_head
$LN87@gz_head:
  00af0	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00af5	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00af8	83 e9 01	 sub	 ecx, 1
  00afb	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00b00	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00b03	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00b08	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b0b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b0e	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv439[rsp], eax
  00b15	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00b1a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b1d	48 83 c1 01	 add	 rcx, 1
  00b21	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00b26	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN88@gz_head:
  00b29	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv439[rsp]
  00b30	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv440[rsp], eax
$LN89@gz_head:
$LN3@gz_head:

; 192  :             }
; 193  :             /* an unexpected end of file is not checked for here -- it will be
; 194  :                noticed on the first request for uncompressed data */
; 195  : 
; 196  :             /* set up for decompression */
; 197  :             inflateReset(strm);

  00b37	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00b3c	e8 00 00 00 00	 call	 inflateReset

; 198  :             strm->adler = crc32(0L, Z_NULL, 0);

  00b41	45 33 c0	 xor	 r8d, r8d
  00b44	33 d2		 xor	 edx, edx
  00b46	33 c9		 xor	 ecx, ecx
  00b48	e8 00 00 00 00	 call	 crc32
  00b4d	44 8b d8	 mov	 r11d, eax
  00b50	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00b55	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 199  :             state->how = GZIP;

  00b59	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b61	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 200  :             state->direct = 0;

  00b68	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b70	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [rax+76], 0

; 201  :             return 0;

  00b77	33 c0		 xor	 eax, eax
  00b79	e9 d1 00 00 00	 jmp	 $LN28@gz_head

; 202  :         }
; 203  :         else {

  00b7e	eb 1e		 jmp	 SHORT $LN2@gz_head
$LN16@gz_head:

; 204  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 205  :             state->out[0] = 31;

  00b80	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b88	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00b8c	c6 00 1f	 mov	 BYTE PTR [rax], 31

; 206  :             state->have = 1;

  00b8f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b97	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [rax+56], 1
$LN2@gz_head:
$LN18@gz_head:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 211  :        input to output -- this assumes that the output buffer is larger than
; 212  :        the input buffer, which also assures space for gzungetc() */
; 213  :     state->raw = state->pos;

  00b9e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00ba6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bae	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00bb1	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 214  :     state->next = state->out;

  00bb4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00bbc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bc4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00bc8	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 215  :     if (strm->avail_in) {

  00bcc	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00bd1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00bd5	74 58		 je	 SHORT $LN1@gz_head

; 216  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

  00bd7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00bdc	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  00be0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00be8	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00beb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bf3	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  00bf7	48 8b 54 24 28	 mov	 rdx, QWORD PTR strm$[rsp]
  00bfc	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00bff	e8 00 00 00 00	 call	 memcpy

; 217  :         state->have += strm->avail_in;

  00c04	4c 8b 9c 24 c0
	00 00 00	 mov	 r11, QWORD PTR state$[rsp]
  00c0c	41 8b 4b 38	 mov	 ecx, DWORD PTR [r11+56]
  00c10	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00c15	03 48 08	 add	 ecx, DWORD PTR [rax+8]
  00c18	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c20	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 218  :         strm->avail_in = 0;

  00c23	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00c28	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN1@gz_head:

; 219  :     }
; 220  :     state->how = COPY;

  00c2f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c37	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 221  :     state->direct = 1;

  00c3e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c46	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1

; 222  :     return 0;

  00c4d	33 c0		 xor	 eax, eax
$LN28@gz_head:

; 223  : }

  00c4f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00c56	c3		 ret	 0
gz_head	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_next4 DD imagerel gz_next4
	DD	imagerel gz_next4+603
	DD	imagerel $unwind$gz_next4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_next4 DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_next4
_TEXT	SEGMENT
strm$ = 32
val$ = 40
ch$ = 44
tv80 = 48
tv79 = 52
tv128 = 56
tv95 = 60
tv146 = 64
tv145 = 68
tv164 = 72
tv163 = 76
state$ = 96
ret$ = 104
gz_next4 PROC						; COMDAT

; 76   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 77   :     int ch;
; 78   :     unsigned long val;
; 79   :     z_streamp strm = &(state->strm);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00013	48 83 c0 70	 add	 rax, 112		; 00000070H
  00017	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 80   : 
; 81   :     val = NEXT();

  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00021	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00025	75 19		 jne	 SHORT $LN4@gz_next4
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0002c	e8 00 00 00 00	 call	 gz_avail
  00031	83 f8 ff	 cmp	 eax, -1
  00034	75 0a		 jne	 SHORT $LN4@gz_next4
  00036	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR tv80[rsp], -1
  0003e	eb 53		 jmp	 SHORT $LN7@gz_next4
$LN4@gz_next4:
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00045	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00049	75 0a		 jne	 SHORT $LN5@gz_next4
  0004b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv79[rsp], -1
  00053	eb 36		 jmp	 SHORT $LN6@gz_next4
$LN5@gz_next4:
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0005d	83 e9 01	 sub	 ecx, 1
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00065	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	89 44 24 34	 mov	 DWORD PTR tv79[rsp], eax
  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  0007c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007f	48 83 c1 01	 add	 rcx, 1
  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@gz_next4:
  0008b	8b 44 24 34	 mov	 eax, DWORD PTR tv79[rsp]
  0008f	89 44 24 30	 mov	 DWORD PTR tv80[rsp], eax
$LN7@gz_next4:
  00093	8b 44 24 30	 mov	 eax, DWORD PTR tv80[rsp]
  00097	89 44 24 28	 mov	 DWORD PTR val$[rsp], eax

; 82   :     val += (unsigned)NEXT() << 8;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000a0	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000a4	75 19		 jne	 SHORT $LN8@gz_next4
  000a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000ab	e8 00 00 00 00	 call	 gz_avail
  000b0	83 f8 ff	 cmp	 eax, -1
  000b3	75 0a		 jne	 SHORT $LN8@gz_next4
  000b5	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR tv128[rsp], -1
  000bd	eb 53		 jmp	 SHORT $LN11@gz_next4
$LN8@gz_next4:
  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000c4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000c8	75 0a		 jne	 SHORT $LN9@gz_next4
  000ca	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR tv95[rsp], -1
  000d2	eb 36		 jmp	 SHORT $LN10@gz_next4
$LN9@gz_next4:
  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000d9	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000dc	83 e9 01	 sub	 ecx, 1
  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000e4	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f2	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000fb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fe	48 83 c1 01	 add	 rcx, 1
  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00107	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@gz_next4:
  0010a	8b 44 24 3c	 mov	 eax, DWORD PTR tv95[rsp]
  0010e	89 44 24 38	 mov	 DWORD PTR tv128[rsp], eax
$LN11@gz_next4:
  00112	8b 4c 24 38	 mov	 ecx, DWORD PTR tv128[rsp]
  00116	c1 e1 08	 shl	 ecx, 8
  00119	8b 44 24 28	 mov	 eax, DWORD PTR val$[rsp]
  0011d	03 c1		 add	 eax, ecx
  0011f	89 44 24 28	 mov	 DWORD PTR val$[rsp], eax

; 83   :     val += (unsigned long)NEXT() << 16;

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00128	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0012c	75 19		 jne	 SHORT $LN12@gz_next4
  0012e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00133	e8 00 00 00 00	 call	 gz_avail
  00138	83 f8 ff	 cmp	 eax, -1
  0013b	75 0a		 jne	 SHORT $LN12@gz_next4
  0013d	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv146[rsp], -1
  00145	eb 53		 jmp	 SHORT $LN15@gz_next4
$LN12@gz_next4:
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0014c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00150	75 0a		 jne	 SHORT $LN13@gz_next4
  00152	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv145[rsp], -1
  0015a	eb 36		 jmp	 SHORT $LN14@gz_next4
$LN13@gz_next4:
  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00161	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00164	83 e9 01	 sub	 ecx, 1
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0016c	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  0016f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017a	89 44 24 44	 mov	 DWORD PTR tv145[rsp], eax
  0017e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  00183	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00186	48 83 c1 01	 add	 rcx, 1
  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0018f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN14@gz_next4:
  00192	8b 44 24 44	 mov	 eax, DWORD PTR tv145[rsp]
  00196	89 44 24 40	 mov	 DWORD PTR tv146[rsp], eax
$LN15@gz_next4:
  0019a	8b 4c 24 40	 mov	 ecx, DWORD PTR tv146[rsp]
  0019e	c1 e1 10	 shl	 ecx, 16
  001a1	8b 44 24 28	 mov	 eax, DWORD PTR val$[rsp]
  001a5	03 c1		 add	 eax, ecx
  001a7	89 44 24 28	 mov	 DWORD PTR val$[rsp], eax

; 84   :     ch = NEXT();

  001ab	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001b0	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001b4	75 19		 jne	 SHORT $LN16@gz_next4
  001b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001bb	e8 00 00 00 00	 call	 gz_avail
  001c0	83 f8 ff	 cmp	 eax, -1
  001c3	75 0a		 jne	 SHORT $LN16@gz_next4
  001c5	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR tv164[rsp], -1
  001cd	eb 53		 jmp	 SHORT $LN19@gz_next4
$LN16@gz_next4:
  001cf	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001d4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001d8	75 0a		 jne	 SHORT $LN17@gz_next4
  001da	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR tv163[rsp], -1
  001e2	eb 36		 jmp	 SHORT $LN18@gz_next4
$LN17@gz_next4:
  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001e9	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001ec	83 e9 01	 sub	 ecx, 1
  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001f4	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  001f7	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00202	89 44 24 4c	 mov	 DWORD PTR tv163[rsp], eax
  00206	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  0020b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020e	48 83 c1 01	 add	 rcx, 1
  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00217	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN18@gz_next4:
  0021a	8b 44 24 4c	 mov	 eax, DWORD PTR tv163[rsp]
  0021e	89 44 24 48	 mov	 DWORD PTR tv164[rsp], eax
$LN19@gz_next4:
  00222	8b 44 24 48	 mov	 eax, DWORD PTR tv164[rsp]
  00226	89 44 24 2c	 mov	 DWORD PTR ch$[rsp], eax

; 85   :     if (ch == -1)

  0022a	83 7c 24 2c ff	 cmp	 DWORD PTR ch$[rsp], -1
  0022f	75 07		 jne	 SHORT $LN1@gz_next4

; 86   :         return -1;

  00231	b8 ff ff ff ff	 mov	 eax, -1
  00236	eb 1e		 jmp	 SHORT $LN2@gz_next4
$LN1@gz_next4:

; 87   :     val += (unsigned long)ch << 24;

  00238	8b 4c 24 2c	 mov	 ecx, DWORD PTR ch$[rsp]
  0023c	c1 e1 18	 shl	 ecx, 24
  0023f	8b 44 24 28	 mov	 eax, DWORD PTR val$[rsp]
  00243	03 c1		 add	 eax, ecx
  00245	89 44 24 28	 mov	 DWORD PTR val$[rsp], eax

; 88   :     *ret = val;

  00249	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ret$[rsp]
  0024e	8b 44 24 28	 mov	 eax, DWORD PTR val$[rsp]
  00252	89 01		 mov	 DWORD PTR [rcx], eax

; 89   :     return 0;

  00254	33 c0		 xor	 eax, eax
$LN2@gz_next4:

; 90   : }

  00256	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0025a	c3		 ret	 0
gz_next4 ENDP
PUBLIC	gzdirect
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN6
	DD	imagerel $LN6+93
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzdirect
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzdirect PROC						; COMDAT

; 605  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 606  :     gz_statep state;
; 607  : 
; 608  :     /* get internal structure */
; 609  :     if (file == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 04		 jne	 SHORT $LN3@gzdirect

; 610  :         return 0;

  00011	33 c0		 xor	 eax, eax
  00013	eb 43		 jmp	 SHORT $LN4@gzdirect
$LN3@gzdirect:

; 611  :     state = (gz_statep)file;

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0001a	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 612  : 
; 613  :     /* check that we're reading */
; 614  :     if (state->mode != GZ_READ)

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00024	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  0002a	74 04		 je	 SHORT $LN2@gzdirect

; 615  :         return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 28		 jmp	 SHORT $LN4@gzdirect
$LN2@gzdirect:

; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->how == LOOK && state->have == 0)

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00039	75 15		 jne	 SHORT $LN1@gzdirect
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00040	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00044	75 0a		 jne	 SHORT $LN1@gzdirect

; 620  :         (void)gz_head(state);

  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0004b	e8 00 00 00 00	 call	 gz_head
$LN1@gzdirect:

; 621  : 
; 622  :     /* return 1 if reading direct, 0 if decompressing a gzip stream */
; 623  :     return state->direct;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00055	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
$LN4@gzdirect:

; 624  : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+593
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_decomp
_TEXT	SEGMENT
crc$ = 32
strm$ = 40
len$ = 48
had$ = 52
ret$ = 56
tv92 = 64
state$ = 96
gz_decomp PROC						; COMDAT

; 235  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 236  :     int ret;
; 237  :     unsigned had;
; 238  :     unsigned long crc, len;
; 239  :     z_streamp strm = &(state->strm);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00012	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 240  : 
; 241  :     /* fill output buffer up to end of deflate stream */
; 242  :     had = strm->avail_out;

  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0001c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001f	89 44 24 34	 mov	 DWORD PTR had$[rsp], eax
$LN15@gz_decomp:

; 243  :     do {
; 244  :         /* get more input for inflate() */
; 245  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00023	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00028	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0002c	75 19		 jne	 SHORT $LN12@gz_decomp
  0002e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00033	e8 00 00 00 00	 call	 gz_avail
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	75 0a		 jne	 SHORT $LN12@gz_decomp

; 246  :             return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	e9 05 02 00 00	 jmp	 $LN16@gz_decomp
$LN12@gz_decomp:

; 247  :         if (strm->avail_in == 0) {

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0004c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00050	75 20		 jne	 SHORT $LN11@gz_decomp

; 248  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  00059	ba fd ff ff ff	 mov	 edx, -3
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00063	e8 00 00 00 00	 call	 gz_error

; 249  :             return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	e9 da 01 00 00	 jmp	 $LN16@gz_decomp
$LN11@gz_decomp:

; 250  :         }
; 251  : 
; 252  :         /* decompress and handle errors */
; 253  :         ret = inflate(strm, Z_NO_FLUSH);

  00072	33 d2		 xor	 edx, edx
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00079	e8 00 00 00 00	 call	 inflate
  0007e	89 44 24 38	 mov	 DWORD PTR ret$[rsp], eax

; 254  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00082	83 7c 24 38 fe	 cmp	 DWORD PTR ret$[rsp], -2
  00087	74 07		 je	 SHORT $LN9@gz_decomp
  00089	83 7c 24 38 02	 cmp	 DWORD PTR ret$[rsp], 2
  0008e	75 20		 jne	 SHORT $LN10@gz_decomp
$LN9@gz_decomp:

; 255  :             gz_error(state, Z_STREAM_ERROR,
; 256  :                       "internal error: inflate stream corrupt");

  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  00097	ba fe ff ff ff	 mov	 edx, -2
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000a1	e8 00 00 00 00	 call	 gz_error

; 257  :             return -1;

  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	e9 9c 01 00 00	 jmp	 $LN16@gz_decomp
$LN10@gz_decomp:

; 258  :         }
; 259  :         if (ret == Z_MEM_ERROR) {

  000b0	83 7c 24 38 fc	 cmp	 DWORD PTR ret$[rsp], -4
  000b5	75 20		 jne	 SHORT $LN8@gz_decomp

; 260  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000be	ba fc ff ff ff	 mov	 edx, -4
  000c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000c8	e8 00 00 00 00	 call	 gz_error

; 261  :             return -1;

  000cd	b8 ff ff ff ff	 mov	 eax, -1
  000d2	e9 75 01 00 00	 jmp	 $LN16@gz_decomp
$LN8@gz_decomp:

; 262  :         }
; 263  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  000d7	83 7c 24 38 fd	 cmp	 DWORD PTR ret$[rsp], -3
  000dc	75 46		 jne	 SHORT $LN7@gz_decomp

; 264  :             gz_error(state, Z_DATA_ERROR,
; 265  :                       strm->msg == NULL ? "compressed data error" : strm->msg);

  000de	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000e3	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000e8	75 0e		 jne	 SHORT $LN18@gz_decomp
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000f1	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
  000f6	eb 0e		 jmp	 SHORT $LN19@gz_decomp
$LN18@gz_decomp:
  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000fd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00101	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
$LN19@gz_decomp:
  00106	4c 8b 44 24 40	 mov	 r8, QWORD PTR tv92[rsp]
  0010b	ba fd ff ff ff	 mov	 edx, -3
  00110	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00115	e8 00 00 00 00	 call	 gz_error

; 266  :             return -1;

  0011a	b8 ff ff ff ff	 mov	 eax, -1
  0011f	e9 28 01 00 00	 jmp	 $LN16@gz_decomp
$LN7@gz_decomp:

; 267  :         }
; 268  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00124	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00129	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0012d	74 0b		 je	 SHORT $LN6@gz_decomp
  0012f	83 7c 24 38 01	 cmp	 DWORD PTR ret$[rsp], 1
  00134	0f 85 e9 fe ff
	ff		 jne	 $LN15@gz_decomp
$LN6@gz_decomp:

; 269  : 
; 270  :     /* update available output and crc check value */
; 271  :     state->have = had - strm->avail_out;

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0013f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00142	8b 4c 24 34	 mov	 ecx, DWORD PTR had$[rsp]
  00146	2b c8		 sub	 ecx, eax
  00148	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0014d	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 272  :     state->next = strm->next_out - state->have;

  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00155	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0015d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00161	48 2b c8	 sub	 rcx, rax
  00164	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00169	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 273  :     strm->adler = crc32(strm->adler, state->next, state->have);

  0016d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00172	44 8b 40 38	 mov	 r8d, DWORD PTR [rax+56]
  00176	48 8b 54 24 60	 mov	 rdx, QWORD PTR state$[rsp]
  0017b	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0017f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00184	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00187	e8 00 00 00 00	 call	 crc32
  0018c	44 8b d8	 mov	 r11d, eax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00194	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 274  : 
; 275  :     /* check gzip trailer if at end of deflate stream */
; 276  :     if (ret == Z_STREAM_END) {

  00198	83 7c 24 38 01	 cmp	 DWORD PTR ret$[rsp], 1
  0019d	0f 85 a7 00 00
	00		 jne	 $LN5@gz_decomp

; 277  :         if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

  001a3	48 8d 54 24 20	 lea	 rdx, QWORD PTR crc$[rsp]
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001ad	e8 00 00 00 00	 call	 gz_next4
  001b2	83 f8 ff	 cmp	 eax, -1
  001b5	74 14		 je	 SHORT $LN3@gz_decomp
  001b7	48 8d 54 24 30	 lea	 rdx, QWORD PTR len$[rsp]
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001c1	e8 00 00 00 00	 call	 gz_next4
  001c6	83 f8 ff	 cmp	 eax, -1
  001c9	75 1d		 jne	 SHORT $LN4@gz_decomp
$LN3@gz_decomp:

; 278  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  001cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  001d2	ba fd ff ff ff	 mov	 edx, -3
  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001dc	e8 00 00 00 00	 call	 gz_error

; 279  :             return -1;

  001e1	b8 ff ff ff ff	 mov	 eax, -1
  001e6	eb 64		 jmp	 SHORT $LN16@gz_decomp
$LN4@gz_decomp:

; 280  :         }
; 281  :         if (crc != strm->adler) {

  001e8	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  001ed	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  001f0	39 44 24 20	 cmp	 DWORD PTR crc$[rsp], eax
  001f4	74 1d		 je	 SHORT $LN2@gz_decomp

; 282  :             gz_error(state, Z_DATA_ERROR, "incorrect data check");

  001f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  001fd	ba fd ff ff ff	 mov	 edx, -3
  00202	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00207	e8 00 00 00 00	 call	 gz_error

; 283  :             return -1;

  0020c	b8 ff ff ff ff	 mov	 eax, -1
  00211	eb 39		 jmp	 SHORT $LN16@gz_decomp
$LN2@gz_decomp:

; 284  :         }
; 285  :         if (len != (strm->total_out & 0xffffffffL)) {

  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00218	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0021b	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  0021f	74 1d		 je	 SHORT $LN1@gz_decomp

; 286  :             gz_error(state, Z_DATA_ERROR, "incorrect length check");

  00221	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  00228	ba fd ff ff ff	 mov	 edx, -3
  0022d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00232	e8 00 00 00 00	 call	 gz_error

; 287  :             return -1;

  00237	b8 ff ff ff ff	 mov	 eax, -1
  0023c	eb 0e		 jmp	 SHORT $LN16@gz_decomp
$LN1@gz_decomp:

; 288  :         }
; 289  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

  0023e	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00243	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0
$LN5@gz_decomp:

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;

  0024a	33 c0		 xor	 eax, eax
$LN16@gz_decomp:

; 295  : }

  0024c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00250	c3		 ret	 0
gz_decomp ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_make DD imagerel gz_make
	DD	imagerel gz_make+236
	DD	imagerel $unwind$gz_make
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_make DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_make
_TEXT	SEGMENT
strm$ = 32
state$ = 64
gz_make	PROC						; COMDAT

; 306  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 307  :     z_streamp strm = &(state->strm);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00012	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 308  : 
; 309  :     if (state->how == LOOK) {           /* look for gzip header */

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0001c	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00020	75 2b		 jne	 SHORT $LN8@gz_make

; 310  :         if (gz_head(state) == -1)

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00027	e8 00 00 00 00	 call	 gz_head
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	75 0a		 jne	 SHORT $LN7@gz_make

; 311  :             return -1;

  00031	b8 ff ff ff ff	 mov	 eax, -1
  00036	e9 ac 00 00 00	 jmp	 $LN9@gz_make
$LN7@gz_make:

; 312  :         if (state->have)                /* got some data from gz_head() */

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00040	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00044	74 07		 je	 SHORT $LN6@gz_make

; 313  :             return 0;

  00046	33 c0		 xor	 eax, eax
  00048	e9 9a 00 00 00	 jmp	 $LN9@gz_make
$LN6@gz_make:
$LN8@gz_make:

; 314  :     }
; 315  :     if (state->how == COPY) {           /* straight copy */

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00052	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  00056	75 48		 jne	 SHORT $LN5@gz_make

; 316  :         if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)

  00058	4c 8b 4c 24 40	 mov	 r9, QWORD PTR state$[rsp]
  0005d	49 83 c1 38	 add	 r9, 56			; 00000038H
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00066	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  0006a	41 d1 e0	 shl	 r8d, 1
  0006d	48 8b 54 24 40	 mov	 rdx, QWORD PTR state$[rsp]
  00072	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0007b	e8 00 00 00 00	 call	 gz_load
  00080	83 f8 ff	 cmp	 eax, -1
  00083	75 07		 jne	 SHORT $LN4@gz_make

; 317  :             return -1;

  00085	b8 ff ff ff ff	 mov	 eax, -1
  0008a	eb 5b		 jmp	 SHORT $LN9@gz_make
$LN4@gz_make:

; 318  :         state->next = state->out;

  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00096	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0009a	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0009e	eb 45		 jmp	 SHORT $LN3@gz_make
$LN5@gz_make:

; 319  :     }
; 320  :     else if (state->how == GZIP) {      /* decompress */

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000a5	83 78 48 02	 cmp	 DWORD PTR [rax+72], 2
  000a9	75 3a		 jne	 SHORT $LN2@gz_make

; 321  :         strm->avail_out = state->size << 1;

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000b0	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  000b3	d1 e1		 shl	 ecx, 1
  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000ba	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 322  :         strm->next_out = state->out;

  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000c7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000cb	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 323  :         if (gz_decomp(state) == -1)

  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000d4	e8 00 00 00 00	 call	 gz_decomp
  000d9	83 f8 ff	 cmp	 eax, -1
  000dc	75 07		 jne	 SHORT $LN1@gz_make

; 324  :             return -1;

  000de	b8 ff ff ff ff	 mov	 eax, -1
  000e3	eb 02		 jmp	 SHORT $LN9@gz_make
$LN1@gz_make:
$LN2@gz_make:
$LN3@gz_make:

; 325  :     }
; 326  :     return 0;

  000e5	33 c0		 xor	 eax, eax
$LN9@gz_make:

; 327  : }

  000e7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000eb	c3		 ret	 0
gz_make	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+244
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_skip
_TEXT	SEGMENT
n$ = 32
tv73 = 36
state$ = 64
len$ = 72
gz_skip	PROC						; COMDAT

; 333  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN7@gz_skip:

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00012	0f 84 d5 00 00
	00		 je	 $LN6@gz_skip

; 338  :         /* skip over whatever is in output buffer */
; 339  :         if (state->have) {

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0001d	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00021	0f 84 91 00 00
	00		 je	 $LN5@gz_skip

; 340  :             n = GT_OFF(state->have) || (z_off64_t)state->have > len ?
; 341  :                 (unsigned)len : state->have;

  00027	33 c0		 xor	 eax, eax
  00029	83 f8 01	 cmp	 eax, 1
  0002c	74 0e		 je	 SHORT $LN10@gz_skip
  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00033	81 78 38 ff ff
	ff 7f		 cmp	 DWORD PTR [rax+56], 2147483647 ; 7fffffffH
  0003a	77 1c		 ja	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00041	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  00045	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  00048	7f 0e		 jg	 SHORT $LN11@gz_skip
  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0004f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00052	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  00056	eb 08		 jmp	 SHORT $LN12@gz_skip
$LN11@gz_skip:
  00058	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0005c	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
$LN12@gz_skip:
  00060	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]
  00064	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 342  :             state->have -= n;

  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0006d	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00071	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00074	2b c8		 sub	 ecx, eax
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0007b	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 343  :             state->next += n;

  0007e	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00087	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00090	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 344  :             state->pos += n;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00099	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0009c	03 4c 24 20	 add	 ecx, DWORD PTR n$[rsp]
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000a5	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 345  :             len -= n;

  000a8	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000ac	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  000b0	2b c1		 sub	 eax, ecx
  000b2	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  000b6	eb 30		 jmp	 SHORT $LN4@gz_skip
$LN5@gz_skip:

; 346  :         }
; 347  : 
; 348  :         /* output buffer empty -- return if we're at the end of the input */
; 349  :         else if (state->eof && state->strm.avail_in == 0)

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000bd	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  000c1	74 0f		 je	 SHORT $LN3@gz_skip
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000c8	83 78 78 00	 cmp	 DWORD PTR [rax+120], 0
  000cc	75 04		 jne	 SHORT $LN3@gz_skip

; 350  :             break;

  000ce	eb 1d		 jmp	 SHORT $LN6@gz_skip

; 351  : 
; 352  :         /* need more data to skip -- load up output buffer */
; 353  :         else {

  000d0	eb 16		 jmp	 SHORT $LN2@gz_skip
$LN3@gz_skip:

; 354  :             /* get more output, looking for header if required */
; 355  :             if (gz_make(state) == -1)

  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000d7	e8 00 00 00 00	 call	 gz_make
  000dc	83 f8 ff	 cmp	 eax, -1
  000df	75 07		 jne	 SHORT $LN1@gz_skip

; 356  :                 return -1;

  000e1	b8 ff ff ff ff	 mov	 eax, -1
  000e6	eb 07		 jmp	 SHORT $LN8@gz_skip
$LN1@gz_skip:
$LN2@gz_skip:
$LN4@gz_skip:

; 357  :         }

  000e8	e9 20 ff ff ff	 jmp	 $LN7@gz_skip
$LN6@gz_skip:

; 358  :     return 0;

  000ed	33 c0		 xor	 eax, eax
$LN8@gz_skip:

; 359  : }

  000ef	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f3	c3		 ret	 0
gz_skip	ENDP
PUBLIC	gzgets
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzgets
_TEXT	SEGMENT
eol$ = 32
n$ = 40
left$ = 44
state$ = 48
str$ = 56
tv91 = 64
file$ = 96
buf$ = 104
len$ = 112
gzgets	PROC						; COMDAT

; 543  : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 544  :     unsigned left, n;
; 545  :     char *str;
; 546  :     unsigned char *eol;
; 547  :     gz_statep state;
; 548  : 
; 549  :     /* check parameters and get internal structure */
; 550  :     if (file == NULL || buf == NULL || len < 1)

  00013	48 83 7c 24 60
	00		 cmp	 QWORD PTR file$[rsp], 0
  00019	74 0f		 je	 SHORT $LN15@gzgets
  0001b	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00021	74 07		 je	 SHORT $LN15@gzgets
  00023	83 7c 24 70 01	 cmp	 DWORD PTR len$[rsp], 1
  00028	7d 07		 jge	 SHORT $LN16@gzgets
$LN15@gzgets:

; 551  :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 c4 01 00 00	 jmp	 $LN17@gzgets
$LN16@gzgets:

; 552  :     state = (gz_statep)file;

  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR file$[rsp]
  00036	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 553  : 
; 554  :     /* check that we're reading and that there's no error */
; 555  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00040	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00046	75 0b		 jne	 SHORT $LN13@gzgets
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004d	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00051	74 07		 je	 SHORT $LN14@gzgets
$LN13@gzgets:

; 556  :         return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	e9 9b 01 00 00	 jmp	 $LN17@gzgets
$LN14@gzgets:

; 557  : 
; 558  :     /* process a skip request */
; 559  :     if (state->seek) {

  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005f	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00063	74 2a		 je	 SHORT $LN12@gzgets

; 560  :         state->seek = 0;

  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0006a	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 561  :         if (gz_skip(state, state->skip) == -1)

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00076	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0007e	e8 00 00 00 00	 call	 gz_skip
  00083	83 f8 ff	 cmp	 eax, -1
  00086	75 07		 jne	 SHORT $LN11@gzgets

; 562  :             return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 66 01 00 00	 jmp	 $LN17@gzgets
$LN11@gzgets:
$LN12@gzgets:

; 563  :     }
; 564  : 
; 565  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 566  :        append a terminating zero to the string (we don't check for a zero in
; 567  :        the contents, let the user worry about that) */
; 568  :     str = buf;

  0008f	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  00094	48 89 44 24 38	 mov	 QWORD PTR str$[rsp], rax

; 569  :     left = (unsigned)len - 1;

  00099	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  0009d	83 e8 01	 sub	 eax, 1
  000a0	89 44 24 2c	 mov	 DWORD PTR left$[rsp], eax

; 570  :     if (left) do {

  000a4	83 7c 24 2c 00	 cmp	 DWORD PTR left$[rsp], 0
  000a9	0f 84 39 01 00
	00		 je	 $LN10@gzgets
$LN9@gzgets:

; 571  :         /* assure that something is in the output buffer */
; 572  :         if (state->have == 0) {

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b4	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000b8	75 39		 jne	 SHORT $LN6@gzgets

; 573  :             if (gz_make(state) == -1)

  000ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000bf	e8 00 00 00 00	 call	 gz_make
  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	75 07		 jne	 SHORT $LN5@gzgets

; 574  :                 return NULL;            /* error */

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 25 01 00 00	 jmp	 $LN17@gzgets
$LN5@gzgets:

; 575  :             if (state->have == 0) {     /* end of file */

  000d0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000d5	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000d9	75 18		 jne	 SHORT $LN4@gzgets

; 576  :                 if (buf == str)         /* got bupkus */

  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR str$[rsp]
  000e0	48 39 44 24 68	 cmp	 QWORD PTR buf$[rsp], rax
  000e5	75 07		 jne	 SHORT $LN3@gzgets

; 577  :                     return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 07 01 00 00	 jmp	 $LN17@gzgets
$LN3@gzgets:

; 578  :                 break;                  /* got something -- return it */

  000ee	e9 f5 00 00 00	 jmp	 $LN7@gzgets
$LN4@gzgets:
$LN6@gzgets:

; 579  :             }
; 580  :         }
; 581  : 
; 582  :         /* look for end-of-line in current output buffer */
; 583  :         n = state->have > left ? left : state->have;

  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000f8	8b 44 24 2c	 mov	 eax, DWORD PTR left$[rsp]
  000fc	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  000ff	76 0a		 jbe	 SHORT $LN19@gzgets
  00101	8b 44 24 2c	 mov	 eax, DWORD PTR left$[rsp]
  00105	89 44 24 40	 mov	 DWORD PTR tv91[rsp], eax
  00109	eb 0c		 jmp	 SHORT $LN20@gzgets
$LN19@gzgets:
  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00110	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00113	89 44 24 40	 mov	 DWORD PTR tv91[rsp], eax
$LN20@gzgets:
  00117	8b 44 24 40	 mov	 eax, DWORD PTR tv91[rsp]
  0011b	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 584  :         eol = memchr(state->next, '\n', n);

  0011f	44 8b 44 24 28	 mov	 r8d, DWORD PTR n$[rsp]
  00124	ba 0a 00 00 00	 mov	 edx, 10
  00129	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0012e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00138	48 89 44 24 20	 mov	 QWORD PTR eol$[rsp], rax

; 585  :         if (eol != NULL)

  0013d	48 83 7c 24 20
	00		 cmp	 QWORD PTR eol$[rsp], 0
  00143	74 18		 je	 SHORT $LN2@gzgets

; 586  :             n = (unsigned)(eol - state->next) + 1;

  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0014a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR eol$[rsp]
  00153	48 2b c1	 sub	 rax, rcx
  00156	83 c0 01	 add	 eax, 1
  00159	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
$LN2@gzgets:

; 587  : 
; 588  :         /* copy through end-of-line, or remainder if not found */
; 589  :         memcpy(buf, state->next, n);

  0015d	44 8b 44 24 28	 mov	 r8d, DWORD PTR n$[rsp]
  00162	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  00167	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0016b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00170	e8 00 00 00 00	 call	 memcpy

; 590  :         state->have -= n;

  00175	4c 8b 5c 24 30	 mov	 r11, QWORD PTR state$[rsp]
  0017a	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0017e	41 8b 4b 38	 mov	 ecx, DWORD PTR [r11+56]
  00182	2b c8		 sub	 ecx, eax
  00184	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00189	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 591  :         state->next += n;

  0018c	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00190	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00195	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  00199	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0019e	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 592  :         state->pos += n;

  001a2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001a7	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  001aa	03 4c 24 28	 add	 ecx, DWORD PTR n$[rsp]
  001ae	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001b3	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 593  :         left -= n;

  001b6	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  001ba	8b 44 24 2c	 mov	 eax, DWORD PTR left$[rsp]
  001be	2b c1		 sub	 eax, ecx
  001c0	89 44 24 2c	 mov	 DWORD PTR left$[rsp], eax

; 594  :         buf += n;

  001c4	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  001c8	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  001cd	48 03 c1	 add	 rax, rcx
  001d0	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 595  :     } while (left && eol == NULL);

  001d5	83 7c 24 2c 00	 cmp	 DWORD PTR left$[rsp], 0
  001da	74 0c		 je	 SHORT $LN1@gzgets
  001dc	48 83 7c 24 20
	00		 cmp	 QWORD PTR eol$[rsp], 0
  001e2	0f 84 c7 fe ff
	ff		 je	 $LN9@gzgets
$LN1@gzgets:
$LN7@gzgets:
$LN10@gzgets:

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  001e8	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  001ed	c6 00 00	 mov	 BYTE PTR [rax], 0

; 599  :     return str;

  001f0	48 8b 44 24 38	 mov	 rax, QWORD PTR str$[rsp]
$LN17@gzgets:

; 600  : }

  001f5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f9	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
PUBLIC	gzungetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN14
	DD	imagerel $LN14+530
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzungetc
_TEXT	SEGMENT
state$ = 32
dest$80294 = 40
src$80293 = 48
c$ = 80
file$ = 88
gzungetc PROC						; COMDAT

; 485  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure */
; 489  :     if (file == NULL)

  0000d	48 83 7c 24 58
	00		 cmp	 QWORD PTR file$[rsp], 0
  00013	75 0a		 jne	 SHORT $LN11@gzungetc

; 490  :         return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	e9 ee 01 00 00	 jmp	 $LN12@gzungetc
$LN11@gzungetc:

; 491  :     state = (gz_statep)file;

  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR file$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 492  : 
; 493  :     /* check that we're reading and that there's no error */
; 494  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0002e	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00034	75 0b		 jne	 SHORT $LN9@gzungetc
  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0003b	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0003f	74 0a		 je	 SHORT $LN10@gzungetc
$LN9@gzungetc:

; 495  :         return -1;

  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	e9 c2 01 00 00	 jmp	 $LN12@gzungetc
$LN10@gzungetc:

; 496  : 
; 497  :     /* process a skip request */
; 498  :     if (state->seek) {

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00050	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00054	74 2d		 je	 SHORT $LN8@gzungetc

; 499  :         state->seek = 0;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005b	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 500  :         if (gz_skip(state, state->skip) == -1)

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00067	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0006f	e8 00 00 00 00	 call	 gz_skip
  00074	83 f8 ff	 cmp	 eax, -1
  00077	75 0a		 jne	 SHORT $LN7@gzungetc

; 501  :             return -1;

  00079	b8 ff ff ff ff	 mov	 eax, -1
  0007e	e9 8a 01 00 00	 jmp	 $LN12@gzungetc
$LN7@gzungetc:
$LN8@gzungetc:

; 502  :     }
; 503  : 
; 504  :     /* can't push EOF */
; 505  :     if (c < 0)

  00083	83 7c 24 50 00	 cmp	 DWORD PTR c$[rsp], 0
  00088	7d 0a		 jge	 SHORT $LN6@gzungetc

; 506  :         return -1;

  0008a	b8 ff ff ff ff	 mov	 eax, -1
  0008f	e9 79 01 00 00	 jmp	 $LN12@gzungetc
$LN6@gzungetc:

; 507  : 
; 508  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 509  :     if (state->have == 0) {

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00099	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0009d	75 5b		 jne	 SHORT $LN5@gzungetc

; 510  :         state->have = 1;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a4	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [rax+56], 1

; 511  :         state->next = state->out + (state->size << 1) - 1;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b3	d1 e0		 shl	 eax, 1
  000b5	8b c8		 mov	 ecx, eax
  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000bc	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c0	48 8d 4c 08 ff	 lea	 rcx, QWORD PTR [rax+rcx-1]
  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ca	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 512  :         state->next[0] = c;

  000ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000d3	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000d7	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp]
  000dc	88 01		 mov	 BYTE PTR [rcx], al

; 513  :         state->pos--;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e3	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ee	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 514  :         return c;

  000f1	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
  000f5	e9 13 01 00 00	 jmp	 $LN12@gzungetc
$LN5@gzungetc:

; 515  :     }
; 516  : 
; 517  :     /* if no room, give up (must have already done a gzungetc()) */
; 518  :     if (state->have == (state->size << 1)) {

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ff	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00102	d1 e1		 shl	 ecx, 1
  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00109	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  0010c	75 20		 jne	 SHORT $LN4@gzungetc

; 519  :         gz_error(state, Z_BUF_ERROR, "out of room to push characters");

  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  00115	ba fb ff ff ff	 mov	 edx, -5
  0011a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0011f	e8 00 00 00 00	 call	 gz_error

; 520  :         return -1;

  00124	b8 ff ff ff ff	 mov	 eax, -1
  00129	e9 df 00 00 00	 jmp	 $LN12@gzungetc
$LN4@gzungetc:

; 521  :     }
; 522  : 
; 523  :     /* slide output data if needed and insert byte before existing data */
; 524  :     if (state->next == state->out) {

  0012e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00138	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013c	48 39 41 30	 cmp	 QWORD PTR [rcx+48], rax
  00140	75 7b		 jne	 SHORT $LN3@gzungetc

; 525  :         unsigned char *src = state->out + state->have;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00147	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0014f	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00153	48 89 44 24 30	 mov	 QWORD PTR src$80293[rsp], rax

; 526  :         unsigned char *dest = state->out + (state->size << 1);

  00158	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0015d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00160	d1 e0		 shl	 eax, 1
  00162	8b c0		 mov	 eax, eax
  00164	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00169	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  0016d	48 89 44 24 28	 mov	 QWORD PTR dest$80294[rsp], rax
$LN2@gzungetc:

; 527  :         while (src > state->out)

  00172	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00177	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0017b	48 39 44 24 30	 cmp	 QWORD PTR src$80293[rsp], rax
  00180	76 2d		 jbe	 SHORT $LN1@gzungetc

; 528  :             *--dest = *--src;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR src$80293[rsp]
  00187	48 83 e8 01	 sub	 rax, 1
  0018b	48 89 44 24 30	 mov	 QWORD PTR src$80293[rsp], rax
  00190	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$80294[rsp]
  00195	48 83 e8 01	 sub	 rax, 1
  00199	48 89 44 24 28	 mov	 QWORD PTR dest$80294[rsp], rax
  0019e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$80294[rsp]
  001a3	48 8b 44 24 30	 mov	 rax, QWORD PTR src$80293[rsp]
  001a8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ab	88 01		 mov	 BYTE PTR [rcx], al
  001ad	eb c3		 jmp	 SHORT $LN2@gzungetc
$LN1@gzungetc:

; 529  :         state->next = dest;

  001af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$80294[rsp]
  001b9	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@gzungetc:

; 530  :     }
; 531  :     state->have++;

  001bd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001c2	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  001c5	83 c1 01	 add	 ecx, 1
  001c8	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001cd	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 532  :     state->next--;

  001d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001d5	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  001d9	48 83 e9 01	 sub	 rcx, 1
  001dd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001e2	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 533  :     state->next[0] = c;

  001e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001eb	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  001ef	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp]
  001f4	88 01		 mov	 BYTE PTR [rcx], al

; 534  :     state->pos--;

  001f6	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001fb	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  001fe	83 e9 01	 sub	 ecx, 1
  00201	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00206	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 535  :     return c;

  00209	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
$LN12@gzungetc:

; 536  : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
PUBLIC	gzread
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN27
	DD	imagerel $LN27+641
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzread
_TEXT	SEGMENT
n$ = 32
strm$ = 40
got$ = 48
state$ = 56
tv87 = 64
file$ = 96
buf$ = 104
len$ = 112
gzread	PROC						; COMDAT

; 366  : {

$LN27:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 367  :     unsigned got, n;
; 368  :     gz_statep state;
; 369  :     z_streamp strm;
; 370  : 
; 371  :     /* get internal structure */
; 372  :     if (file == NULL)

  00013	48 83 7c 24 60
	00		 cmp	 QWORD PTR file$[rsp], 0
  00019	75 0a		 jne	 SHORT $LN22@gzread

; 373  :         return -1;

  0001b	b8 ff ff ff ff	 mov	 eax, -1
  00020	e9 57 02 00 00	 jmp	 $LN23@gzread
$LN22@gzread:

; 374  :     state = (gz_statep)file;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR file$[rsp]
  0002a	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 375  :     strm = &(state->strm);

  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00034	48 83 c0 70	 add	 rax, 112		; 00000070H
  00038	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 376  : 
; 377  :     /* check that we're reading and that there's no error */
; 378  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0003d	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00042	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00048	75 0b		 jne	 SHORT $LN20@gzread
  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0004f	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00053	74 0a		 je	 SHORT $LN21@gzread
$LN20@gzread:

; 379  :         return -1;

  00055	b8 ff ff ff ff	 mov	 eax, -1
  0005a	e9 1d 02 00 00	 jmp	 $LN23@gzread
$LN21@gzread:

; 380  : 
; 381  :     /* since an int is returned, make sure len fits in one, otherwise return
; 382  :        with an error (this avoids the flaw in the interface) */
; 383  :     if ((int)len < 0) {

  0005f	83 7c 24 70 00	 cmp	 DWORD PTR len$[rsp], 0
  00064	7d 20		 jge	 SHORT $LN19@gzread

; 384  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0006d	ba fb ff ff ff	 mov	 edx, -5
  00072	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00077	e8 00 00 00 00	 call	 gz_error

; 385  :         return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 f6 01 00 00	 jmp	 $LN23@gzread
$LN19@gzread:

; 386  :     }
; 387  : 
; 388  :     /* if len is zero, avoid unnecessary operations */
; 389  :     if (len == 0)

  00086	83 7c 24 70 00	 cmp	 DWORD PTR len$[rsp], 0
  0008b	75 07		 jne	 SHORT $LN18@gzread

; 390  :         return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 e8 01 00 00	 jmp	 $LN23@gzread
$LN18@gzread:

; 391  : 
; 392  :     /* process a skip request */
; 393  :     if (state->seek) {

  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00099	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  0009d	74 2d		 je	 SHORT $LN17@gzread

; 394  :         state->seek = 0;

  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000a4	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 395  :         if (gz_skip(state, state->skip) == -1)

  000ab	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000b0	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  000b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000b8	e8 00 00 00 00	 call	 gz_skip
  000bd	83 f8 ff	 cmp	 eax, -1
  000c0	75 0a		 jne	 SHORT $LN16@gzread

; 396  :             return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 b0 01 00 00	 jmp	 $LN23@gzread
$LN16@gzread:
$LN17@gzread:

; 397  :     }
; 398  : 
; 399  :     /* get len bytes to buf, or less than len if at the end */
; 400  :     got = 0;

  000cc	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0
$LN15@gzread:

; 401  :     do {
; 402  :         /* first just try copying data from the output buffer */
; 403  :         if (state->have) {

  000d4	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000d9	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000dd	74 75		 je	 SHORT $LN12@gzread

; 404  :             n = state->have > len ? len : state->have;

  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000e4	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000e8	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  000eb	76 0a		 jbe	 SHORT $LN25@gzread
  000ed	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000f1	89 44 24 40	 mov	 DWORD PTR tv87[rsp], eax
  000f5	eb 0c		 jmp	 SHORT $LN26@gzread
$LN25@gzread:
  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000fc	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  000ff	89 44 24 40	 mov	 DWORD PTR tv87[rsp], eax
$LN26@gzread:
  00103	8b 44 24 40	 mov	 eax, DWORD PTR tv87[rsp]
  00107	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 405  :             memcpy(buf, state->next, n);

  0010b	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  00110	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  00115	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00119	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  0011e	e8 00 00 00 00	 call	 memcpy

; 406  :             state->next += n;

  00123	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00127	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0012c	48 03 48 30	 add	 rcx, QWORD PTR [rax+48]
  00130	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00135	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 407  :             state->have -= n;

  00139	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0013e	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00142	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00145	2b c8		 sub	 ecx, eax
  00147	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0014c	89 48 38	 mov	 DWORD PTR [rax+56], ecx
  0014f	e9 d8 00 00 00	 jmp	 $LN11@gzread
$LN12@gzread:

; 408  :         }
; 409  : 
; 410  :         /* output buffer empty -- return if we're at the end of the input */
; 411  :         else if (state->eof && strm->avail_in == 0)

  00154	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00159	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0015d	74 15		 je	 SHORT $LN10@gzread
  0015f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00164	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00168	75 0a		 jne	 SHORT $LN10@gzread
  0016a	e9 09 01 00 00	 jmp	 $LN13@gzread

; 412  :             break;

  0016f	e9 b8 00 00 00	 jmp	 $LN9@gzread
$LN10@gzread:

; 413  : 
; 414  :         /* need output data -- for small len or new stream load up our output
; 415  :            buffer */
; 416  :         else if (state->how == LOOK || len < (state->size << 1)) {

  00174	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00179	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0017d	74 10		 je	 SHORT $LN7@gzread
  0017f	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00184	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00187	d1 e0		 shl	 eax, 1
  00189	39 44 24 70	 cmp	 DWORD PTR len$[rsp], eax
  0018d	73 20		 jae	 SHORT $LN8@gzread
$LN7@gzread:

; 417  :             /* get more output, looking for header if required */
; 418  :             if (gz_make(state) == -1)

  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00194	e8 00 00 00 00	 call	 gz_make
  00199	83 f8 ff	 cmp	 eax, -1
  0019c	75 0a		 jne	 SHORT $LN6@gzread

; 419  :                 return -1;

  0019e	b8 ff ff ff ff	 mov	 eax, -1
  001a3	e9 d4 00 00 00	 jmp	 $LN23@gzread
$LN6@gzread:

; 420  :             continue;       /* no progress yet -- go back to memcpy() above */

  001a8	e9 c0 00 00 00	 jmp	 $LN14@gzread
  001ad	eb 7d		 jmp	 SHORT $LN5@gzread
$LN8@gzread:

; 421  :             /* the copy above assures that we will leave with space in the
; 422  :                output buffer, allowing at least one gzungetc() to succeed */
; 423  :         }
; 424  : 
; 425  :         /* large len -- read directly into user buffer */
; 426  :         else if (state->how == COPY) {      /* read directly */

  001af	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001b4	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  001b8	75 2a		 jne	 SHORT $LN4@gzread

; 427  :             if (gz_load(state, buf, len, &n) == -1)

  001ba	4c 8d 4c 24 20	 lea	 r9, QWORD PTR n$[rsp]
  001bf	44 8b 44 24 70	 mov	 r8d, DWORD PTR len$[rsp]
  001c4	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  001c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001ce	e8 00 00 00 00	 call	 gz_load
  001d3	83 f8 ff	 cmp	 eax, -1
  001d6	75 0a		 jne	 SHORT $LN3@gzread

; 428  :                 return -1;

  001d8	b8 ff ff ff ff	 mov	 eax, -1
  001dd	e9 9a 00 00 00	 jmp	 $LN23@gzread
$LN3@gzread:

; 429  :         }
; 430  : 
; 431  :         /* large len -- decompress directly into user buffer */
; 432  :         else {  /* state->how == GZIP */

  001e2	eb 48		 jmp	 SHORT $LN2@gzread
$LN4@gzread:

; 433  :             strm->avail_out = len;

  001e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  001e9	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  001ed	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 434  :             strm->next_out = buf;

  001f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  001f5	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  001fa	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 435  :             if (gz_decomp(state) == -1)

  001fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00203	e8 00 00 00 00	 call	 gz_decomp
  00208	83 f8 ff	 cmp	 eax, -1
  0020b	75 07		 jne	 SHORT $LN1@gzread

; 436  :                 return -1;

  0020d	b8 ff ff ff ff	 mov	 eax, -1
  00212	eb 68		 jmp	 SHORT $LN23@gzread
$LN1@gzread:

; 437  :             n = state->have;

  00214	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00219	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0021c	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 438  :             state->have = 0;

  00220	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00225	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0
$LN2@gzread:
$LN5@gzread:
$LN9@gzread:
$LN11@gzread:

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;

  0022c	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00230	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  00234	2b c1		 sub	 eax, ecx
  00236	89 44 24 70	 mov	 DWORD PTR len$[rsp], eax

; 443  :         buf = (char *)buf + n;

  0023a	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  0023e	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  00243	48 03 c1	 add	 rax, rcx
  00246	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 444  :         got += n;

  0024b	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  0024f	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
  00253	03 c1		 add	 eax, ecx
  00255	89 44 24 30	 mov	 DWORD PTR got$[rsp], eax

; 445  :         state->pos += n;

  00259	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0025e	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00261	03 4c 24 20	 add	 ecx, DWORD PTR n$[rsp]
  00265	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0026a	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN14@gzread:

; 446  :     } while (len);

  0026d	83 7c 24 70 00	 cmp	 DWORD PTR len$[rsp], 0
  00272	0f 85 5c fe ff
	ff		 jne	 $LN15@gzread
$LN13@gzread:

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;

  00278	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
$LN23@gzread:

; 450  : }

  0027c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00280	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
PUBLIC	gzgetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN9
	DD	imagerel $LN9+225
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzgetc
_TEXT	SEGMENT
buf$ = 32
ret$ = 36
state$ = 40
tv83 = 48
tv91 = 52
file$ = 80
gzgetc	PROC						; COMDAT

; 455  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 456  :     int ret;
; 457  :     unsigned char buf[1];
; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure */
; 461  :     if (file == NULL)

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN4@gzgetc

; 462  :         return -1;

  00011	b8 ff ff ff ff	 mov	 eax, -1
  00016	e9 c1 00 00 00	 jmp	 $LN5@gzgetc
$LN4@gzgetc:

; 463  :     state = (gz_statep)file;

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 464  : 
; 465  :     /* check that we're reading and that there's no error */
; 466  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0002a	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [rax], 7247	; 00001c4fH
  00030	75 0b		 jne	 SHORT $LN2@gzgetc
  00032	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00037	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0003b	74 0a		 je	 SHORT $LN3@gzgetc
$LN2@gzgetc:

; 467  :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	e9 95 00 00 00	 jmp	 $LN5@gzgetc
$LN3@gzgetc:

; 468  : 
; 469  :     /* try output buffer (no need to check for skip request) */
; 470  :     if (state->have) {

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004c	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00050	74 53		 je	 SHORT $LN1@gzgetc

; 471  :         state->have--;

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00057	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  0005a	83 e9 01	 sub	 ecx, 1
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00062	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 472  :         state->pos++;

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006a	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0006d	83 c1 01	 add	 ecx, 1
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00075	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 473  :         return *(state->next)++;

  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00081	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00084	88 44 24 30	 mov	 BYTE PTR tv83[rsp], al
  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0008d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00091	48 83 c1 01	 add	 rcx, 1
  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009a	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  0009e	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv83[rsp]
  000a3	eb 37		 jmp	 SHORT $LN5@gzgetc
$LN1@gzgetc:

; 474  :     }
; 475  : 
; 476  :     /* nothing there -- try gzread() */
; 477  :     ret = gzread(file, buf, 1);

  000a5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ab	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000b5	e8 00 00 00 00	 call	 gzread
  000ba	89 44 24 24	 mov	 DWORD PTR ret$[rsp], eax

; 478  :     return ret < 1 ? -1 : buf[0];

  000be	83 7c 24 24 01	 cmp	 DWORD PTR ret$[rsp], 1
  000c3	7d 0a		 jge	 SHORT $LN7@gzgetc
  000c5	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv91[rsp], -1
  000cd	eb 09		 jmp	 SHORT $LN8@gzgetc
$LN7@gzgetc:
  000cf	0f b6 44 24 20	 movzx	 eax, BYTE PTR buf$[rsp]
  000d4	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
$LN8@gzgetc:
  000d8	8b 44 24 34	 mov	 eax, DWORD PTR tv91[rsp]
$LN5@gzgetc:

; 479  : }

  000dc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e0	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
END
