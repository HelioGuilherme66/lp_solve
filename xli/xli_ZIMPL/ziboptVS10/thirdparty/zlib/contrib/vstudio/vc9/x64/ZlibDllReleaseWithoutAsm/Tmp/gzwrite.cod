; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzwrite.c
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+424
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_init
_TEXT	SEGMENT
strm$ = 64
ret$ = 72
state$ = 96
gz_init	PROC						; COMDAT

; 17   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00012	48 89 44 24 40	 mov	 QWORD PTR strm$[rsp], rax

; 20   : 
; 21   :     /* allocate input and output buffers */
; 22   :     state->in = malloc(state->want);

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0001c	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00025	4c 8b d8	 mov	 r11, rax
  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002d	4c 89 58 20	 mov	 QWORD PTR [rax+32], r11

; 23   :     state->out = malloc(state->want);

  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00036	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	4c 8b d8	 mov	 r11, rax
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00047	4c 89 58 28	 mov	 QWORD PTR [rax+40], r11

; 24   :     if (state->in == NULL || state->out == NULL) {

  0004b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00050	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00055	74 0c		 je	 SHORT $LN4@gz_init
  00057	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0005c	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00061	75 56		 jne	 SHORT $LN5@gz_init
$LN4@gz_init:

; 25   :         if (state->out != NULL)

  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00068	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0006d	74 0f		 je	 SHORT $LN3@gz_init

; 26   :             free(state->out);

  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00074	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gz_init:

; 27   :         if (state->in != NULL)

  0007e	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00083	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00088	74 0f		 je	 SHORT $LN2@gz_init

; 28   :             free(state->in);

  0008a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0008f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@gz_init:

; 29   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a0	ba fc ff ff ff	 mov	 edx, -4
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000aa	e8 00 00 00 00	 call	 gz_error

; 30   :         return -1;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	e9 ea 00 00 00	 jmp	 $LN6@gz_init
$LN5@gz_init:

; 31   :     }
; 32   : 
; 33   :     /* allocate deflate memory, set up for gzip compression */
; 34   :     strm->zalloc = Z_NULL;

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000be	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 35   :     strm->zfree = Z_NULL;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000cb	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 36   :     strm->opaque = Z_NULL;

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d8	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 37   :     ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 38   :                        15 + 16, 8, state->strategy);

  000e0	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@
  000ef	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000f9	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  000fc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00100	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00108	41 b9 1f 00 00
	00		 mov	 r9d, 31
  0010e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00119	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00121	e8 00 00 00 00	 call	 deflateInit2_
  00126	89 44 24 48	 mov	 DWORD PTR ret$[rsp], eax

; 39   :     if (ret != Z_OK) {

  0012a	83 7c 24 48 00	 cmp	 DWORD PTR ret$[rsp], 0
  0012f	74 2c		 je	 SHORT $LN1@gz_init

; 40   :         free(state->in);

  00131	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00136	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 41   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00140	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00147	ba fc ff ff ff	 mov	 edx, -4
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00151	e8 00 00 00 00	 call	 gz_error

; 42   :         return -1;

  00156	b8 ff ff ff ff	 mov	 eax, -1
  0015b	eb 46		 jmp	 SHORT $LN6@gz_init
$LN1@gz_init:

; 43   :     }
; 44   : 
; 45   :     /* mark state as initialized */
; 46   :     state->size = state->want;

  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00162	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00167	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0016a	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 47   : 
; 48   :     /* initialize write buffer */
; 49   :     strm->avail_out = state->size;

  0016d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00172	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00177	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0017a	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 50   :     strm->next_out = state->out;

  0017d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00182	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00187	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0018b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 51   :     state->next = strm->next_out;

  0018f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00194	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00199	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0019d	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 52   :     return 0;

  001a1	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 53   : }

  001a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a7	c3		 ret	 0
gz_init	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+416
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_comp
_TEXT	SEGMENT
have$ = 32
strm$ = 40
ret$ = 48
got$ = 52
state$ = 80
flush$ = 88
gz_comp	PROC						; COMDAT

; 62   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00012	48 83 c0 70	 add	 rax, 112		; 00000070H
  00016	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00020	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00024	75 19		 jne	 SHORT $LN12@gz_comp
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0002b	e8 00 00 00 00	 call	 gz_init
  00030	83 f8 ff	 cmp	 eax, -1
  00033	75 0a		 jne	 SHORT $LN12@gz_comp

; 69   :         return -1;

  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	e9 5c 01 00 00	 jmp	 $LN13@gz_comp
$LN12@gz_comp:

; 70   : 
; 71   :     /* run deflate() on provided input until it produces no more output */
; 72   :     ret = Z_OK;

  0003f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN11@gz_comp:

; 73   :     do {
; 74   :         /* write out current buffer contents if full, or if flushing, but if
; 75   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 76   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 77   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0004c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00050	74 1d		 je	 SHORT $LN7@gz_comp
  00052	83 7c 24 58 00	 cmp	 DWORD PTR flush$[rsp], 0
  00057	0f 84 cc 00 00
	00		 je	 $LN8@gz_comp
  0005d	83 7c 24 58 04	 cmp	 DWORD PTR flush$[rsp], 4
  00062	75 0b		 jne	 SHORT $LN6@gz_comp
  00064	83 7c 24 30 01	 cmp	 DWORD PTR ret$[rsp], 1
  00069	0f 85 ba 00 00
	00		 jne	 $LN8@gz_comp
$LN6@gz_comp:
$LN7@gz_comp:

; 78   :             have = (unsigned)(strm->next_out - state->next);

  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00079	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0007d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00081	48 2b c1	 sub	 rax, rcx
  00084	89 44 24 20	 mov	 DWORD PTR have$[rsp], eax

; 79   :             if (have && ((got = write(state->fd, state->next, have)) < 0 ||
; 80   :                          (unsigned)got != have)) {

  00088	83 7c 24 20 00	 cmp	 DWORD PTR have$[rsp], 0
  0008d	74 5b		 je	 SHORT $LN5@gz_comp
  0008f	44 8b 44 24 20	 mov	 r8d, DWORD PTR have$[rsp]
  00094	48 8b 54 24 50	 mov	 rdx, QWORD PTR state$[rsp]
  00099	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0009d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000a2	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  000ab	89 44 24 34	 mov	 DWORD PTR got$[rsp], eax
  000af	83 7c 24 34 00	 cmp	 DWORD PTR got$[rsp], 0
  000b4	7c 0a		 jl	 SHORT $LN4@gz_comp
  000b6	8b 44 24 20	 mov	 eax, DWORD PTR have$[rsp]
  000ba	39 44 24 34	 cmp	 DWORD PTR got$[rsp], eax
  000be	74 2a		 je	 SHORT $LN5@gz_comp
$LN4@gz_comp:

; 81   :                 gz_error(state, Z_ERRNO, zstrerror());

  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  000ce	4c 8b c0	 mov	 r8, rax
  000d1	ba ff ff ff ff	 mov	 edx, -1
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000db	e8 00 00 00 00	 call	 gz_error

; 82   :                 return -1;

  000e0	b8 ff ff ff ff	 mov	 eax, -1
  000e5	e9 b1 00 00 00	 jmp	 $LN13@gz_comp
$LN5@gz_comp:

; 83   :             }
; 84   :             if (strm->avail_out == 0) {

  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000ef	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000f3	75 22		 jne	 SHORT $LN3@gz_comp

; 85   :                 strm->avail_out = state->size;

  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  000fa	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000ff	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00102	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 86   :                 strm->next_out = state->out;

  00105	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0010f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00113	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN3@gz_comp:

; 87   :             }
; 88   :             state->next = strm->next_out;

  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00121	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00125	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN8@gz_comp:

; 89   :         }
; 90   : 
; 91   :         /* compress */
; 92   :         have = strm->avail_out;

  00129	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0012e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00131	89 44 24 20	 mov	 DWORD PTR have$[rsp], eax

; 93   :         ret = deflate(strm, flush);

  00135	8b 54 24 58	 mov	 edx, DWORD PTR flush$[rsp]
  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0013e	e8 00 00 00 00	 call	 deflate
  00143	89 44 24 30	 mov	 DWORD PTR ret$[rsp], eax

; 94   :         if (ret == Z_STREAM_ERROR) {

  00147	83 7c 24 30 fe	 cmp	 DWORD PTR ret$[rsp], -2
  0014c	75 1d		 jne	 SHORT $LN2@gz_comp

; 95   :             gz_error(state, Z_STREAM_ERROR,
; 96   :                       "internal error: deflate stream corrupt");

  0014e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00155	ba fe ff ff ff	 mov	 edx, -2
  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0015f	e8 00 00 00 00	 call	 gz_error

; 97   :             return -1;

  00164	b8 ff ff ff ff	 mov	 eax, -1
  00169	eb 30		 jmp	 SHORT $LN13@gz_comp
$LN2@gz_comp:

; 98   :         }
; 99   :         have -= strm->avail_out;

  0016b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00170	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00173	8b 44 24 20	 mov	 eax, DWORD PTR have$[rsp]
  00177	2b c1		 sub	 eax, ecx
  00179	89 44 24 20	 mov	 DWORD PTR have$[rsp], eax

; 100  :     } while (have);

  0017d	83 7c 24 20 00	 cmp	 DWORD PTR have$[rsp], 0
  00182	0f 85 bf fe ff
	ff		 jne	 $LN11@gz_comp

; 101  : 
; 102  :     /* if that completed a deflate stream, allow another to start */
; 103  :     if (flush == Z_FINISH)

  00188	83 7c 24 58 04	 cmp	 DWORD PTR flush$[rsp], 4
  0018d	75 0a		 jne	 SHORT $LN1@gz_comp

; 104  :         deflateReset(strm);

  0018f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00194	e8 00 00 00 00	 call	 deflateReset
$LN1@gz_comp:

; 105  : 
; 106  :     /* all done, no errors */
; 107  :     return 0;

  00199	33 c0		 xor	 eax, eax
$LN13@gz_comp:

; 108  : }

  0019b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019f	c3		 ret	 0
gz_comp	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+284
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_zero
_TEXT	SEGMENT
first$ = 32
n$ = 36
strm$ = 40
tv78 = 48
state$ = 80
len$ = 88
gz_zero	PROC						; COMDAT

; 114  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 115  :     int first;
; 116  :     unsigned n;
; 117  :     z_streamp strm = &(state->strm);

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00012	48 83 c0 70	 add	 rax, 112		; 00000070H
  00016	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 118  : 
; 119  :     /* consume whatever's left in the input buffer */
; 120  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00020	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00024	74 1b		 je	 SHORT $LN5@gz_zero
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0002d	e8 00 00 00 00	 call	 gz_comp
  00032	83 f8 ff	 cmp	 eax, -1
  00035	75 0a		 jne	 SHORT $LN5@gz_zero

; 121  :         return -1;

  00037	b8 ff ff ff ff	 mov	 eax, -1
  0003c	e9 d6 00 00 00	 jmp	 $LN6@gz_zero
$LN5@gz_zero:

; 122  : 
; 123  :     /* compress len zeros (len guaranteed > 0) */
; 124  :     first = 1;

  00041	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1
$LN4@gz_zero:

; 125  :     while (len) {

  00049	83 7c 24 58 00	 cmp	 DWORD PTR len$[rsp], 0
  0004e	0f 84 c1 00 00
	00		 je	 $LN3@gz_zero

; 126  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 127  :             (unsigned)len : state->size;

  00054	33 c0		 xor	 eax, eax
  00056	83 f8 01	 cmp	 eax, 1
  00059	74 0e		 je	 SHORT $LN8@gz_zero
  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00060	81 78 14 ff ff
	ff 7f		 cmp	 DWORD PTR [rax+20], 2147483647 ; 7fffffffH
  00067	77 1c		 ja	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00069	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0006e	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  00072	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00075	7f 0e		 jg	 SHORT $LN9@gz_zero
  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0007c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0007f	89 44 24 30	 mov	 DWORD PTR tv78[rsp], eax
  00083	eb 08		 jmp	 SHORT $LN10@gz_zero
$LN9@gz_zero:
  00085	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  00089	89 44 24 30	 mov	 DWORD PTR tv78[rsp], eax
$LN10@gz_zero:
  0008d	8b 44 24 30	 mov	 eax, DWORD PTR tv78[rsp]
  00091	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 128  :         if (first) {

  00095	83 7c 24 20 00	 cmp	 DWORD PTR first$[rsp], 0
  0009a	74 1d		 je	 SHORT $LN2@gz_zero

; 129  :             memset(state->in, 0, n);

  0009c	44 8b 44 24 24	 mov	 r8d, DWORD PTR n$[rsp]
  000a1	33 d2		 xor	 edx, edx
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000a8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ac	e8 00 00 00 00	 call	 memset

; 130  :             first = 0;

  000b1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0
$LN2@gz_zero:

; 131  :         }
; 132  :         strm->avail_in = n;

  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  000be	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  000c2	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 133  :         strm->next_in = state->in;

  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  000ca	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000cf	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 134  :         state->pos += n;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000db	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000de	03 4c 24 24	 add	 ecx, DWORD PTR n$[rsp]
  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000e7	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 135  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000ea	33 d2		 xor	 edx, edx
  000ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000f1	e8 00 00 00 00	 call	 gz_comp
  000f6	83 f8 ff	 cmp	 eax, -1
  000f9	75 07		 jne	 SHORT $LN1@gz_zero

; 136  :             return -1;

  000fb	b8 ff ff ff ff	 mov	 eax, -1
  00100	eb 15		 jmp	 SHORT $LN6@gz_zero
$LN1@gz_zero:

; 137  :         len -= n;

  00102	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  00106	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  0010a	2b c1		 sub	 eax, ecx
  0010c	89 44 24 58	 mov	 DWORD PTR len$[rsp], eax

; 138  :     }

  00110	e9 34 ff ff ff	 jmp	 $LN4@gz_zero
$LN3@gz_zero:

; 139  :     return 0;

  00115	33 c0		 xor	 eax, eax
$LN6@gz_zero:

; 140  : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
gz_zero	ENDP
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN8
	DD	imagerel $LN8+300
	DD	imagerel $unwind$gzclose_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzclose_w
_TEXT	SEGMENT
ret$ = 32
state$ = 40
tv95 = 48
file$ = 80
gzclose_w PROC						; COMDAT

; 502  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 503  :     int ret = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure */
; 507  :     if (file == NULL)

  00011	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00017	75 0a		 jne	 SHORT $LN3@gzclose_w

; 508  :         return Z_STREAM_ERROR;

  00019	b8 fe ff ff ff	 mov	 eax, -2
  0001e	e9 04 01 00 00	 jmp	 $LN4@gzclose_w
$LN3@gzclose_w:

; 509  :     state = (gz_statep)file;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00028	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 510  : 
; 511  :     /* check that we're writing */
; 512  :     if (state->mode != GZ_WRITE)

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00032	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00038	74 0a		 je	 SHORT $LN2@gzclose_w

; 513  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2
  0003f	e9 e3 00 00 00	 jmp	 $LN4@gzclose_w
$LN2@gzclose_w:

; 514  : 
; 515  :     /* check for seek request */
; 516  :     if (state->seek) {

  00044	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00049	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  0004d	74 2c		 je	 SHORT $LN1@gzclose_w

; 517  :         state->seek = 0;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00054	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 518  :         ret += gz_zero(state, state->skip);

  0005b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00060	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  00063	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00068	e8 00 00 00 00	 call	 gz_zero
  0006d	44 8b d8	 mov	 r11d, eax
  00070	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00074	41 03 c3	 add	 eax, r11d
  00077	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax
$LN1@gzclose_w:

; 519  :     }
; 520  : 
; 521  :     /* flush, free memory, and close file */
; 522  :     ret += gz_comp(state, Z_FINISH);

  0007b	ba 04 00 00 00	 mov	 edx, 4
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00085	e8 00 00 00 00	 call	 gz_comp
  0008a	44 8b d8	 mov	 r11d, eax
  0008d	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00091	41 03 c3	 add	 eax, r11d
  00094	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 523  :     (void)deflateEnd(&(state->strm));

  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0009d	48 83 c1 70	 add	 rcx, 112		; 00000070H
  000a1	e8 00 00 00 00	 call	 deflateEnd

; 524  :     free(state->out);

  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ab	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 525  :     free(state->in);

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ba	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 526  :     gz_error(state, Z_OK, NULL);

  000c4	45 33 c0	 xor	 r8d, r8d
  000c7	33 d2		 xor	 edx, edx
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ce	e8 00 00 00 00	 call	 gz_error

; 527  :     free(state->path);

  000d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000d8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 528  :     ret += close(state->fd);

  000e2	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  000e7	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  000f1	44 8b d8	 mov	 r11d, eax
  000f4	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  000f8	41 03 c3	 add	 eax, r11d
  000fb	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 529  :     free(state);

  000ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 530  :     return ret ? Z_ERRNO : Z_OK;

  0010a	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  0010f	74 0a		 je	 SHORT $LN6@gzclose_w
  00111	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR tv95[rsp], -1
  00119	eb 08		 jmp	 SHORT $LN7@gzclose_w
$LN6@gzclose_w:
  0011b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN7@gzclose_w:
  00123	8b 44 24 30	 mov	 eax, DWORD PTR tv95[rsp]
$LN4@gzclose_w:

; 531  : }

  00127	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012b	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
PUBLIC	gzsetparams
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN11
	DD	imagerel $LN11+284
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzsetparams
_TEXT	SEGMENT
strm$ = 32
state$ = 40
file$ = 64
level$ = 72
strategy$ = 80
gzsetparams PROC					; COMDAT

; 462  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 463  :     gz_statep state;
; 464  :     z_streamp strm;
; 465  : 
; 466  :     /* get internal structure */
; 467  :     if (file == NULL)

  00012	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00018	75 0a		 jne	 SHORT $LN8@gzsetparam

; 468  :         return Z_STREAM_ERROR;

  0001a	b8 fe ff ff ff	 mov	 eax, -2
  0001f	e9 f3 00 00 00	 jmp	 $LN9@gzsetparam
$LN8@gzsetparam:

; 469  :     state = (gz_statep)file;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 470  :     strm = &(state->strm);

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00033	48 83 c0 70	 add	 rax, 112		; 00000070H
  00037	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 471  : 
; 472  :     /* check that we're writing and that there's no error */
; 473  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00041	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00047	75 0b		 jne	 SHORT $LN6@gzsetparam
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00052	74 0a		 je	 SHORT $LN7@gzsetparam
$LN6@gzsetparam:

; 474  :         return Z_STREAM_ERROR;

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 b9 00 00 00	 jmp	 $LN9@gzsetparam
$LN7@gzsetparam:

; 475  : 
; 476  :     /* if no change is requested, then do nothing */
; 477  :     if (level == state->level && strategy == state->strategy)

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00063	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00066	39 44 24 48	 cmp	 DWORD PTR level$[rsp], eax
  0006a	75 15		 jne	 SHORT $LN5@gzsetparam
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00071	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00074	39 44 24 50	 cmp	 DWORD PTR strategy$[rsp], eax
  00078	75 07		 jne	 SHORT $LN5@gzsetparam

; 478  :         return Z_OK;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 96 00 00 00	 jmp	 $LN9@gzsetparam
$LN5@gzsetparam:

; 479  : 
; 480  :     /* check for seek request */
; 481  :     if (state->seek) {

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00086	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  0008a	74 2a		 je	 SHORT $LN4@gzsetparam

; 482  :         state->seek = 0;

  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00091	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 483  :         if (gz_zero(state, state->skip) == -1)

  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009d	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000a5	e8 00 00 00 00	 call	 gz_zero
  000aa	83 f8 ff	 cmp	 eax, -1
  000ad	75 07		 jne	 SHORT $LN3@gzsetparam

; 484  :             return -1;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	eb 61		 jmp	 SHORT $LN9@gzsetparam
$LN3@gzsetparam:
$LN4@gzsetparam:

; 485  :     }
; 486  : 
; 487  :     /* change compression parameters for subsequent input */
; 488  :     if (state->size) {

  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000bb	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  000bf	74 3c		 je	 SHORT $LN2@gzsetparam

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000c6	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000ca	74 1e		 je	 SHORT $LN1@gzsetparam
  000cc	ba 01 00 00 00	 mov	 edx, 1
  000d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000d6	e8 00 00 00 00	 call	 gz_comp
  000db	83 f8 ff	 cmp	 eax, -1
  000de	75 0a		 jne	 SHORT $LN1@gzsetparam

; 491  :             return state->err;

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e5	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  000e8	eb 2d		 jmp	 SHORT $LN9@gzsetparam
$LN1@gzsetparam:

; 492  :         deflateParams(strm, level, strategy);

  000ea	44 8b 44 24 50	 mov	 r8d, DWORD PTR strategy$[rsp]
  000ef	8b 54 24 48	 mov	 edx, DWORD PTR level$[rsp]
  000f3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000f8	e8 00 00 00 00	 call	 deflateParams
$LN2@gzsetparam:

; 493  :     }
; 494  :     state->level = level;

  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00102	8b 44 24 48	 mov	 eax, DWORD PTR level$[rsp]
  00106	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 495  :     state->strategy = strategy;

  00109	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0010e	8b 44 24 50	 mov	 eax, DWORD PTR strategy$[rsp]
  00112	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 496  :     return Z_OK;

  00115	33 c0		 xor	 eax, eax
$LN9@gzsetparam:

; 497  : }

  00117	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011b	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
PUBLIC	gzflush
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN10
	DD	imagerel $LN10+174
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzflush
_TEXT	SEGMENT
state$ = 32
file$ = 64
flush$ = 72
gzflush	PROC						; COMDAT

; 429  : {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 430  :     gz_statep state;
; 431  : 
; 432  :     /* get internal structure */
; 433  :     if (file == NULL)

  0000d	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00013	75 0a		 jne	 SHORT $LN7@gzflush

; 434  :         return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	e9 8a 00 00 00	 jmp	 $LN8@gzflush
$LN7@gzflush:

; 435  :     state = (gz_statep)file;

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 436  : 
; 437  :     /* check that we're writing and that there's no error */
; 438  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0002e	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00034	75 0b		 jne	 SHORT $LN5@gzflush
  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0003b	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0003f	74 07		 je	 SHORT $LN6@gzflush
$LN5@gzflush:

; 439  :         return Z_STREAM_ERROR;

  00041	b8 fe ff ff ff	 mov	 eax, -2
  00046	eb 61		 jmp	 SHORT $LN8@gzflush
$LN6@gzflush:

; 440  : 
; 441  :     /* check flush parameter */
; 442  :     if (flush < 0 || flush > Z_FINISH)

  00048	83 7c 24 48 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004d	7c 07		 jl	 SHORT $LN3@gzflush
  0004f	83 7c 24 48 04	 cmp	 DWORD PTR flush$[rsp], 4
  00054	7e 07		 jle	 SHORT $LN4@gzflush
$LN3@gzflush:

; 443  :         return Z_STREAM_ERROR;

  00056	b8 fe ff ff ff	 mov	 eax, -2
  0005b	eb 4c		 jmp	 SHORT $LN8@gzflush
$LN4@gzflush:

; 444  : 
; 445  :     /* check for seek request */
; 446  :     if (state->seek) {

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00062	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00066	74 2a		 je	 SHORT $LN2@gzflush

; 447  :         state->seek = 0;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006d	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 448  :         if (gz_zero(state, state->skip) == -1)

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00079	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00081	e8 00 00 00 00	 call	 gz_zero
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 07		 jne	 SHORT $LN1@gzflush

; 449  :             return -1;

  0008b	b8 ff ff ff ff	 mov	 eax, -1
  00090	eb 17		 jmp	 SHORT $LN8@gzflush
$LN1@gzflush:
$LN2@gzflush:

; 450  :     }
; 451  : 
; 452  :     /* compress remaining data with requested flush */
; 453  :     gz_comp(state, flush);

  00092	8b 54 24 48	 mov	 edx, DWORD PTR flush$[rsp]
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0009b	e8 00 00 00 00	 call	 gz_comp

; 454  :     return state->err;

  000a0	4c 8b 5c 24 20	 mov	 r11, QWORD PTR state$[rsp]
  000a5	41 8b 43 60	 mov	 eax, DWORD PTR [r11+96]
$LN8@gzflush:

; 455  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
PUBLIC	gzprintf
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN12
	DD	imagerel $LN12+412
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzprintf
_TEXT	SEGMENT
va$ = 32
strm$ = 40
len$ = 48
size$ = 52
state$ = 56
file$ = 80
format$ = 88
gzprintf PROC						; COMDAT

; 282  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 283  :     int size, len;
; 284  :     gz_statep state;
; 285  :     z_streamp strm;
; 286  :     va_list va;
; 287  : 
; 288  :     /* get internal structure */
; 289  :     if (file == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN9@gzprintf

; 290  :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	e9 6d 01 00 00	 jmp	 $LN10@gzprintf
$LN9@gzprintf:

; 291  :     state = (gz_statep)file;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  0002f	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 292  :     strm = &(state->strm);

  00034	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00039	48 83 c0 70	 add	 rax, 112		; 00000070H
  0003d	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 293  : 
; 294  :     /* check that we're writing and that there's no error */
; 295  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00042	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00047	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  0004d	75 0b		 jne	 SHORT $LN7@gzprintf
  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00054	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00058	74 07		 je	 SHORT $LN8@gzprintf
$LN7@gzprintf:

; 296  :         return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 36 01 00 00	 jmp	 $LN10@gzprintf
$LN8@gzprintf:

; 297  : 
; 298  :     /* make sure we have some buffer space */
; 299  :     if (state->size == 0 && gz_init(state) == -1)

  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00066	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0006a	75 16		 jne	 SHORT $LN6@gzprintf
  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00071	e8 00 00 00 00	 call	 gz_init
  00076	83 f8 ff	 cmp	 eax, -1
  00079	75 07		 jne	 SHORT $LN6@gzprintf

; 300  :         return 0;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 15 01 00 00	 jmp	 $LN10@gzprintf
$LN6@gzprintf:

; 301  : 
; 302  :     /* check for seek request */
; 303  :     if (state->seek) {

  00082	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00087	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  0008b	74 2a		 je	 SHORT $LN5@gzprintf

; 304  :         state->seek = 0;

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00092	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 305  :         if (gz_zero(state, state->skip) == -1)

  00099	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0009e	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000a6	e8 00 00 00 00	 call	 gz_zero
  000ab	83 f8 ff	 cmp	 eax, -1
  000ae	75 07		 jne	 SHORT $LN4@gzprintf

; 306  :             return 0;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 e0 00 00 00	 jmp	 $LN10@gzprintf
$LN4@gzprintf:
$LN5@gzprintf:

; 307  :     }
; 308  : 
; 309  :     /* consume whatever's left in the input buffer */
; 310  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000bc	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000c0	74 18		 je	 SHORT $LN3@gzprintf
  000c2	33 d2		 xor	 edx, edx
  000c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000c9	e8 00 00 00 00	 call	 gz_comp
  000ce	83 f8 ff	 cmp	 eax, -1
  000d1	75 07		 jne	 SHORT $LN3@gzprintf

; 311  :         return 0;

  000d3	33 c0		 xor	 eax, eax
  000d5	e9 bd 00 00 00	 jmp	 $LN10@gzprintf
$LN3@gzprintf:

; 312  : 
; 313  :     /* do the printf() into the input buffer, put length in len */
; 314  :     size = (int)(state->size);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000df	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000e2	89 44 24 34	 mov	 DWORD PTR size$[rsp], eax

; 315  :     state->in[size - 1] = 0;

  000e6	8b 44 24 34	 mov	 eax, DWORD PTR size$[rsp]
  000ea	83 e8 01	 sub	 eax, 1
  000ed	48 63 c8	 movsxd	 rcx, eax
  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000f5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000f9	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 316  :     va_start(va, format);

  000fd	48 8d 44 24 60	 lea	 rax, QWORD PTR format$[rsp+8]
  00102	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 317  : #ifdef NO_vsnprintf
; 318  : #  ifdef HAS_vsprintf_void
; 319  :     (void)vsprintf(state->in, format, va);
; 320  :     va_end(va);
; 321  :     for (len = 0; len < size; len++)
; 322  :         if (state->in[len] == 0) break;
; 323  : #  else
; 324  :     len = vsprintf(state->in, format, va);
; 325  :     va_end(va);
; 326  : #  endif
; 327  : #else
; 328  : #  ifdef HAS_vsnprintf_void
; 329  :     (void)vsnprintf(state->in, size, format, va);
; 330  :     va_end(va);
; 331  :     len = strlen(state->in);
; 332  : #  else
; 333  :     len = vsnprintf((char *)(state->in), size, format, va);

  00107	48 63 54 24 34	 movsxd	 rdx, DWORD PTR size$[rsp]
  0010c	4c 8b 4c 24 20	 mov	 r9, QWORD PTR va$[rsp]
  00111	4c 8b 44 24 58	 mov	 r8, QWORD PTR format$[rsp]
  00116	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0011b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__vsnprintf
  00125	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 334  :     va_end(va);

  00129	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 335  : #  endif
; 336  : #endif
; 337  : 
; 338  :     /* check that printf() results fit in buffer */
; 339  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  00132	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  00137	7e 25		 jle	 SHORT $LN1@gzprintf
  00139	8b 44 24 34	 mov	 eax, DWORD PTR size$[rsp]
  0013d	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00141	7d 1b		 jge	 SHORT $LN1@gzprintf
  00143	8b 44 24 34	 mov	 eax, DWORD PTR size$[rsp]
  00147	83 e8 01	 sub	 eax, 1
  0014a	48 63 c8	 movsxd	 rcx, eax
  0014d	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00152	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00156	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0015a	85 c0		 test	 eax, eax
  0015c	74 04		 je	 SHORT $LN2@gzprintf
$LN1@gzprintf:

; 340  :         return 0;

  0015e	33 c0		 xor	 eax, eax
  00160	eb 35		 jmp	 SHORT $LN10@gzprintf
$LN2@gzprintf:

; 341  : 
; 342  :     /* update buffer and position, defer compression until needed */
; 343  :     strm->avail_in = (unsigned)len;

  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00167	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0016b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 344  :     strm->next_in = state->in;

  0016e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00173	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00178	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0017c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 345  :     state->pos += len;

  0017f	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00184	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00187	03 4c 24 30	 add	 ecx, DWORD PTR len$[rsp]
  0018b	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00190	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 346  :     return len;

  00193	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
$LN10@gzprintf:

; 347  : }

  00197	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019b	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
PUBLIC	gzwrite
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN21
	DD	imagerel $LN21+570
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzwrite
_TEXT	SEGMENT
put$ = 32
n$ = 36
strm$ = 40
state$ = 48
file$ = 80
buf$ = 88
len$ = 96
gzwrite	PROC						; COMDAT

; 147  : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 148  :     unsigned put = len;

  00013	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR put$[rsp], eax

; 149  :     unsigned n;
; 150  :     gz_statep state;
; 151  :     z_streamp strm;
; 152  : 
; 153  :     /* get internal structure */
; 154  :     if (file == NULL)

  0001b	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00021	75 07		 jne	 SHORT $LN18@gzwrite

; 155  :         return 0;

  00023	33 c0		 xor	 eax, eax
  00025	e9 0b 02 00 00	 jmp	 $LN19@gzwrite
$LN18@gzwrite:

; 156  :     state = (gz_statep)file;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 157  :     strm = &(state->strm);

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00039	48 83 c0 70	 add	 rax, 112		; 00000070H
  0003d	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 158  : 
; 159  :     /* check that we're writing and that there's no error */
; 160  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00047	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  0004d	75 0b		 jne	 SHORT $LN16@gzwrite
  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00054	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00058	74 07		 je	 SHORT $LN17@gzwrite
$LN16@gzwrite:

; 161  :         return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 d4 01 00 00	 jmp	 $LN19@gzwrite
$LN17@gzwrite:

; 162  : 
; 163  :     /* since an int is returned, make sure len fits in one, otherwise return
; 164  :        with an error (this avoids the flaw in the interface) */
; 165  :     if ((int)len < 0) {

  00061	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  00066	7d 1d		 jge	 SHORT $LN15@gzwrite

; 166  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0006f	ba fb ff ff ff	 mov	 edx, -5
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00079	e8 00 00 00 00	 call	 gz_error

; 167  :         return 0;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 b0 01 00 00	 jmp	 $LN19@gzwrite
$LN15@gzwrite:

; 168  :     }
; 169  : 
; 170  :     /* if len is zero, avoid unnecessary operations */
; 171  :     if (len == 0)

  00085	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  0008a	75 07		 jne	 SHORT $LN14@gzwrite

; 172  :         return 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 a2 01 00 00	 jmp	 $LN19@gzwrite
$LN14@gzwrite:

; 173  : 
; 174  :     /* allocate memory if this is the first time through */
; 175  :     if (state->size == 0 && gz_init(state) == -1)

  00093	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00098	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0009c	75 16		 jne	 SHORT $LN13@gzwrite
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000a3	e8 00 00 00 00	 call	 gz_init
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	75 07		 jne	 SHORT $LN13@gzwrite

; 176  :         return 0;

  000ad	33 c0		 xor	 eax, eax
  000af	e9 81 01 00 00	 jmp	 $LN19@gzwrite
$LN13@gzwrite:

; 177  : 
; 178  :     /* check for seek request */
; 179  :     if (state->seek) {

  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b9	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  000bd	74 2a		 je	 SHORT $LN12@gzwrite

; 180  :         state->seek = 0;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c4	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 181  :         if (gz_zero(state, state->skip) == -1)

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000d0	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  000d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000d8	e8 00 00 00 00	 call	 gz_zero
  000dd	83 f8 ff	 cmp	 eax, -1
  000e0	75 07		 jne	 SHORT $LN11@gzwrite

; 182  :             return 0;

  000e2	33 c0		 xor	 eax, eax
  000e4	e9 4c 01 00 00	 jmp	 $LN19@gzwrite
$LN11@gzwrite:
$LN12@gzwrite:

; 183  :     }
; 184  : 
; 185  :     /* for small len, copy to input buffer, otherwise compress directly */
; 186  :     if (len < state->size) {

  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000ee	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000f1	39 44 24 60	 cmp	 DWORD PTR len$[rsp], eax
  000f5	0f 83 d4 00 00
	00		 jae	 $LN10@gzwrite
$LN9@gzwrite:

; 187  :         /* copy to input buffer, compress when full */
; 188  :         do {
; 189  :             if (strm->avail_in == 0)

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00100	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00104	75 11		 jne	 SHORT $LN6@gzwrite

; 190  :                 strm->next_in = state->in;

  00106	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00110	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00114	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN6@gzwrite:

; 191  :             n = state->size - strm->avail_in;

  00117	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00121	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00124	8b 42 14	 mov	 eax, DWORD PTR [rdx+20]
  00127	2b c1		 sub	 eax, ecx
  00129	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 192  :             if (n > len)

  0012d	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00131	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  00135	76 08		 jbe	 SHORT $LN5@gzwrite

; 193  :                 n = len;

  00137	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  0013b	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN5@gzwrite:

; 194  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  0013f	44 8b 44 24 24	 mov	 r8d, DWORD PTR n$[rsp]
  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00149	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00151	48 03 08	 add	 rcx, QWORD PTR [rax]
  00154	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  00159	e8 00 00 00 00	 call	 memcpy

; 195  :             strm->avail_in += n;

  0015e	4c 8b 5c 24 28	 mov	 r11, QWORD PTR strm$[rsp]
  00163	41 8b 4b 08	 mov	 ecx, DWORD PTR [r11+8]
  00167	03 4c 24 24	 add	 ecx, DWORD PTR n$[rsp]
  0016b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00170	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 196  :             state->pos += n;

  00173	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00178	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0017b	03 4c 24 24	 add	 ecx, DWORD PTR n$[rsp]
  0017f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00184	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 197  :             buf = (char *)buf + n;

  00187	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  0018b	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00190	48 03 c1	 add	 rax, rcx
  00193	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 198  :             len -= n;

  00198	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  0019c	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  001a0	2b c1		 sub	 eax, ecx
  001a2	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 199  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  001a6	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  001ab	74 15		 je	 SHORT $LN4@gzwrite
  001ad	33 d2		 xor	 edx, edx
  001af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  001b4	e8 00 00 00 00	 call	 gz_comp
  001b9	83 f8 ff	 cmp	 eax, -1
  001bc	75 04		 jne	 SHORT $LN4@gzwrite

; 200  :                 return 0;

  001be	33 c0		 xor	 eax, eax
  001c0	eb 73		 jmp	 SHORT $LN19@gzwrite
$LN4@gzwrite:

; 201  :         } while (len);

  001c2	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  001c7	0f 85 2e ff ff
	ff		 jne	 $LN9@gzwrite

; 202  :     }
; 203  :     else {

  001cd	eb 62		 jmp	 SHORT $LN3@gzwrite
$LN10@gzwrite:

; 204  :         /* consume whatever's left in the input buffer */
; 205  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  001cf	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  001d4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001d8	74 15		 je	 SHORT $LN2@gzwrite
  001da	33 d2		 xor	 edx, edx
  001dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  001e1	e8 00 00 00 00	 call	 gz_comp
  001e6	83 f8 ff	 cmp	 eax, -1
  001e9	75 04		 jne	 SHORT $LN2@gzwrite

; 206  :             return 0;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 46		 jmp	 SHORT $LN19@gzwrite
$LN2@gzwrite:

; 207  : 
; 208  :         /* directly compress user buffer to file */
; 209  :         strm->avail_in = len;

  001ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  001f4	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  001f8	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 210  :         strm->next_in = (voidp)buf;

  001fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  00200	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00205	48 89 01	 mov	 QWORD PTR [rcx], rax

; 211  :         state->pos += len;

  00208	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0020d	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00210	03 4c 24 60	 add	 ecx, DWORD PTR len$[rsp]
  00214	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00219	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 212  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  0021c	33 d2		 xor	 edx, edx
  0021e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00223	e8 00 00 00 00	 call	 gz_comp
  00228	83 f8 ff	 cmp	 eax, -1
  0022b	75 04		 jne	 SHORT $LN1@gzwrite

; 213  :             return 0;

  0022d	33 c0		 xor	 eax, eax
  0022f	eb 04		 jmp	 SHORT $LN19@gzwrite
$LN1@gzwrite:
$LN3@gzwrite:

; 214  :     }
; 215  : 
; 216  :     /* input was all buffered or compressed (put will fit in int) */
; 217  :     return (int)put;

  00231	8b 44 24 20	 mov	 eax, DWORD PTR put$[rsp]
$LN19@gzwrite:

; 218  : }

  00235	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00239	c3		 ret	 0
gzwrite	ENDP
PUBLIC	gzputs
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzputs
_TEXT	SEGMENT
len$ = 32
ret$ = 36
tv73 = 40
file$ = 64
str$ = 72
gzputs	PROC						; COMDAT

; 267  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 268  :     int ret;
; 269  :     unsigned len;
; 270  : 
; 271  :     /* write string */
; 272  :     len = (unsigned)strlen(str);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 273  :     ret = gzwrite(file, str, len);

  0001c	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00021	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0002b	e8 00 00 00 00	 call	 gzwrite
  00030	89 44 24 24	 mov	 DWORD PTR ret$[rsp], eax

; 274  :     return ret == 0 && len != 0 ? -1 : ret;

  00034	83 7c 24 24 00	 cmp	 DWORD PTR ret$[rsp], 0
  00039	75 11		 jne	 SHORT $LN3@gzputs
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00040	74 0a		 je	 SHORT $LN3@gzputs
  00042	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv73[rsp], -1
  0004a	eb 08		 jmp	 SHORT $LN4@gzputs
$LN3@gzputs:
  0004c	8b 44 24 24	 mov	 eax, DWORD PTR ret$[rsp]
  00050	89 44 24 28	 mov	 DWORD PTR tv73[rsp], eax
$LN4@gzputs:
  00054	8b 44 24 28	 mov	 eax, DWORD PTR tv73[rsp]

; 275  : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
PUBLIC	gzputc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN11
	DD	imagerel $LN11+310
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzputc
_TEXT	SEGMENT
strm$ = 32
buf$ = 40
state$ = 48
file$ = 80
c$ = 88
gzputc	PROC						; COMDAT

; 224  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 225  :     unsigned char buf[1];
; 226  :     gz_statep state;
; 227  :     z_streamp strm;
; 228  : 
; 229  :     /* get internal structure */
; 230  :     if (file == NULL)

  0000d	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00013	75 0a		 jne	 SHORT $LN8@gzputc

; 231  :         return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	e9 12 01 00 00	 jmp	 $LN9@gzputc
$LN8@gzputc:

; 232  :     state = (gz_statep)file;

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00024	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 233  :     strm = &(state->strm);

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002e	48 83 c0 70	 add	 rax, 112		; 00000070H
  00032	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 234  : 
; 235  :     /* check that we're writing and that there's no error */
; 236  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003c	81 38 b1 79 00
	00		 cmp	 DWORD PTR [rax], 31153	; 000079b1H
  00042	75 0b		 jne	 SHORT $LN6@gzputc
  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00049	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0004d	74 0a		 je	 SHORT $LN7@gzputc
$LN6@gzputc:

; 237  :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	e9 d8 00 00 00	 jmp	 $LN9@gzputc
$LN7@gzputc:

; 238  : 
; 239  :     /* check for seek request */
; 240  :     if (state->seek) {

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005e	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00062	74 2d		 je	 SHORT $LN5@gzputc

; 241  :         state->seek = 0;

  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00069	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 242  :         if (gz_zero(state, state->skip) == -1)

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00075	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0007d	e8 00 00 00 00	 call	 gz_zero
  00082	83 f8 ff	 cmp	 eax, -1
  00085	75 0a		 jne	 SHORT $LN4@gzputc

; 243  :             return -1;

  00087	b8 ff ff ff ff	 mov	 eax, -1
  0008c	e9 a0 00 00 00	 jmp	 $LN9@gzputc
$LN4@gzputc:
$LN5@gzputc:

; 244  :     }
; 245  : 
; 246  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 247  :        initialized) */
; 248  :     if (strm->avail_in < state->size) {

  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009e	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  000a1	73 60		 jae	 SHORT $LN3@gzputc

; 249  :         if (strm->avail_in == 0)

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000a8	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000ac	75 11		 jne	 SHORT $LN2@gzputc

; 250  :             strm->next_in = state->in;

  000ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000bc	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN2@gzputc:

; 251  :         strm->next_in[strm->avail_in++] = c;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000c4	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  000c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000cc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cf	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp]
  000d4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000dc	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000df	83 c1 01	 add	 ecx, 1
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000e7	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 252  :         state->pos++;

  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000ef	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000f2	83 c1 01	 add	 ecx, 1
  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000fa	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 253  :         return c;

  000fd	8b 44 24 58	 mov	 eax, DWORD PTR c$[rsp]
  00101	eb 2e		 jmp	 SHORT $LN9@gzputc
$LN3@gzputc:

; 254  :     }
; 255  : 
; 256  :     /* no room in buffer or not initialized, use gz_write() */
; 257  :     buf[0] = c;

  00103	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp]
  00108	88 44 24 28	 mov	 BYTE PTR buf$[rsp], al

; 258  :     if (gzwrite(file, buf, 1) != 1)

  0010c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00112	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  0011c	e8 00 00 00 00	 call	 gzwrite
  00121	83 f8 01	 cmp	 eax, 1
  00124	74 07		 je	 SHORT $LN1@gzputc

; 259  :         return -1;

  00126	b8 ff ff ff ff	 mov	 eax, -1
  0012b	eb 04		 jmp	 SHORT $LN9@gzputc
$LN1@gzputc:

; 260  :     return c;

  0012d	8b 44 24 58	 mov	 eax, DWORD PTR c$[rsp]
$LN9@gzputc:

; 261  : }

  00131	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00135	c3		 ret	 0
gzputc	ENDP
END
