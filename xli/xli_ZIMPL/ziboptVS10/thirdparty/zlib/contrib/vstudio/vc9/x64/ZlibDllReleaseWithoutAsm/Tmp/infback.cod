; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\infback.c
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 625  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN1@inflateBac
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN1@inflateBac
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 627  :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 29		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 628  :     ZFREE(strm, strm->state);

  00030	48 8b 54 24 30	 mov	 rdx, QWORD PTR strm$[rsp]
  00035	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  0003e	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00047	ff 50 38	 call	 QWORD PTR [rax+56]

; 629  :     strm->state = Z_NULL;

  0004a	4c 8b 5c 24 30	 mov	 r11, QWORD PTR strm$[rsp]
  0004f	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  00057	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 632  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
inflateBackEnd ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 75   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00005	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 111  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 112  :     state->distcode = distfix;

  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 113  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 114  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN10
	DD	imagerel $LN10+341
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
state$ = 32
strm$ = 64
windowBits$ = 72
window$ = 80
version$ = 88
stream_size$ = 96
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 58
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN6@inflateBac@2
  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00027	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 07		 jne	 SHORT $LN6@inflateBac@2
  00032	83 7c 24 60 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 0d 01 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	74 16		 je	 SHORT $LN4@inflateBac@2
  0004b	48 83 7c 24 50
	00		 cmp	 QWORD PTR window$[rsp], 0
  00051	74 0e		 je	 SHORT $LN4@inflateBac@2
  00053	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00058	7c 07		 jl	 SHORT $LN4@inflateBac@2
  0005a	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  0005f	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00061	b8 fe ff ff ff	 mov	 eax, -2
  00066	e9 e5 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00082	75 1d		 jne	 SHORT $LN3@inflateBac@2

; 45   :         strm->zalloc = zcalloc;

  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  00090	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 46   :         strm->opaque = (voidpf)0;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00099	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN3@inflateBac@2:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a6	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000ab	75 10		 jne	 SHORT $LN2@inflateBac@2
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000b9	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@inflateBac@2:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  000bd	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000c3	ba 01 00 00 00	 mov	 edx, 1
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000cd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  000e4	75 07		 jne	 SHORT $LN1@inflateBac@2
  000e6	b8 fc ff ff ff	 mov	 eax, -4
  000eb	eb 63		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f7	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 54   :     state->dmax = 32768U;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00100	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 55   :     state->wbits = windowBits;

  00107	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0010c	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00110	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 56   :     state->wsize = 1U << windowBits;

  00113	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	d3 e0		 shl	 eax, cl
  0011e	8b c8		 mov	 ecx, eax
  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00125	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 57   :     state->window = window;

  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR window$[rsp]
  00132	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 58   :     state->wnext = 0;

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0013b	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 59   :     state->whave = 0;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00147	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 60   :     return Z_OK;

  0014e	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 61   : }

  00150	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00154	c3		 ret	 0
inflateBackInit_ ENDP
PUBLIC	inflateBack
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN355
	DD	imagerel $LN355+7224
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBack
_TEXT	SEGMENT
put$ = 48
last$ = 56
here$ = 60
have$ = 64
len$ = 68
bits$ = 72
left$ = 76
next$ = 80
ret$ = 88
hold$ = 92
copy$ = 96
from$ = 104
state$ = 112
tv73 = 120
tv76 = 124
tv137 = 128
tv796 = 132
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 247  : {

$LN355:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0001b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00024	74 0f		 je	 SHORT $LN346@inflateBac@3
  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00033	75 0a		 jne	 SHORT $LN347@inflateBac@3
$LN346@inflateBac@3:

; 265  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 a3 1b 00 00	 jmp	 $LN348@inflateBac@3
$LN347@inflateBac@3:

; 266  :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	48 89 44 24 70	 mov	 QWORD PTR state$[rsp], rax

; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 270  :     state->mode = TYPE;

  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00065	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 271  :     state->last = 0;

  0006b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00070	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 272  :     state->whave = 0;

  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0007c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 273  :     next = strm->next_in;

  00083	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00093	48 83 7c 24 50
	00		 cmp	 QWORD PTR next$[rsp], 0
  00099	74 11		 je	 SHORT $LN350@inflateBac@3
  0009b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a6	89 44 24 78	 mov	 DWORD PTR tv73[rsp], eax
  000aa	eb 08		 jmp	 SHORT $LN351@inflateBac@3
$LN350@inflateBac@3:
  000ac	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN351@inflateBac@3:
  000b4	8b 44 24 78	 mov	 eax, DWORD PTR tv73[rsp]
  000b8	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 275  :     hold = 0;

  000bc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0

; 276  :     bits = 0;

  000c4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 277  :     put = state->window;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d5	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 278  :     left = state->wsize;

  000da	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000df	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000e2	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
$LN345@inflateBac@3:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000eb	8b 00		 mov	 eax, DWORD PTR [rax]
  000ed	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000f1	8b 44 24 7c	 mov	 eax, DWORD PTR tv76[rsp]
  000f5	83 e8 0b	 sub	 eax, 11
  000f8	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000fc	83 7c 24 7c 12	 cmp	 DWORD PTR tv76[rsp], 18
  00101	0f 87 a9 1a 00
	00		 ja	 $LN1@inflateBac@3
  00107	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv76[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00113	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN354@inflateBac@3[rcx+rax*4]
  0011a	48 03 c1	 add	 rax, rcx
  0011d	ff e0		 jmp	 rax
$LN341@inflateBac@3:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00124	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00128	74 3b		 je	 SHORT $LN340@inflateBac@3
$LN339@inflateBac@3:

; 286  :                 BYTEBITS();

  0012a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0012e	83 e0 07	 and	 eax, 7
  00131	0f b6 c8	 movzx	 ecx, al
  00134	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00138	d3 e8		 shr	 eax, cl
  0013a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0013e	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  00142	83 e1 07	 and	 ecx, 7
  00145	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00149	2b c1		 sub	 eax, ecx
  0014b	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 d5		 jne	 SHORT $LN339@inflateBac@3

; 287  :                 state->mode = DONE;

  00155	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0015a	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 288  :                 break;

  00160	e9 55 1a 00 00	 jmp	 $LN342@inflateBac@3
$LN340@inflateBac@3:
$LN336@inflateBac@3:
$LN333@inflateBac@3:

; 289  :             }
; 290  :             NEEDBITS(3);

  00165	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  0016a	0f 83 94 00 00
	00		 jae	 $LN332@inflateBac@3
$LN331@inflateBac@3:
$LN328@inflateBac@3:
  00170	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00175	75 35		 jne	 SHORT $LN325@inflateBac@3
  00177	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0017c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00184	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0018b	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0018f	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00194	75 16		 jne	 SHORT $LN324@inflateBac@3
  00196	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0019f	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  001a7	e9 13 1a 00 00	 jmp	 $inf_leave$78223
$LN324@inflateBac@3:
$LN325@inflateBac@3:
  001ac	33 c0		 xor	 eax, eax
  001ae	85 c0		 test	 eax, eax
  001b0	75 be		 jne	 SHORT $LN328@inflateBac@3
  001b2	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  001b6	83 e8 01	 sub	 eax, 1
  001b9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001c2	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001c5	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  001c9	0f b6 c8	 movzx	 ecx, al
  001cc	8b c2		 mov	 eax, edx
  001ce	d3 e0		 shl	 eax, cl
  001d0	8b c8		 mov	 ecx, eax
  001d2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  001d6	03 c1		 add	 eax, ecx
  001d8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  001dc	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001e1	48 83 c0 01	 add	 rax, 1
  001e5	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  001ea	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  001ee	83 c0 08	 add	 eax, 8
  001f1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  001f5	33 c0		 xor	 eax, eax
  001f7	85 c0		 test	 eax, eax
  001f9	0f 85 71 ff ff
	ff		 jne	 $LN331@inflateBac@3
  001ff	e9 61 ff ff ff	 jmp	 $LN333@inflateBac@3
$LN332@inflateBac@3:
  00204	33 c0		 xor	 eax, eax
  00206	85 c0		 test	 eax, eax
  00208	0f 85 57 ff ff
	ff		 jne	 $LN336@inflateBac@3

; 291  :             state->last = BITS(1);

  0020e	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00212	83 e1 01	 and	 ecx, 1
  00215	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0021a	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN323@inflateBac@3:

; 292  :             DROPBITS(1);

  0021d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00221	d1 e8		 shr	 eax, 1
  00223	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00227	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0022b	83 e8 01	 sub	 eax, 1
  0022e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	75 e5		 jne	 SHORT $LN323@inflateBac@3

; 293  :             switch (BITS(2)) {

  00238	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0023c	83 e0 03	 and	 eax, 3
  0023f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  00246	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv137[rsp], 0
  0024e	74 20		 je	 SHORT $LN318@inflateBac@3
  00250	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv137[rsp], 1
  00258	74 23		 je	 SHORT $LN317@inflateBac@3
  0025a	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv137[rsp], 2
  00262	74 31		 je	 SHORT $LN316@inflateBac@3
  00264	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR tv137[rsp], 3
  0026c	74 34		 je	 SHORT $LN315@inflateBac@3
  0026e	eb 50		 jmp	 SHORT $LN319@inflateBac@3
$LN318@inflateBac@3:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  00270	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00275	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 298  :                 break;

  0027b	eb 43		 jmp	 SHORT $LN319@inflateBac@3
$LN317@inflateBac@3:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  0027d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00282	e8 00 00 00 00	 call	 fixedtables

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00287	4c 8b 5c 24 70	 mov	 r11, QWORD PTR state$[rsp]
  0028c	41 c7 03 14 00
	00 00		 mov	 DWORD PTR [r11], 20

; 304  :                 break;

  00293	eb 2b		 jmp	 SHORT $LN319@inflateBac@3
$LN316@inflateBac@3:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  00295	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0029a	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 309  :                 break;

  002a0	eb 1e		 jmp	 SHORT $LN319@inflateBac@3
$LN315@inflateBac@3:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  002a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  002b1	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 312  :                 state->mode = BAD;

  002b5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  002ba	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29
$LN319@inflateBac@3:
$LN314@inflateBac@3:

; 313  :             }
; 314  :             DROPBITS(2);

  002c0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002c4	c1 e8 02	 shr	 eax, 2
  002c7	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002cb	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  002cf	83 e8 02	 sub	 eax, 2
  002d2	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  002d6	33 c0		 xor	 eax, eax
  002d8	85 c0		 test	 eax, eax
  002da	75 e4		 jne	 SHORT $LN314@inflateBac@3

; 315  :             break;

  002dc	e9 d9 18 00 00	 jmp	 $LN342@inflateBac@3
$LN311@inflateBac@3:
$LN310@inflateBac@3:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  002e1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  002e5	83 e0 07	 and	 eax, 7
  002e8	0f b6 c8	 movzx	 ecx, al
  002eb	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002ef	d3 e8		 shr	 eax, cl
  002f1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002f5	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  002f9	83 e1 07	 and	 ecx, 7
  002fc	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00300	2b c1		 sub	 eax, ecx
  00302	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00306	33 c0		 xor	 eax, eax
  00308	85 c0		 test	 eax, eax
  0030a	75 d5		 jne	 SHORT $LN310@inflateBac@3
$LN307@inflateBac@3:
$LN304@inflateBac@3:

; 320  :             NEEDBITS(32);

  0030c	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00311	0f 83 94 00 00
	00		 jae	 $LN303@inflateBac@3
$LN302@inflateBac@3:
$LN299@inflateBac@3:
  00317	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0031c	75 35		 jne	 SHORT $LN296@inflateBac@3
  0031e	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00323	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0032b	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00332	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00336	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0033b	75 16		 jne	 SHORT $LN295@inflateBac@3
  0033d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00346	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0034e	e9 6c 18 00 00	 jmp	 $inf_leave$78223
$LN295@inflateBac@3:
$LN296@inflateBac@3:
  00353	33 c0		 xor	 eax, eax
  00355	85 c0		 test	 eax, eax
  00357	75 be		 jne	 SHORT $LN299@inflateBac@3
  00359	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0035d	83 e8 01	 sub	 eax, 1
  00360	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00364	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00369	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0036c	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00370	0f b6 c8	 movzx	 ecx, al
  00373	8b c2		 mov	 eax, edx
  00375	d3 e0		 shl	 eax, cl
  00377	8b c8		 mov	 ecx, eax
  00379	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0037d	03 c1		 add	 eax, ecx
  0037f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00383	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00388	48 83 c0 01	 add	 rax, 1
  0038c	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00391	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00395	83 c0 08	 add	 eax, 8
  00398	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0039c	33 c0		 xor	 eax, eax
  0039e	85 c0		 test	 eax, eax
  003a0	0f 85 71 ff ff
	ff		 jne	 $LN302@inflateBac@3
  003a6	e9 61 ff ff ff	 jmp	 $LN304@inflateBac@3
$LN303@inflateBac@3:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	0f 85 57 ff ff
	ff		 jne	 $LN307@inflateBac@3

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  003b5	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  003b9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003bf	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  003c3	c1 e8 10	 shr	 eax, 16
  003c6	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  003cb	3b c8		 cmp	 ecx, eax
  003cd	74 23		 je	 SHORT $LN294@inflateBac@3

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  003cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  003de	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 323  :                 state->mode = BAD;

  003e2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003e7	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 324  :                 break;

  003ed	e9 c8 17 00 00	 jmp	 $LN342@inflateBac@3
$LN294@inflateBac@3:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  003f2	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  003f6	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003fc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00401	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN293@inflateBac@3:

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  00404	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0040c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00414	33 c0		 xor	 eax, eax
  00416	85 c0		 test	 eax, eax
  00418	75 ea		 jne	 SHORT $LN293@inflateBac@3
$LN290@inflateBac@3:

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  0041a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0041f	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00423	0f 84 3e 01 00
	00		 je	 $LN289@inflateBac@3

; 333  :                 copy = state->length;

  00429	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0042e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00431	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN288@inflateBac@3:

; 334  :                 PULL();

  00435	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0043a	75 35		 jne	 SHORT $LN285@inflateBac@3
  0043c	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00441	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00449	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00450	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00454	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00459	75 16		 jne	 SHORT $LN284@inflateBac@3
  0045b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00464	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0046c	e9 4e 17 00 00	 jmp	 $inf_leave$78223
$LN284@inflateBac@3:
$LN285@inflateBac@3:
  00471	33 c0		 xor	 eax, eax
  00473	85 c0		 test	 eax, eax
  00475	75 be		 jne	 SHORT $LN288@inflateBac@3
$LN283@inflateBac@3:

; 335  :                 ROOM();

  00477	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  0047c	75 50		 jne	 SHORT $LN280@inflateBac@3
  0047e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00483	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00487	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0048c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00491	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00494	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  00498	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0049d	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  004a1	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  004a4	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  004a9	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  004ae	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  004b6	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  004bd	85 c0		 test	 eax, eax
  004bf	74 0d		 je	 SHORT $LN279@inflateBac@3
  004c1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  004c9	e9 f1 16 00 00	 jmp	 $inf_leave$78223
$LN279@inflateBac@3:
$LN280@inflateBac@3:
  004ce	33 c0		 xor	 eax, eax
  004d0	85 c0		 test	 eax, eax
  004d2	75 a3		 jne	 SHORT $LN283@inflateBac@3

; 336  :                 if (copy > have) copy = have;

  004d4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  004d8	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  004dc	76 08		 jbe	 SHORT $LN278@inflateBac@3
  004de	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  004e2	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN278@inflateBac@3:

; 337  :                 if (copy > left) copy = left;

  004e6	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  004ea	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  004ee	76 08		 jbe	 SHORT $LN277@inflateBac@3
  004f0	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  004f4	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN277@inflateBac@3:

; 338  :                 zmemcpy(put, next, copy);

  004f8	44 8b 44 24 60	 mov	 r8d, DWORD PTR copy$[rsp]
  004fd	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00502	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  00507	e8 00 00 00 00	 call	 memcpy

; 339  :                 have -= copy;

  0050c	44 8b 5c 24 60	 mov	 r11d, DWORD PTR copy$[rsp]
  00511	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00515	41 2b c3	 sub	 eax, r11d
  00518	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 340  :                 next += copy;

  0051c	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00520	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00525	48 03 c1	 add	 rax, rcx
  00528	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 341  :                 left -= copy;

  0052d	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00531	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  00535	2b c1		 sub	 eax, ecx
  00537	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 342  :                 put += copy;

  0053b	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  0053f	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  00544	48 03 c1	 add	 rax, rcx
  00547	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 343  :                 state->length -= copy;

  0054c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00551	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00555	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00558	2b c8		 sub	 ecx, eax
  0055a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0055f	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 344  :             }

  00562	e9 b3 fe ff ff	 jmp	 $LN290@inflateBac@3
$LN289@inflateBac@3:

; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  00567	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0056c	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 347  :             break;

  00572	e9 43 16 00 00	 jmp	 $LN342@inflateBac@3
$LN276@inflateBac@3:
$LN275@inflateBac@3:
$LN272@inflateBac@3:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  00577	83 7c 24 48 0e	 cmp	 DWORD PTR bits$[rsp], 14
  0057c	0f 83 94 00 00
	00		 jae	 $LN271@inflateBac@3
$LN270@inflateBac@3:
$LN267@inflateBac@3:
  00582	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00587	75 35		 jne	 SHORT $LN264@inflateBac@3
  00589	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0058e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00596	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0059d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  005a1	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  005a6	75 16		 jne	 SHORT $LN263@inflateBac@3
  005a8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  005b1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  005b9	e9 01 16 00 00	 jmp	 $inf_leave$78223
$LN263@inflateBac@3:
$LN264@inflateBac@3:
  005be	33 c0		 xor	 eax, eax
  005c0	85 c0		 test	 eax, eax
  005c2	75 be		 jne	 SHORT $LN267@inflateBac@3
  005c4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  005c8	83 e8 01	 sub	 eax, 1
  005cb	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  005cf	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005d4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  005d7	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  005db	0f b6 c8	 movzx	 ecx, al
  005de	8b c2		 mov	 eax, edx
  005e0	d3 e0		 shl	 eax, cl
  005e2	8b c8		 mov	 ecx, eax
  005e4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  005e8	03 c1		 add	 eax, ecx
  005ea	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  005ee	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005f3	48 83 c0 01	 add	 rax, 1
  005f7	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  005fc	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00600	83 c0 08	 add	 eax, 8
  00603	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00607	33 c0		 xor	 eax, eax
  00609	85 c0		 test	 eax, eax
  0060b	0f 85 71 ff ff
	ff		 jne	 $LN270@inflateBac@3
  00611	e9 61 ff ff ff	 jmp	 $LN272@inflateBac@3
$LN271@inflateBac@3:
  00616	33 c0		 xor	 eax, eax
  00618	85 c0		 test	 eax, eax
  0061a	0f 85 57 ff ff
	ff		 jne	 $LN275@inflateBac@3

; 352  :             state->nlen = BITS(5) + 257;

  00620	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00624	83 e1 1f	 and	 ecx, 31
  00627	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0062d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00632	89 48 74	 mov	 DWORD PTR [rax+116], ecx
$LN262@inflateBac@3:

; 353  :             DROPBITS(5);

  00635	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00639	c1 e8 05	 shr	 eax, 5
  0063c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00640	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00644	83 e8 05	 sub	 eax, 5
  00647	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0064b	33 c0		 xor	 eax, eax
  0064d	85 c0		 test	 eax, eax
  0064f	75 e4		 jne	 SHORT $LN262@inflateBac@3

; 354  :             state->ndist = BITS(5) + 1;

  00651	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00655	83 e1 1f	 and	 ecx, 31
  00658	83 c1 01	 add	 ecx, 1
  0065b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00660	89 48 78	 mov	 DWORD PTR [rax+120], ecx
$LN259@inflateBac@3:

; 355  :             DROPBITS(5);

  00663	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00667	c1 e8 05	 shr	 eax, 5
  0066a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0066e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00672	83 e8 05	 sub	 eax, 5
  00675	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00679	33 c0		 xor	 eax, eax
  0067b	85 c0		 test	 eax, eax
  0067d	75 e4		 jne	 SHORT $LN259@inflateBac@3

; 356  :             state->ncode = BITS(4) + 4;

  0067f	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00683	83 e1 0f	 and	 ecx, 15
  00686	83 c1 04	 add	 ecx, 4
  00689	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0068e	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN256@inflateBac@3:

; 357  :             DROPBITS(4);

  00691	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00695	c1 e8 04	 shr	 eax, 4
  00698	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0069c	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  006a0	83 e8 04	 sub	 eax, 4
  006a3	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  006a7	33 c0		 xor	 eax, eax
  006a9	85 c0		 test	 eax, eax
  006ab	75 e4		 jne	 SHORT $LN256@inflateBac@3

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  006ad	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006b2	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  006b9	77 0b		 ja	 SHORT $LN252@inflateBac@3
  006bb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006c0	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  006c4	76 23		 jbe	 SHORT $LN253@inflateBac@3
$LN252@inflateBac@3:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  006c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  006ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  006d5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 361  :                 state->mode = BAD;

  006d9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006de	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 362  :                 break;

  006e4	e9 d1 14 00 00	 jmp	 $LN342@inflateBac@3
$LN253@inflateBac@3:

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  006e9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006ee	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN251@inflateBac@3:

; 369  :             while (state->have < state->ncode) {

  006f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  006fa	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006ff	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00702	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  00705	0f 83 04 01 00
	00		 jae	 $LN250@inflateBac@3
$LN249@inflateBac@3:
$LN246@inflateBac@3:

; 370  :                 NEEDBITS(3);

  0070b	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  00710	0f 83 94 00 00
	00		 jae	 $LN245@inflateBac@3
$LN244@inflateBac@3:
$LN241@inflateBac@3:
  00716	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0071b	75 35		 jne	 SHORT $LN238@inflateBac@3
  0071d	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00722	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0072a	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00731	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00735	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0073a	75 16		 jne	 SHORT $LN237@inflateBac@3
  0073c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00745	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0074d	e9 6d 14 00 00	 jmp	 $inf_leave$78223
$LN237@inflateBac@3:
$LN238@inflateBac@3:
  00752	33 c0		 xor	 eax, eax
  00754	85 c0		 test	 eax, eax
  00756	75 be		 jne	 SHORT $LN241@inflateBac@3
  00758	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0075c	83 e8 01	 sub	 eax, 1
  0075f	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00763	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00768	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0076b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0076f	0f b6 c8	 movzx	 ecx, al
  00772	8b c2		 mov	 eax, edx
  00774	d3 e0		 shl	 eax, cl
  00776	8b c8		 mov	 ecx, eax
  00778	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0077c	03 c1		 add	 eax, ecx
  0077e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00782	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00787	48 83 c0 01	 add	 rax, 1
  0078b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00790	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00794	83 c0 08	 add	 eax, 8
  00797	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0079b	33 c0		 xor	 eax, eax
  0079d	85 c0		 test	 eax, eax
  0079f	0f 85 71 ff ff
	ff		 jne	 $LN244@inflateBac@3
  007a5	e9 61 ff ff ff	 jmp	 $LN246@inflateBac@3
$LN245@inflateBac@3:
  007aa	33 c0		 xor	 eax, eax
  007ac	85 c0		 test	 eax, eax
  007ae	0f 85 57 ff ff
	ff		 jne	 $LN249@inflateBac@3

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  007b4	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  007b8	83 e2 07	 and	 edx, 7
  007bb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007c0	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  007c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflateBack@@9@9
  007ca	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  007ce	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007d3	66 89 94 48 88
	00 00 00	 mov	 WORD PTR [rax+rcx*2+136], dx
  007db	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007e0	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  007e3	83 c1 01	 add	 ecx, 1
  007e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007eb	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN236@inflateBac@3:

; 372  :                 DROPBITS(3);

  007ee	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  007f2	c1 e8 03	 shr	 eax, 3
  007f5	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  007f9	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  007fd	83 e8 03	 sub	 eax, 3
  00800	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00804	33 c0		 xor	 eax, eax
  00806	85 c0		 test	 eax, eax
  00808	75 e4		 jne	 SHORT $LN236@inflateBac@3

; 373  :             }

  0080a	e9 e6 fe ff ff	 jmp	 $LN251@inflateBac@3
$LN250@inflateBac@3:
$LN233@inflateBac@3:

; 374  :             while (state->have < 19)

  0080f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00814	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  00818	73 37		 jae	 SHORT $LN232@inflateBac@3

; 375  :                 state->lens[order[state->have++]] = 0;

  0081a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0081f	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00822	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflateBack@@9@9
  00829	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  0082d	33 c9		 xor	 ecx, ecx
  0082f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00834	66 89 8c 50 88
	00 00 00	 mov	 WORD PTR [rax+rdx*2+136], cx
  0083c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00841	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00844	83 c1 01	 add	 ecx, 1
  00847	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0084c	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  0084f	eb be		 jmp	 SHORT $LN233@inflateBac@3
$LN232@inflateBac@3:

; 376  :             state->next = state->codes;

  00851	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00856	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  0085d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00862	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 377  :             state->lencode = (code const FAR *)(state->next);

  00869	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0086e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00873	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0087a	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 378  :             state->lenbits = 7;

  0087e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00883	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0088a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0088f	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  00896	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0089b	48 83 c0 68	 add	 rax, 104		; 00000068H
  0089f	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  008a4	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  008ab	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  008b0	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  008b7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c1	41 b8 13 00 00
	00		 mov	 r8d, 19
  008c7	33 c9		 xor	 ecx, ecx
  008c9	e8 00 00 00 00	 call	 inflate_table
  008ce	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 381  :             if (ret) {

  008d2	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  008d7	74 23		 je	 SHORT $LN231@inflateBac@3

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  008d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  008e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  008e8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 383  :                 state->mode = BAD;

  008ec	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  008f1	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 384  :                 break;

  008f7	e9 be 12 00 00	 jmp	 $LN342@inflateBac@3
$LN231@inflateBac@3:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;

  008fc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00901	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN230@inflateBac@3:

; 390  :             while (state->have < state->nlen + state->ndist) {

  00908	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0090d	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  00910	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00915	03 48 78	 add	 ecx, DWORD PTR [rax+120]
  00918	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0091d	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  00920	0f 83 f0 05 00
	00		 jae	 $LN229@inflateBac@3
$LN228@inflateBac@3:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  00926	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0092b	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  0092e	b8 01 00 00 00	 mov	 eax, 1
  00933	d3 e0		 shl	 eax, cl
  00935	8b c8		 mov	 ecx, eax
  00937	83 e9 01	 sub	 ecx, 1
  0093a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0093e	23 c1		 and	 eax, ecx
  00940	8b c8		 mov	 ecx, eax
  00942	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00947	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0094b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0094e	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  00952	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00957	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  0095b	77 05		 ja	 SHORT $LN226@inflateBac@3
  0095d	e9 94 00 00 00	 jmp	 $LN227@inflateBac@3
$LN226@inflateBac@3:
$LN225@inflateBac@3:
$LN222@inflateBac@3:

; 394  :                     PULLBYTE();

  00962	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00967	75 35		 jne	 SHORT $LN219@inflateBac@3
  00969	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0096e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00976	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0097d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00981	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00986	75 16		 jne	 SHORT $LN218@inflateBac@3
  00988	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00991	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00999	e9 21 12 00 00	 jmp	 $inf_leave$78223
$LN218@inflateBac@3:
$LN219@inflateBac@3:
  0099e	33 c0		 xor	 eax, eax
  009a0	85 c0		 test	 eax, eax
  009a2	75 be		 jne	 SHORT $LN222@inflateBac@3
  009a4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  009a8	83 e8 01	 sub	 eax, 1
  009ab	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  009af	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009b4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  009b7	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  009bb	0f b6 c8	 movzx	 ecx, al
  009be	8b c2		 mov	 eax, edx
  009c0	d3 e0		 shl	 eax, cl
  009c2	8b c8		 mov	 ecx, eax
  009c4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  009c8	03 c1		 add	 eax, ecx
  009ca	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  009ce	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009d3	48 83 c0 01	 add	 rax, 1
  009d7	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  009dc	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  009e0	83 c0 08	 add	 eax, 8
  009e3	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  009e7	33 c0		 xor	 eax, eax
  009e9	85 c0		 test	 eax, eax
  009eb	0f 85 71 ff ff
	ff		 jne	 $LN225@inflateBac@3

; 395  :                 }

  009f1	e9 30 ff ff ff	 jmp	 $LN228@inflateBac@3
$LN227@inflateBac@3:

; 396  :                 if (here.val < 16) {

  009f6	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  009fb	83 f8 10	 cmp	 eax, 16
  009fe	0f 8d 06 01 00
	00		 jge	 $LN217@inflateBac@3
$LN216@inflateBac@3:
$LN213@inflateBac@3:

; 397  :                     NEEDBITS(here.bits);

  00a04	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00a09	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00a0d	0f 83 94 00 00
	00		 jae	 $LN212@inflateBac@3
$LN211@inflateBac@3:
$LN208@inflateBac@3:
  00a13	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00a18	75 35		 jne	 SHORT $LN205@inflateBac@3
  00a1a	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00a1f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00a27	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00a2e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00a32	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00a37	75 16		 jne	 SHORT $LN204@inflateBac@3
  00a39	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00a42	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00a4a	e9 70 11 00 00	 jmp	 $inf_leave$78223
$LN204@inflateBac@3:
$LN205@inflateBac@3:
  00a4f	33 c0		 xor	 eax, eax
  00a51	85 c0		 test	 eax, eax
  00a53	75 be		 jne	 SHORT $LN208@inflateBac@3
  00a55	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00a59	83 e8 01	 sub	 eax, 1
  00a5c	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00a60	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a65	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00a68	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00a6c	0f b6 c8	 movzx	 ecx, al
  00a6f	8b c2		 mov	 eax, edx
  00a71	d3 e0		 shl	 eax, cl
  00a73	8b c8		 mov	 ecx, eax
  00a75	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00a79	03 c1		 add	 eax, ecx
  00a7b	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00a7f	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a84	48 83 c0 01	 add	 rax, 1
  00a88	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00a8d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00a91	83 c0 08	 add	 eax, 8
  00a94	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00a98	33 c0		 xor	 eax, eax
  00a9a	85 c0		 test	 eax, eax
  00a9c	0f 85 71 ff ff
	ff		 jne	 $LN211@inflateBac@3
  00aa2	e9 5d ff ff ff	 jmp	 $LN213@inflateBac@3
$LN212@inflateBac@3:
  00aa7	33 c0		 xor	 eax, eax
  00aa9	85 c0		 test	 eax, eax
  00aab	0f 85 53 ff ff
	ff		 jne	 $LN216@inflateBac@3
$LN203@inflateBac@3:

; 398  :                     DROPBITS(here.bits);

  00ab1	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ab6	0f b6 c8	 movzx	 ecx, al
  00ab9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00abd	d3 e8		 shr	 eax, cl
  00abf	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00ac3	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  00ac8	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00acc	2b c1		 sub	 eax, ecx
  00ace	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00ad2	33 c0		 xor	 eax, eax
  00ad4	85 c0		 test	 eax, eax
  00ad6	75 d9		 jne	 SHORT $LN203@inflateBac@3

; 399  :                     state->lens[state->have++] = here.val;

  00ad8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00add	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00ae0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ae5	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00aea	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  00af2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00af7	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00afa	83 c1 01	 add	 ecx, 1
  00afd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00b02	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 400  :                 }
; 401  :                 else {

  00b05	e9 07 04 00 00	 jmp	 $LN200@inflateBac@3
$LN217@inflateBac@3:

; 402  :                     if (here.val == 16) {

  00b0a	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00b0f	83 f8 10	 cmp	 eax, 16
  00b12	0f 85 52 01 00
	00		 jne	 $LN199@inflateBac@3
$LN198@inflateBac@3:
$LN195@inflateBac@3:

; 403  :                         NEEDBITS(here.bits + 2);

  00b18	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00b1d	83 c0 02	 add	 eax, 2
  00b20	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00b24	0f 83 94 00 00
	00		 jae	 $LN194@inflateBac@3
$LN193@inflateBac@3:
$LN190@inflateBac@3:
  00b2a	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00b2f	75 35		 jne	 SHORT $LN187@inflateBac@3
  00b31	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00b36	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00b3e	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00b45	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00b49	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00b4e	75 16		 jne	 SHORT $LN186@inflateBac@3
  00b50	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00b59	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00b61	e9 59 10 00 00	 jmp	 $inf_leave$78223
$LN186@inflateBac@3:
$LN187@inflateBac@3:
  00b66	33 c0		 xor	 eax, eax
  00b68	85 c0		 test	 eax, eax
  00b6a	75 be		 jne	 SHORT $LN190@inflateBac@3
  00b6c	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00b70	83 e8 01	 sub	 eax, 1
  00b73	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00b77	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b7c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00b7f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00b83	0f b6 c8	 movzx	 ecx, al
  00b86	8b c2		 mov	 eax, edx
  00b88	d3 e0		 shl	 eax, cl
  00b8a	8b c8		 mov	 ecx, eax
  00b8c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00b90	03 c1		 add	 eax, ecx
  00b92	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00b96	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b9b	48 83 c0 01	 add	 rax, 1
  00b9f	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00ba4	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00ba8	83 c0 08	 add	 eax, 8
  00bab	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00baf	33 c0		 xor	 eax, eax
  00bb1	85 c0		 test	 eax, eax
  00bb3	0f 85 71 ff ff
	ff		 jne	 $LN193@inflateBac@3
  00bb9	e9 5a ff ff ff	 jmp	 $LN195@inflateBac@3
$LN194@inflateBac@3:
  00bbe	33 c0		 xor	 eax, eax
  00bc0	85 c0		 test	 eax, eax
  00bc2	0f 85 50 ff ff
	ff		 jne	 $LN198@inflateBac@3
$LN185@inflateBac@3:

; 404  :                         DROPBITS(here.bits);

  00bc8	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00bcd	0f b6 c8	 movzx	 ecx, al
  00bd0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00bd4	d3 e8		 shr	 eax, cl
  00bd6	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00bda	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  00bdf	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00be3	2b c1		 sub	 eax, ecx
  00be5	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00be9	33 c0		 xor	 eax, eax
  00beb	85 c0		 test	 eax, eax
  00bed	75 d9		 jne	 SHORT $LN185@inflateBac@3

; 405  :                         if (state->have == 0) {

  00bef	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00bf4	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  00bf8	75 23		 jne	 SHORT $LN182@inflateBac@3

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00bfa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c02	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00c09	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 407  :                             state->mode = BAD;

  00c0d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c12	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 408  :                             break;

  00c18	e9 f9 02 00 00	 jmp	 $LN229@inflateBac@3
$LN182@inflateBac@3:

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  00c1d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c22	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00c25	83 e8 01	 sub	 eax, 1
  00c28	8b c8		 mov	 ecx, eax
  00c2a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c2f	0f b7 84 48 88
	00 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+136]
  00c37	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 411  :                         copy = 3 + BITS(2);

  00c3b	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c3f	83 e0 03	 and	 eax, 3
  00c42	83 c0 03	 add	 eax, 3
  00c45	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN181@inflateBac@3:

; 412  :                         DROPBITS(2);

  00c49	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c4d	c1 e8 02	 shr	 eax, 2
  00c50	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00c54	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00c58	83 e8 02	 sub	 eax, 2
  00c5b	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00c5f	33 c0		 xor	 eax, eax
  00c61	85 c0		 test	 eax, eax
  00c63	75 e4		 jne	 SHORT $LN181@inflateBac@3

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  00c65	e9 25 02 00 00	 jmp	 $LN178@inflateBac@3
$LN199@inflateBac@3:
  00c6a	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  00c6f	83 f8 11	 cmp	 eax, 17
  00c72	0f 85 0e 01 00
	00		 jne	 $LN177@inflateBac@3
$LN176@inflateBac@3:
$LN173@inflateBac@3:

; 415  :                         NEEDBITS(here.bits + 3);

  00c78	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00c7d	83 c0 03	 add	 eax, 3
  00c80	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00c84	0f 83 94 00 00
	00		 jae	 $LN172@inflateBac@3
$LN171@inflateBac@3:
$LN168@inflateBac@3:
  00c8a	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00c8f	75 35		 jne	 SHORT $LN165@inflateBac@3
  00c91	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00c96	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00c9e	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00ca5	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00ca9	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00cae	75 16		 jne	 SHORT $LN164@inflateBac@3
  00cb0	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00cb9	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00cc1	e9 f9 0e 00 00	 jmp	 $inf_leave$78223
$LN164@inflateBac@3:
$LN165@inflateBac@3:
  00cc6	33 c0		 xor	 eax, eax
  00cc8	85 c0		 test	 eax, eax
  00cca	75 be		 jne	 SHORT $LN168@inflateBac@3
  00ccc	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00cd0	83 e8 01	 sub	 eax, 1
  00cd3	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00cd7	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cdc	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00cdf	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00ce3	0f b6 c8	 movzx	 ecx, al
  00ce6	8b c2		 mov	 eax, edx
  00ce8	d3 e0		 shl	 eax, cl
  00cea	8b c8		 mov	 ecx, eax
  00cec	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00cf0	03 c1		 add	 eax, ecx
  00cf2	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00cf6	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cfb	48 83 c0 01	 add	 rax, 1
  00cff	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00d04	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00d08	83 c0 08	 add	 eax, 8
  00d0b	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d0f	33 c0		 xor	 eax, eax
  00d11	85 c0		 test	 eax, eax
  00d13	0f 85 71 ff ff
	ff		 jne	 $LN171@inflateBac@3
  00d19	e9 5a ff ff ff	 jmp	 $LN173@inflateBac@3
$LN172@inflateBac@3:
  00d1e	33 c0		 xor	 eax, eax
  00d20	85 c0		 test	 eax, eax
  00d22	0f 85 50 ff ff
	ff		 jne	 $LN176@inflateBac@3
$LN163@inflateBac@3:

; 416  :                         DROPBITS(here.bits);

  00d28	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d2d	0f b6 c8	 movzx	 ecx, al
  00d30	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d34	d3 e8		 shr	 eax, cl
  00d36	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d3a	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  00d3f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00d43	2b c1		 sub	 eax, ecx
  00d45	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d49	33 c0		 xor	 eax, eax
  00d4b	85 c0		 test	 eax, eax
  00d4d	75 d9		 jne	 SHORT $LN163@inflateBac@3

; 417  :                         len = 0;

  00d4f	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 418  :                         copy = 3 + BITS(3);

  00d57	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d5b	83 e0 07	 and	 eax, 7
  00d5e	83 c0 03	 add	 eax, 3
  00d61	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN160@inflateBac@3:

; 419  :                         DROPBITS(3);

  00d65	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d69	c1 e8 03	 shr	 eax, 3
  00d6c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d70	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00d74	83 e8 03	 sub	 eax, 3
  00d77	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00d7b	33 c0		 xor	 eax, eax
  00d7d	85 c0		 test	 eax, eax
  00d7f	75 e4		 jne	 SHORT $LN160@inflateBac@3

; 420  :                     }
; 421  :                     else {

  00d81	e9 09 01 00 00	 jmp	 $LN157@inflateBac@3
$LN177@inflateBac@3:
$LN156@inflateBac@3:
$LN153@inflateBac@3:

; 422  :                         NEEDBITS(here.bits + 7);

  00d86	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d8b	83 c0 07	 add	 eax, 7
  00d8e	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  00d92	0f 83 94 00 00
	00		 jae	 $LN152@inflateBac@3
$LN151@inflateBac@3:
$LN148@inflateBac@3:
  00d98	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00d9d	75 35		 jne	 SHORT $LN145@inflateBac@3
  00d9f	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00da4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00dac	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00db3	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00db7	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00dbc	75 16		 jne	 SHORT $LN144@inflateBac@3
  00dbe	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00dc7	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00dcf	e9 eb 0d 00 00	 jmp	 $inf_leave$78223
$LN144@inflateBac@3:
$LN145@inflateBac@3:
  00dd4	33 c0		 xor	 eax, eax
  00dd6	85 c0		 test	 eax, eax
  00dd8	75 be		 jne	 SHORT $LN148@inflateBac@3
  00dda	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00dde	83 e8 01	 sub	 eax, 1
  00de1	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00de5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00dea	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00ded	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00df1	0f b6 c8	 movzx	 ecx, al
  00df4	8b c2		 mov	 eax, edx
  00df6	d3 e0		 shl	 eax, cl
  00df8	8b c8		 mov	 ecx, eax
  00dfa	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00dfe	03 c1		 add	 eax, ecx
  00e00	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e04	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00e09	48 83 c0 01	 add	 rax, 1
  00e0d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00e12	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e16	83 c0 08	 add	 eax, 8
  00e19	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e1d	33 c0		 xor	 eax, eax
  00e1f	85 c0		 test	 eax, eax
  00e21	0f 85 71 ff ff
	ff		 jne	 $LN151@inflateBac@3
  00e27	e9 5a ff ff ff	 jmp	 $LN153@inflateBac@3
$LN152@inflateBac@3:
  00e2c	33 c0		 xor	 eax, eax
  00e2e	85 c0		 test	 eax, eax
  00e30	0f 85 50 ff ff
	ff		 jne	 $LN156@inflateBac@3
$LN143@inflateBac@3:

; 423  :                         DROPBITS(here.bits);

  00e36	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  00e3b	0f b6 c8	 movzx	 ecx, al
  00e3e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e42	d3 e8		 shr	 eax, cl
  00e44	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e48	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  00e4d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e51	2b c1		 sub	 eax, ecx
  00e53	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e57	33 c0		 xor	 eax, eax
  00e59	85 c0		 test	 eax, eax
  00e5b	75 d9		 jne	 SHORT $LN143@inflateBac@3

; 424  :                         len = 0;

  00e5d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 425  :                         copy = 11 + BITS(7);

  00e65	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e69	83 e0 7f	 and	 eax, 127		; 0000007fH
  00e6c	83 c0 0b	 add	 eax, 11
  00e6f	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN140@inflateBac@3:

; 426  :                         DROPBITS(7);

  00e73	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e77	c1 e8 07	 shr	 eax, 7
  00e7a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e7e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e82	83 e8 07	 sub	 eax, 7
  00e85	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e89	33 c0		 xor	 eax, eax
  00e8b	85 c0		 test	 eax, eax
  00e8d	75 e4		 jne	 SHORT $LN140@inflateBac@3
$LN157@inflateBac@3:
$LN178@inflateBac@3:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00e8f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00e94	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00e97	03 54 24 60	 add	 edx, DWORD PTR copy$[rsp]
  00e9b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ea0	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00ea3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ea8	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  00eab	3b d0		 cmp	 edx, eax
  00ead	76 20		 jbe	 SHORT $LN137@inflateBac@3

; 429  :                         strm->msg = (char *)"invalid bit length repeat";

  00eaf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00eb7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00ebe	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 430  :                         state->mode = BAD;

  00ec2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ec7	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 431  :                         break;

  00ecd	eb 47		 jmp	 SHORT $LN229@inflateBac@3
$LN137@inflateBac@3:
$LN136@inflateBac@3:

; 432  :                     }
; 433  :                     while (copy--)

  00ecf	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00ed3	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00ed7	83 e8 01	 sub	 eax, 1
  00eda	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
  00ede	85 c9		 test	 ecx, ecx
  00ee0	74 2f		 je	 SHORT $LN135@inflateBac@3

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00ee2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ee7	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00eea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00eef	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  00ef4	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  00efc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f01	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00f04	83 c1 01	 add	 ecx, 1
  00f07	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f0c	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  00f0f	eb be		 jmp	 SHORT $LN136@inflateBac@3
$LN135@inflateBac@3:
$LN200@inflateBac@3:

; 435  :                 }
; 436  :             }

  00f11	e9 f2 f9 ff ff	 jmp	 $LN230@inflateBac@3
$LN229@inflateBac@3:

; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00f16	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f1b	83 38 1d	 cmp	 DWORD PTR [rax], 29
  00f1e	75 05		 jne	 SHORT $LN134@inflateBac@3
  00f20	e9 95 0c 00 00	 jmp	 $LN342@inflateBac@3
$LN134@inflateBac@3:

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  00f25	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f2a	0f b7 80 88 02
	00 00		 movzx	 eax, WORD PTR [rax+648]
  00f31	85 c0		 test	 eax, eax
  00f33	75 23		 jne	 SHORT $LN133@inflateBac@3

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00f35	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00f3d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00f44	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 444  :                 state->mode = BAD;

  00f48	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f4d	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 445  :                 break;

  00f53	e9 62 0c 00 00	 jmp	 $LN342@inflateBac@3
$LN133@inflateBac@3:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;

  00f58	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f5d	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  00f64	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f69	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 452  :             state->lencode = (code const FAR *)(state->next);

  00f70	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f75	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f7a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00f81	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 453  :             state->lenbits = 9;

  00f85	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f8a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  00f91	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f96	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  00f9d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00fa2	48 83 c0 68	 add	 rax, 104		; 00000068H
  00fa6	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  00fab	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  00fb2	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00fb7	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  00fbe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fc3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fc8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00fcd	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  00fd1	b9 01 00 00 00	 mov	 ecx, 1
  00fd6	e8 00 00 00 00	 call	 inflate_table
  00fdb	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 456  :             if (ret) {

  00fdf	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  00fe4	74 23		 je	 SHORT $LN132@inflateBac@3

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  00fe6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00fee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00ff5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 458  :                 state->mode = BAD;

  00ff9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ffe	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 459  :                 break;

  01004	e9 b1 0b 00 00	 jmp	 $LN342@inflateBac@3
$LN132@inflateBac@3:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  01009	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0100e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0101a	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 462  :             state->distbits = 6;

  0101e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01023	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  0102a	4c 8b 54 24 70	 mov	 r10, QWORD PTR state$[rsp]
  0102f	49 81 c2 08 03
	00 00		 add	 r10, 776		; 00000308H
  01036	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp]
  0103b	49 83 c0 6c	 add	 r8, 108			; 0000006cH
  0103f	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  01044	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  0104b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01050	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  01053	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01058	48 8d 94 48 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx*2+136]
  01060	4c 89 54 24 28	 mov	 QWORD PTR [rsp+40], r10
  01065	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0106a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0106f	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01073	b9 02 00 00 00	 mov	 ecx, 2
  01078	e8 00 00 00 00	 call	 inflate_table
  0107d	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 465  :             if (ret) {

  01081	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  01086	74 23		 je	 SHORT $LN131@inflateBac@3

; 466  :                 strm->msg = (char *)"invalid distances set";

  01088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  01097	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 467  :                 state->mode = BAD;

  0109b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  010a0	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 468  :                 break;

  010a6	e9 0f 0b 00 00	 jmp	 $LN342@inflateBac@3
$LN131@inflateBac@3:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  010ab	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  010b0	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN130@inflateBac@3:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  010b6	83 7c 24 40 06	 cmp	 DWORD PTR have$[rsp], 6
  010bb	0f 82 0a 01 00
	00		 jb	 $LN129@inflateBac@3
  010c1	81 7c 24 4c 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  010c9	0f 82 fc 00 00
	00		 jb	 $LN129@inflateBac@3
$LN128@inflateBac@3:

; 476  :                 RESTORE();

  010cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010d7	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  010dc	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  010e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010e8	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  010ec	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  010ef	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010f7	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  010fc	48 89 01	 mov	 QWORD PTR [rcx], rax
  010ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01107	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0110b	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0110e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01113	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01117	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  0111a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0111f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01123	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  01126	33 c0		 xor	 eax, eax
  01128	85 c0		 test	 eax, eax
  0112a	75 a3		 jne	 SHORT $LN128@inflateBac@3

; 477  :                 if (state->whave < state->wsize)

  0112c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01131	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01136	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01139	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  0113c	73 16		 jae	 SHORT $LN125@inflateBac@3

; 478  :                     state->whave = state->wsize - left;

  0113e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01143	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01147	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  0114a	2b c8		 sub	 ecx, eax
  0114c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01151	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN125@inflateBac@3:

; 479  :                 inflate_fast(strm, state->wsize);

  01154	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01159	8b 50 2c	 mov	 edx, DWORD PTR [rax+44]
  0115c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01164	e8 00 00 00 00	 call	 inflate_fast
$LN124@inflateBac@3:

; 480  :                 LOAD();

  01169	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01171	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01175	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0117a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01182	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01185	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01189	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01191	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01194	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01199	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011a1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  011a4	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  011a8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011ad	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  011b0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  011b4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011b9	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  011bc	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  011c0	33 c0		 xor	 eax, eax
  011c2	85 c0		 test	 eax, eax
  011c4	75 a3		 jne	 SHORT $LN124@inflateBac@3

; 481  :                 break;

  011c6	e9 ef 09 00 00	 jmp	 $LN342@inflateBac@3
$LN129@inflateBac@3:
$LN121@inflateBac@3:

; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  011cb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011d0	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  011d3	b8 01 00 00 00	 mov	 eax, 1
  011d8	d3 e0		 shl	 eax, cl
  011da	8b c8		 mov	 ecx, eax
  011dc	83 e9 01	 sub	 ecx, 1
  011df	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  011e3	23 c1		 and	 eax, ecx
  011e5	8b c8		 mov	 ecx, eax
  011e7	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011ec	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  011f0	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  011f3	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  011f7	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  011fc	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01200	77 05		 ja	 SHORT $LN119@inflateBac@3
  01202	e9 94 00 00 00	 jmp	 $LN120@inflateBac@3
$LN119@inflateBac@3:
$LN118@inflateBac@3:
$LN115@inflateBac@3:

; 488  :                 PULLBYTE();

  01207	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0120c	75 35		 jne	 SHORT $LN112@inflateBac@3
  0120e	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01213	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0121b	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01222	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01226	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0122b	75 16		 jne	 SHORT $LN111@inflateBac@3
  0122d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01236	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0123e	e9 7c 09 00 00	 jmp	 $inf_leave$78223
$LN111@inflateBac@3:
$LN112@inflateBac@3:
  01243	33 c0		 xor	 eax, eax
  01245	85 c0		 test	 eax, eax
  01247	75 be		 jne	 SHORT $LN115@inflateBac@3
  01249	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0124d	83 e8 01	 sub	 eax, 1
  01250	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01254	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01259	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0125c	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01260	0f b6 c8	 movzx	 ecx, al
  01263	8b c2		 mov	 eax, edx
  01265	d3 e0		 shl	 eax, cl
  01267	8b c8		 mov	 ecx, eax
  01269	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0126d	03 c1		 add	 eax, ecx
  0126f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01273	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01278	48 83 c0 01	 add	 rax, 1
  0127c	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01281	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01285	83 c0 08	 add	 eax, 8
  01288	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0128c	33 c0		 xor	 eax, eax
  0128e	85 c0		 test	 eax, eax
  01290	0f 85 71 ff ff
	ff		 jne	 $LN118@inflateBac@3

; 489  :             }

  01296	e9 30 ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  0129b	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  012a0	85 c0		 test	 eax, eax
  012a2	0f 84 33 01 00
	00		 je	 $LN110@inflateBac@3
  012a8	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  012ad	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  012b2	85 c0		 test	 eax, eax
  012b4	0f 85 21 01 00
	00		 jne	 $LN110@inflateBac@3

; 491  :                 last = here;

  012ba	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  012be	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN109@inflateBac@3:

; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  012c2	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  012c8	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  012cd	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  012d2	03 c8		 add	 ecx, eax
  012d4	b8 01 00 00 00	 mov	 eax, 1
  012d9	d3 e0		 shl	 eax, cl
  012db	83 e8 01	 sub	 eax, 1
  012de	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  012e2	23 d0		 and	 edx, eax
  012e4	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  012e9	0f b6 c8	 movzx	 ecx, al
  012ec	8b c2		 mov	 eax, edx
  012ee	d3 e8		 shr	 eax, cl
  012f0	8b c8		 mov	 ecx, eax
  012f2	41 8b c0	 mov	 eax, r8d
  012f5	03 c1		 add	 eax, ecx
  012f7	8b c8		 mov	 ecx, eax
  012f9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  012fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01302	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01305	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01309	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0130e	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01313	03 c1		 add	 eax, ecx
  01315	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01319	77 05		 ja	 SHORT $LN107@inflateBac@3
  0131b	e9 94 00 00 00	 jmp	 $LN108@inflateBac@3
$LN107@inflateBac@3:
$LN106@inflateBac@3:
$LN103@inflateBac@3:

; 496  :                     PULLBYTE();

  01320	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01325	75 35		 jne	 SHORT $LN100@inflateBac@3
  01327	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0132c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01334	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0133b	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0133f	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01344	75 16		 jne	 SHORT $LN99@inflateBac@3
  01346	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0134f	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01357	e9 63 08 00 00	 jmp	 $inf_leave$78223
$LN99@inflateBac@3:
$LN100@inflateBac@3:
  0135c	33 c0		 xor	 eax, eax
  0135e	85 c0		 test	 eax, eax
  01360	75 be		 jne	 SHORT $LN103@inflateBac@3
  01362	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01366	83 e8 01	 sub	 eax, 1
  01369	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0136d	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01372	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01375	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01379	0f b6 c8	 movzx	 ecx, al
  0137c	8b c2		 mov	 eax, edx
  0137e	d3 e0		 shl	 eax, cl
  01380	8b c8		 mov	 ecx, eax
  01382	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01386	03 c1		 add	 eax, ecx
  01388	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0138c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01391	48 83 c0 01	 add	 rax, 1
  01395	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  0139a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0139e	83 c0 08	 add	 eax, 8
  013a1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  013a5	33 c0		 xor	 eax, eax
  013a7	85 c0		 test	 eax, eax
  013a9	0f 85 71 ff ff
	ff		 jne	 $LN106@inflateBac@3

; 497  :                 }

  013af	e9 0e ff ff ff	 jmp	 $LN109@inflateBac@3
$LN108@inflateBac@3:
$LN98@inflateBac@3:

; 498  :                 DROPBITS(last.bits);

  013b4	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  013b9	0f b6 c8	 movzx	 ecx, al
  013bc	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  013c0	d3 e8		 shr	 eax, cl
  013c2	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  013c6	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  013cb	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  013cf	2b c1		 sub	 eax, ecx
  013d1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  013d5	33 c0		 xor	 eax, eax
  013d7	85 c0		 test	 eax, eax
  013d9	75 d9		 jne	 SHORT $LN98@inflateBac@3
$LN110@inflateBac@3:
$LN95@inflateBac@3:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  013db	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  013e0	0f b6 c8	 movzx	 ecx, al
  013e3	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  013e7	d3 e8		 shr	 eax, cl
  013e9	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  013ed	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  013f2	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  013f6	2b c1		 sub	 eax, ecx
  013f8	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  013fc	33 c0		 xor	 eax, eax
  013fe	85 c0		 test	 eax, eax
  01400	75 d9		 jne	 SHORT $LN95@inflateBac@3

; 501  :             state->length = (unsigned)here.val;

  01402	0f b7 4c 24 3e	 movzx	 ecx, WORD PTR here$[rsp+2]
  01407	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0140c	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  0140f	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  01414	85 c0		 test	 eax, eax
  01416	0f 85 96 00 00
	00		 jne	 $LN92@inflateBac@3
$LN91@inflateBac@3:

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  0141c	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  01421	75 50		 jne	 SHORT $LN88@inflateBac@3
  01423	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01428	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0142c	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01431	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01436	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01439	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  0143d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01442	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01446	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  01449	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  0144e	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  01453	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  0145b	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01462	85 c0		 test	 eax, eax
  01464	74 0d		 je	 SHORT $LN87@inflateBac@3
  01466	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0146e	e9 4c 07 00 00	 jmp	 $inf_leave$78223
$LN87@inflateBac@3:
$LN88@inflateBac@3:
  01473	33 c0		 xor	 eax, eax
  01475	85 c0		 test	 eax, eax
  01477	75 a3		 jne	 SHORT $LN91@inflateBac@3

; 509  :                 *put++ = (unsigned char)(state->length);

  01479	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  0147e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01483	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  01487	88 01		 mov	 BYTE PTR [rcx], al
  01489	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  0148e	48 83 c0 01	 add	 rax, 1
  01492	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 510  :                 left--;

  01497	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0149b	83 e8 01	 sub	 eax, 1
  0149e	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 511  :                 state->mode = LEN;

  014a2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014a7	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 512  :                 break;

  014ad	e9 08 07 00 00	 jmp	 $LN342@inflateBac@3
$LN92@inflateBac@3:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  014b2	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  014b7	83 e0 20	 and	 eax, 32			; 00000020H
  014ba	85 c0		 test	 eax, eax
  014bc	74 10		 je	 SHORT $LN86@inflateBac@3

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  014be	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014c3	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 519  :                 break;

  014c9	e9 ec 06 00 00	 jmp	 $LN342@inflateBac@3
$LN86@inflateBac@3:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  014ce	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  014d3	83 e0 40	 and	 eax, 64			; 00000040H
  014d6	85 c0		 test	 eax, eax
  014d8	74 23		 je	 SHORT $LN85@inflateBac@3

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  014da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  014e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  014e9	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 525  :                 state->mode = BAD;

  014ed	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014f2	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 526  :                 break;

  014f8	e9 bd 06 00 00	 jmp	 $LN342@inflateBac@3
$LN85@inflateBac@3:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  014fd	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR here$[rsp]
  01502	83 e1 0f	 and	 ecx, 15
  01505	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0150a	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 531  :             if (state->extra != 0) {

  0150d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01512	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  01516	0f 84 05 01 00
	00		 je	 $LN84@inflateBac@3
$LN83@inflateBac@3:
$LN80@inflateBac@3:

; 532  :                 NEEDBITS(state->extra);

  0151c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01521	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01524	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  01528	0f 83 94 00 00
	00		 jae	 $LN79@inflateBac@3
$LN78@inflateBac@3:
$LN75@inflateBac@3:
  0152e	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01533	75 35		 jne	 SHORT $LN72@inflateBac@3
  01535	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0153a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01542	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01549	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0154d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01552	75 16		 jne	 SHORT $LN71@inflateBac@3
  01554	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0155d	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01565	e9 55 06 00 00	 jmp	 $inf_leave$78223
$LN71@inflateBac@3:
$LN72@inflateBac@3:
  0156a	33 c0		 xor	 eax, eax
  0156c	85 c0		 test	 eax, eax
  0156e	75 be		 jne	 SHORT $LN75@inflateBac@3
  01570	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01574	83 e8 01	 sub	 eax, 1
  01577	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0157b	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01580	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01583	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01587	0f b6 c8	 movzx	 ecx, al
  0158a	8b c2		 mov	 eax, edx
  0158c	d3 e0		 shl	 eax, cl
  0158e	8b c8		 mov	 ecx, eax
  01590	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01594	03 c1		 add	 eax, ecx
  01596	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0159a	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0159f	48 83 c0 01	 add	 rax, 1
  015a3	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  015a8	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  015ac	83 c0 08	 add	 eax, 8
  015af	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  015b3	33 c0		 xor	 eax, eax
  015b5	85 c0		 test	 eax, eax
  015b7	0f 85 71 ff ff
	ff		 jne	 $LN78@inflateBac@3
  015bd	e9 5a ff ff ff	 jmp	 $LN80@inflateBac@3
$LN79@inflateBac@3:
  015c2	33 c0		 xor	 eax, eax
  015c4	85 c0		 test	 eax, eax
  015c6	0f 85 50 ff ff
	ff		 jne	 $LN83@inflateBac@3

; 533  :                 state->length += BITS(state->extra);

  015cc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015d1	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  015d4	b8 01 00 00 00	 mov	 eax, 1
  015d9	d3 e0		 shl	 eax, cl
  015db	83 e8 01	 sub	 eax, 1
  015de	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  015e2	23 c8		 and	 ecx, eax
  015e4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015e9	03 48 48	 add	 ecx, DWORD PTR [rax+72]
  015ec	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015f1	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN70@inflateBac@3:

; 534  :                 DROPBITS(state->extra);

  015f4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015f9	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  015fc	0f b6 c8	 movzx	 ecx, al
  015ff	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01603	d3 e8		 shr	 eax, cl
  01605	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01609	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0160e	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  01611	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01615	2b c1		 sub	 eax, ecx
  01617	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0161b	33 c0		 xor	 eax, eax
  0161d	85 c0		 test	 eax, eax
  0161f	75 d3		 jne	 SHORT $LN70@inflateBac@3
$LN84@inflateBac@3:
$LN67@inflateBac@3:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  01621	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01626	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  01629	b8 01 00 00 00	 mov	 eax, 1
  0162e	d3 e0		 shl	 eax, cl
  01630	8b c8		 mov	 ecx, eax
  01632	83 e9 01	 sub	 ecx, 1
  01635	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01639	23 c1		 and	 eax, ecx
  0163b	8b c8		 mov	 ecx, eax
  0163d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01642	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01646	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01649	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  0164d	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01652	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01656	77 05		 ja	 SHORT $LN65@inflateBac@3
  01658	e9 94 00 00 00	 jmp	 $LN66@inflateBac@3
$LN65@inflateBac@3:
$LN64@inflateBac@3:
$LN61@inflateBac@3:

; 542  :                 PULLBYTE();

  0165d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01662	75 35		 jne	 SHORT $LN58@inflateBac@3
  01664	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01669	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01671	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01678	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0167c	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01681	75 16		 jne	 SHORT $LN57@inflateBac@3
  01683	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0168c	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01694	e9 26 05 00 00	 jmp	 $inf_leave$78223
$LN57@inflateBac@3:
$LN58@inflateBac@3:
  01699	33 c0		 xor	 eax, eax
  0169b	85 c0		 test	 eax, eax
  0169d	75 be		 jne	 SHORT $LN61@inflateBac@3
  0169f	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  016a3	83 e8 01	 sub	 eax, 1
  016a6	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  016aa	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  016af	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  016b2	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  016b6	0f b6 c8	 movzx	 ecx, al
  016b9	8b c2		 mov	 eax, edx
  016bb	d3 e0		 shl	 eax, cl
  016bd	8b c8		 mov	 ecx, eax
  016bf	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  016c3	03 c1		 add	 eax, ecx
  016c5	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  016c9	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  016ce	48 83 c0 01	 add	 rax, 1
  016d2	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  016d7	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  016db	83 c0 08	 add	 eax, 8
  016de	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  016e2	33 c0		 xor	 eax, eax
  016e4	85 c0		 test	 eax, eax
  016e6	0f 85 71 ff ff
	ff		 jne	 $LN64@inflateBac@3

; 543  :             }

  016ec	e9 30 ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 544  :             if ((here.op & 0xf0) == 0) {

  016f1	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  016f6	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  016fb	85 c0		 test	 eax, eax
  016fd	0f 85 21 01 00
	00		 jne	 $LN56@inflateBac@3

; 545  :                 last = here;

  01703	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  01707	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN55@inflateBac@3:

; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  0170b	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  01711	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  01716	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  0171b	03 c8		 add	 ecx, eax
  0171d	b8 01 00 00 00	 mov	 eax, 1
  01722	d3 e0		 shl	 eax, cl
  01724	83 e8 01	 sub	 eax, 1
  01727	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  0172b	23 d0		 and	 edx, eax
  0172d	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01732	0f b6 c8	 movzx	 ecx, al
  01735	8b c2		 mov	 eax, edx
  01737	d3 e8		 shr	 eax, cl
  01739	8b c8		 mov	 ecx, eax
  0173b	41 8b c0	 mov	 eax, r8d
  0173e	03 c1		 add	 eax, ecx
  01740	8b c8		 mov	 ecx, eax
  01742	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01747	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0174b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0174e	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01752	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01757	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0175c	03 c1		 add	 eax, ecx
  0175e	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01762	77 05		 ja	 SHORT $LN53@inflateBac@3
  01764	e9 94 00 00 00	 jmp	 $LN54@inflateBac@3
$LN53@inflateBac@3:
$LN52@inflateBac@3:
$LN49@inflateBac@3:

; 550  :                     PULLBYTE();

  01769	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0176e	75 35		 jne	 SHORT $LN46@inflateBac@3
  01770	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01775	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0177d	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01784	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01788	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0178d	75 16		 jne	 SHORT $LN45@inflateBac@3
  0178f	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01798	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  017a0	e9 1a 04 00 00	 jmp	 $inf_leave$78223
$LN45@inflateBac@3:
$LN46@inflateBac@3:
  017a5	33 c0		 xor	 eax, eax
  017a7	85 c0		 test	 eax, eax
  017a9	75 be		 jne	 SHORT $LN49@inflateBac@3
  017ab	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  017af	83 e8 01	 sub	 eax, 1
  017b2	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  017b6	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  017bb	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  017be	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  017c2	0f b6 c8	 movzx	 ecx, al
  017c5	8b c2		 mov	 eax, edx
  017c7	d3 e0		 shl	 eax, cl
  017c9	8b c8		 mov	 ecx, eax
  017cb	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  017cf	03 c1		 add	 eax, ecx
  017d1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  017d5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  017da	48 83 c0 01	 add	 rax, 1
  017de	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  017e3	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  017e7	83 c0 08	 add	 eax, 8
  017ea	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  017ee	33 c0		 xor	 eax, eax
  017f0	85 c0		 test	 eax, eax
  017f2	0f 85 71 ff ff
	ff		 jne	 $LN52@inflateBac@3

; 551  :                 }

  017f8	e9 0e ff ff ff	 jmp	 $LN55@inflateBac@3
$LN54@inflateBac@3:
$LN44@inflateBac@3:

; 552  :                 DROPBITS(last.bits);

  017fd	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01802	0f b6 c8	 movzx	 ecx, al
  01805	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01809	d3 e8		 shr	 eax, cl
  0180b	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0180f	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  01814	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01818	2b c1		 sub	 eax, ecx
  0181a	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0181e	33 c0		 xor	 eax, eax
  01820	85 c0		 test	 eax, eax
  01822	75 d9		 jne	 SHORT $LN44@inflateBac@3
$LN56@inflateBac@3:
$LN41@inflateBac@3:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  01824	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01829	0f b6 c8	 movzx	 ecx, al
  0182c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01830	d3 e8		 shr	 eax, cl
  01832	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01836	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0183b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0183f	2b c1		 sub	 eax, ecx
  01841	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01845	33 c0		 xor	 eax, eax
  01847	85 c0		 test	 eax, eax
  01849	75 d9		 jne	 SHORT $LN41@inflateBac@3

; 555  :             if (here.op & 64) {

  0184b	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  01850	83 e0 40	 and	 eax, 64			; 00000040H
  01853	85 c0		 test	 eax, eax
  01855	74 23		 je	 SHORT $LN38@inflateBac@3

; 556  :                 strm->msg = (char *)"invalid distance code";

  01857	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0185f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  01866	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 557  :                 state->mode = BAD;

  0186a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0186f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 558  :                 break;

  01875	e9 40 03 00 00	 jmp	 $LN342@inflateBac@3
$LN38@inflateBac@3:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  0187a	0f b7 4c 24 3e	 movzx	 ecx, WORD PTR here$[rsp+2]
  0187f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01884	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  01887	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR here$[rsp]
  0188c	83 e1 0f	 and	 ecx, 15
  0188f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01894	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 564  :             if (state->extra != 0) {

  01897	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0189c	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  018a0	0f 84 05 01 00
	00		 je	 $LN37@inflateBac@3
$LN36@inflateBac@3:
$LN33@inflateBac@3:

; 565  :                 NEEDBITS(state->extra);

  018a6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  018ab	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  018ae	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  018b2	0f 83 94 00 00
	00		 jae	 $LN32@inflateBac@3
$LN31@inflateBac@3:
$LN28@inflateBac@3:
  018b8	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  018bd	75 35		 jne	 SHORT $LN25@inflateBac@3
  018bf	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  018c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  018cc	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  018d3	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  018d7	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  018dc	75 16		 jne	 SHORT $LN24@inflateBac@3
  018de	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  018e7	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  018ef	e9 cb 02 00 00	 jmp	 $inf_leave$78223
$LN24@inflateBac@3:
$LN25@inflateBac@3:
  018f4	33 c0		 xor	 eax, eax
  018f6	85 c0		 test	 eax, eax
  018f8	75 be		 jne	 SHORT $LN28@inflateBac@3
  018fa	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  018fe	83 e8 01	 sub	 eax, 1
  01901	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01905	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0190a	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0190d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01911	0f b6 c8	 movzx	 ecx, al
  01914	8b c2		 mov	 eax, edx
  01916	d3 e0		 shl	 eax, cl
  01918	8b c8		 mov	 ecx, eax
  0191a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0191e	03 c1		 add	 eax, ecx
  01920	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01924	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01929	48 83 c0 01	 add	 rax, 1
  0192d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01932	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01936	83 c0 08	 add	 eax, 8
  01939	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0193d	33 c0		 xor	 eax, eax
  0193f	85 c0		 test	 eax, eax
  01941	0f 85 71 ff ff
	ff		 jne	 $LN31@inflateBac@3
  01947	e9 5a ff ff ff	 jmp	 $LN33@inflateBac@3
$LN32@inflateBac@3:
  0194c	33 c0		 xor	 eax, eax
  0194e	85 c0		 test	 eax, eax
  01950	0f 85 50 ff ff
	ff		 jne	 $LN36@inflateBac@3

; 566  :                 state->offset += BITS(state->extra);

  01956	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0195b	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0195e	b8 01 00 00 00	 mov	 eax, 1
  01963	d3 e0		 shl	 eax, cl
  01965	83 e8 01	 sub	 eax, 1
  01968	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0196c	23 c8		 and	 ecx, eax
  0196e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01973	03 48 4c	 add	 ecx, DWORD PTR [rax+76]
  01976	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0197b	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN23@inflateBac@3:

; 567  :                 DROPBITS(state->extra);

  0197e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01983	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01986	0f b6 c8	 movzx	 ecx, al
  01989	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0198d	d3 e8		 shr	 eax, cl
  0198f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01993	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01998	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0199b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0199f	2b c1		 sub	 eax, ecx
  019a1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  019a5	33 c0		 xor	 eax, eax
  019a7	85 c0		 test	 eax, eax
  019a9	75 d3		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  019ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  019b0	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019b5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  019b8	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  019bb	73 0d		 jae	 SHORT $LN352@inflateBac@3
  019bd	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  019c1	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv796[rsp], eax
  019c8	eb 0b		 jmp	 SHORT $LN353@inflateBac@3
$LN352@inflateBac@3:
  019ca	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv796[rsp], 0
$LN353@inflateBac@3:
  019d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  019da	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv796[rsp]
  019e1	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  019e4	2b c8		 sub	 ecx, eax
  019e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019eb	39 48 4c	 cmp	 DWORD PTR [rax+76], ecx
  019ee	76 23		 jbe	 SHORT $LN20@inflateBac@3

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  019f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  019f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  019ff	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 572  :                 state->mode = BAD;

  01a03	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a08	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 573  :                 break;

  01a0e	e9 a7 01 00 00	 jmp	 $LN342@inflateBac@3
$LN20@inflateBac@3:
$LN19@inflateBac@3:
$LN16@inflateBac@3:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  01a13	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  01a18	75 50		 jne	 SHORT $LN13@inflateBac@3
  01a1a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a1f	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  01a23	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01a28	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a2d	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01a30	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01a34	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01a39	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01a3d	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  01a40	44 8b 44 24 4c	 mov	 r8d, DWORD PTR left$[rsp]
  01a45	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  01a4a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01a52	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01a59	85 c0		 test	 eax, eax
  01a5b	74 0d		 je	 SHORT $LN12@inflateBac@3
  01a5d	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01a65	e9 55 01 00 00	 jmp	 $inf_leave$78223
$LN12@inflateBac@3:
$LN13@inflateBac@3:
  01a6a	33 c0		 xor	 eax, eax
  01a6c	85 c0		 test	 eax, eax
  01a6e	75 a3		 jne	 SHORT $LN16@inflateBac@3

; 580  :                 copy = state->wsize - state->offset;

  01a70	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  01a75	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a7a	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  01a7d	8b 42 2c	 mov	 eax, DWORD PTR [rdx+44]
  01a80	2b c1		 sub	 eax, ecx
  01a82	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 581  :                 if (copy < left) {

  01a86	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01a8a	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01a8e	73 21		 jae	 SHORT $LN11@inflateBac@3

; 582  :                     from = put + copy;

  01a90	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  01a94	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01a99	48 03 c1	 add	 rax, rcx
  01a9c	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 583  :                     copy = left - copy;

  01aa1	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  01aa5	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01aa9	2b c1		 sub	 eax, ecx
  01aab	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 584  :                 }
; 585  :                 else {

  01aaf	eb 1d		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 586  :                     from = put - state->offset;

  01ab1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ab6	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  01ab9	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01abe	48 2b c1	 sub	 rax, rcx
  01ac1	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 587  :                     copy = left;

  01ac6	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01aca	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN10@inflateBac@3:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  01ace	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ad3	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ad6	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01ada	76 0c		 jbe	 SHORT $LN9@inflateBac@3
  01adc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ae1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ae4	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN9@inflateBac@3:

; 590  :                 state->length -= copy;

  01ae8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01aed	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01af1	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01af4	2b c8		 sub	 ecx, eax
  01af6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01afb	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 591  :                 left -= copy;

  01afe	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  01b02	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01b06	2b c1		 sub	 eax, ecx
  01b08	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
$LN8@inflateBac@3:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  01b0c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01b11	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  01b16	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01b19	88 01		 mov	 BYTE PTR [rcx], al
  01b1b	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01b20	48 83 c0 01	 add	 rax, 1
  01b24	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01b29	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  01b2e	48 83 c0 01	 add	 rax, 1
  01b32	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 594  :                 } while (--copy);

  01b37	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01b3b	83 e8 01	 sub	 eax, 1
  01b3e	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
  01b42	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  01b47	75 c3		 jne	 SHORT $LN8@inflateBac@3

; 595  :             } while (state->length != 0);

  01b49	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b4e	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  01b52	0f 85 bb fe ff
	ff		 jne	 $LN19@inflateBac@3

; 596  :             break;

  01b58	eb 60		 jmp	 SHORT $LN342@inflateBac@3
$LN5@inflateBac@3:

; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;

  01b5a	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 601  :             if (left < state->wsize) {

  01b62	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b67	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01b6a	39 44 24 4c	 cmp	 DWORD PTR left$[rsp], eax
  01b6e	73 34		 jae	 SHORT $LN4@inflateBac@3

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  01b70	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01b75	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01b79	44 8b 41 2c	 mov	 r8d, DWORD PTR [rcx+44]
  01b7d	44 2b c0	 sub	 r8d, eax
  01b80	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  01b85	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  01b89	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01b91	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01b98	85 c0		 test	 eax, eax
  01b9a	74 08		 je	 SHORT $LN3@inflateBac@3

; 603  :                     ret = Z_BUF_ERROR;

  01b9c	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflateBac@3:
$LN4@inflateBac@3:

; 604  :             }
; 605  :             goto inf_leave;

  01ba4	eb 19		 jmp	 SHORT $inf_leave$78223
$LN2@inflateBac@3:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  01ba6	c7 44 24 58 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 609  :             goto inf_leave;

  01bae	eb 0f		 jmp	 SHORT $inf_leave$78223
$LN1@inflateBac@3:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  01bb0	c7 44 24 58 fe
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -2
  01bb8	eb 05		 jmp	 SHORT $inf_leave$78223
$LN342@inflateBac@3:

; 613  :             goto inf_leave;
; 614  :         }

  01bba	e9 27 e5 ff ff	 jmp	 $LN345@inflateBac@3
$inf_leave$78223:

; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  01bbf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01bc7	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01bcc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 619  :     strm->avail_in = have;

  01bcf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01bd7	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01bdb	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 620  :     return ret;

  01bde	8b 44 24 58	 mov	 eax, DWORD PTR ret$[rsp]
$LN348@inflateBac@3:

; 621  : }

  01be2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  01be9	c3		 ret	 0
  01bea	66 90		 npad	 2
$LN354@inflateBac@3:
  01bec	00 00 00 00	 DD	 $LN341@inflateBac@3
  01bf0	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bf4	00 00 00 00	 DD	 $LN311@inflateBac@3
  01bf8	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bfc	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c00	00 00 00 00	 DD	 $LN276@inflateBac@3
  01c04	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c08	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c0c	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c10	00 00 00 00	 DD	 $LN130@inflateBac@3
  01c14	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c18	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c1c	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c20	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c24	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c28	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c2c	00 00 00 00	 DD	 $LN1@inflateBac@3
  01c30	00 00 00 00	 DD	 $LN5@inflateBac@3
  01c34	00 00 00 00	 DD	 $LN2@inflateBac@3
inflateBack ENDP
END
