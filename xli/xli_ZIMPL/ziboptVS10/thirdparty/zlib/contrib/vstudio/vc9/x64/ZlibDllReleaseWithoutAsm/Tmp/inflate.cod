; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateMark
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\inflate.c
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+143
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateMark
_TEXT	SEGMENT
state$ = 0
tv77 = 8
tv76 = 12
strm$ = 32
inflateMark PROC					; COMDAT

; 1472 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateMar
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 07		 jne	 SHORT $LN2@inflateMar
$LN1@inflateMar:
  0001d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H
  00022	eb 66		 jmp	 SHORT $LN3@inflateMar
$LN2@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00029	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 38 0f	 cmp	 DWORD PTR [rax], 15
  00038	75 0d		 jne	 SHORT $LN7@inflateMar
  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00041	89 44 24 08	 mov	 DWORD PTR tv77[rsp], eax
  00045	eb 32		 jmp	 SHORT $LN8@inflateMar
$LN7@inflateMar:
  00047	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0004b	83 38 18	 cmp	 DWORD PTR [rax], 24
  0004e	75 19		 jne	 SHORT $LN5@inflateMar
  00050	48 8b 14 24	 mov	 rdx, QWORD PTR state$[rsp]
  00054	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00058	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  0005b	8b 82 e0 1b 00
	00		 mov	 eax, DWORD PTR [rdx+7136]
  00061	2b c1		 sub	 eax, ecx
  00063	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
  00067	eb 08		 jmp	 SHORT $LN6@inflateMar
$LN5@inflateMar:
  00069	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN6@inflateMar:
  00071	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
  00075	89 44 24 08	 mov	 DWORD PTR tv77[rsp], eax
$LN8@inflateMar:
  00079	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0007d	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00083	c1 e0 10	 shl	 eax, 16
  00086	03 44 24 08	 add	 eax, DWORD PTR tv77[rsp]
$LN3@inflateMar:

; 1480 : }

  0008a	48 83 c4 18	 add	 rsp, 24
  0008e	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
PUBLIC	inflateUndermine
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateUndermine
_TEXT	SEGMENT
state$ = 0
tv70 = 8
strm$ = 32
subvert$ = 40
inflateUndermine PROC					; COMDAT

; 1456 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00013	74 0c		 je	 SHORT $LN1@inflateUnd
  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001f	75 07		 jne	 SHORT $LN2@inflateUnd
$LN1@inflateUnd:
  00021	b8 fe ff ff ff	 mov	 eax, -2
  00026	eb 47		 jmp	 SHORT $LN3@inflateUnd
$LN2@inflateUnd:

; 1460 :     state = (struct inflate_state FAR *)strm->state;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00031	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1461 :     state->sane = !subvert;

  00035	83 7c 24 28 00	 cmp	 DWORD PTR subvert$[rsp], 0
  0003a	75 0a		 jne	 SHORT $LN5@inflateUnd
  0003c	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN6@inflateUnd
$LN5@inflateUnd:
  00046	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN6@inflateUnd:
  0004e	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  00052	8b 44 24 08	 mov	 eax, DWORD PTR tv70[rsp]
  00056	89 81 d8 1b 00
	00		 mov	 DWORD PTR [rcx+7128], eax

; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  0005c	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00060	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1466 :     return Z_DATA_ERROR;

  0006a	b8 fd ff ff ff	 mov	 eax, -3
$LN3@inflateUnd:

; 1467 : #endif
; 1468 : }

  0006f	48 83 c4 18	 add	 rsp, 24
  00073	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
PUBLIC	inflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN10
	DD	imagerel $LN10+575
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateCopy
_TEXT	SEGMENT
window$ = 32
wsize$ = 40
copy$ = 48
state$ = 56
dest$ = 80
source$ = 88
inflateCopy PROC					; COMDAT

; 1409 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  00014	74 2c		 je	 SHORT $LN6@inflateCop
  00016	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  0001c	74 24		 je	 SHORT $LN6@inflateCop
  0001e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 18		 je	 SHORT $LN6@inflateCop
  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  0002f	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00034	74 0c		 je	 SHORT $LN6@inflateCop
  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  0003b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00040	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1418 :         return Z_STREAM_ERROR;

  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 ee 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1419 :     state = (struct inflate_state FAR *)source->state;

  0004c	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0005a	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  0006a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0006e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00073	ff 50 30	 call	 QWORD PTR [rax+48]
  00076	48 89 44 24 30	 mov	 QWORD PTR copy$[rsp], rax

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0007b	48 83 7c 24 30
	00		 cmp	 QWORD PTR copy$[rsp], 0
  00081	75 0a		 jne	 SHORT $LN5@inflateCop
  00083	b8 fc ff ff ff	 mov	 eax, -4
  00088	e9 ad 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1425 :     window = Z_NULL;

  0008d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR window$[rsp], 0

; 1426 :     if (state->window != Z_NULL) {

  00096	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0009b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000a0	74 56		 je	 SHORT $LN4@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000a7	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000aa	ba 01 00 00 00	 mov	 edx, 1
  000af	0f b6 c8	 movzx	 ecx, al
  000b2	d3 e2		 shl	 edx, cl
  000b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  000bf	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  000c8	ff 50 30	 call	 QWORD PTR [rax+48]
  000cb	48 89 44 24 20	 mov	 QWORD PTR window$[rsp], rax

; 1429 :         if (window == Z_NULL) {

  000d0	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  000d6	75 20		 jne	 SHORT $LN3@inflateCop

; 1430 :             ZFREE(source, copy);

  000d8	48 8b 54 24 30	 mov	 rdx, QWORD PTR copy$[rsp]
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  000e2	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  000eb	ff 50 38	 call	 QWORD PTR [rax+56]

; 1431 :             return Z_MEM_ERROR;

  000ee	b8 fc ff ff ff	 mov	 eax, -4
  000f3	e9 42 01 00 00	 jmp	 $LN8@inflateCop
$LN3@inflateCop:
$LN4@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  000f8	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  000fe	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00108	e8 00 00 00 00	 call	 memcpy

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  0010d	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00113	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  00118	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  0011d	e8 00 00 00 00	 call	 memcpy

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  00122	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00127	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  0012e	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00133	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00137	72 79		 jb	 SHORT $LN2@inflateCop
  00139	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0013e	48 81 c1 d4 1b
	00 00		 add	 rcx, 7124		; 00001bd4H
  00145	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0014a	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  0014e	77 62		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00155	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  0015b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00160	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00164	48 2b c8	 sub	 rcx, rax
  00167	48 c1 f9 02	 sar	 rcx, 2
  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  00170	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  00178	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  0017d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00181	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00186	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  0018c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00191	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00195	48 2b c8	 sub	 rcx, rax
  00198	48 c1 f9 02	 sar	 rcx, 2
  0019c	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001a1	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001ae	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  001b2	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001b7	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  001bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001c2	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  001c9	48 2b c8	 sub	 rcx, rax
  001cc	48 c1 f9 02	 sar	 rcx, 2
  001d0	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001d5	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  001dd	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001e2	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1444 :     if (window != Z_NULL) {

  001e9	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  001ef	74 2b		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  001f1	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001f9	b8 01 00 00 00	 mov	 eax, 1
  001fe	d3 e0		 shl	 eax, cl
  00200	89 44 24 28	 mov	 DWORD PTR wsize$[rsp], eax

; 1446 :         zmemcpy(window, state->window, wsize);

  00204	44 8b 44 24 28	 mov	 r8d, DWORD PTR wsize$[rsp]
  00209	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  0020e	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00212	48 8b 4c 24 20	 mov	 rcx, QWORD PTR window$[rsp]
  00217	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;

  0021c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  00221	48 8b 44 24 20	 mov	 rax, QWORD PTR window$[rsp]
  00226	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1449 :     dest->state = (struct internal_state FAR *)copy;

  0022a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0022f	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  00234	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1450 :     return Z_OK;

  00238	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1451 : }

  0023a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0023e	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
PUBLIC	inflateSyncPoint
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
state$ = 0
tv71 = 8
strm$ = 32
inflateSyncPoint PROC					; COMDAT

; 1398 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateSyn
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 07		 jne	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	eb 36		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1402 :     state = (struct inflate_state FAR *)strm->state;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00029	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1403 :     return state->mode == STORED && state->bits == 0;

  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00038	75 14		 jne	 SHORT $LN5@inflateSyn
  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00042	75 0a		 jne	 SHORT $LN5@inflateSyn
  00044	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0004c	eb 08		 jmp	 SHORT $LN6@inflateSyn
$LN5@inflateSyn:
  0004e	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN6@inflateSyn:
  00056	8b 44 24 08	 mov	 eax, DWORD PTR tv71[rsp]
$LN3@inflateSyn:

; 1404 : }

  0005a	48 83 c4 18	 add	 rsp, 24
  0005e	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+178
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT syncsearch
_TEXT	SEGMENT
next$ = 0
got$ = 4
tv70 = 8
have$ = 32
buf$ = 40
len$ = 48
syncsearch PROC						; COMDAT

; 1326 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR have$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax

; 1331 :     next = 0;

  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR next$[rsp], 0
$LN6@syncsearch:

; 1332 :     while (next < len && got < 4) {

  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR next$[rsp], eax
  0002c	73 71		 jae	 SHORT $LN5@syncsearch
  0002e	83 7c 24 04 04	 cmp	 DWORD PTR got$[rsp], 4
  00033	73 6a		 jae	 SHORT $LN5@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00035	83 7c 24 04 02	 cmp	 DWORD PTR got$[rsp], 2
  0003a	73 0a		 jae	 SHORT $LN9@syncsearch
  0003c	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00044	eb 08		 jmp	 SHORT $LN10@syncsearch
$LN9@syncsearch:
  00046	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR tv70[rsp], 255 ; 000000ffH
$LN10@syncsearch:
  0004e	8b 0c 24	 mov	 ecx, DWORD PTR next$[rsp]
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00056	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0005a	3b 44 24 08	 cmp	 eax, DWORD PTR tv70[rsp]
  0005e	75 0d		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00060	8b 44 24 04	 mov	 eax, DWORD PTR got$[rsp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
  0006b	eb 27		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  0006d	8b 0c 24	 mov	 ecx, DWORD PTR next$[rsp]
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00075	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00079	85 c0		 test	 eax, eax
  0007b	74 0a		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  0007d	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0

; 1337 :         else

  00085	eb 0d		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  00087	b8 04 00 00 00	 mov	 eax, 4
  0008c	2b 44 24 04	 sub	 eax, DWORD PTR got$[rsp]
  00090	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
$LN1@syncsearch:
$LN3@syncsearch:

; 1339 :         next++;

  00094	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]
  00097	83 c0 01	 add	 eax, 1
  0009a	89 04 24	 mov	 DWORD PTR next$[rsp], eax

; 1340 :     }

  0009d	eb 86		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1341 :     *have = got;

  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR have$[rsp]
  000a4	8b 44 24 04	 mov	 eax, DWORD PTR got$[rsp]
  000a8	89 01		 mov	 DWORD PTR [rcx], eax

; 1342 :     return next;

  000aa	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]

; 1343 : }

  000ad	48 83 c4 18	 add	 rsp, 24
  000b1	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
PUBLIC	inflateGetHeader
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
state$ = 0
strm$ = 32
head$ = 40
inflateGetHeader PROC					; COMDAT

; 1297 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000e	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00014	74 0c		 je	 SHORT $LN2@inflateGet
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00020	75 07		 jne	 SHORT $LN3@inflateGet
$LN2@inflateGet:
  00022	b8 fe ff ff ff	 mov	 eax, -2
  00027	eb 3d		 jmp	 SHORT $LN4@inflateGet
$LN3@inflateGet:

; 1302 :     state = (struct inflate_state FAR *)strm->state;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00032	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	83 e0 02	 and	 eax, 2
  00040	85 c0		 test	 eax, eax
  00042	75 07		 jne	 SHORT $LN1@inflateGet
  00044	b8 fe ff ff ff	 mov	 eax, -2
  00049	eb 1b		 jmp	 SHORT $LN4@inflateGet
$LN1@inflateGet:

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  0004b	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00054	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1307 :     head->done = 0;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  0005d	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1308 :     return Z_OK;

  00064	33 c0		 xor	 eax, eax
$LN4@inflateGet:

; 1309 : }

  00066	48 83 c4 18	 add	 rsp, 24
  0006a	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateEnd
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateEnd PROC						; COMDAT

; 1240 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN2@inflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN2@inflateEnd
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 5d		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1244 :     state = (struct inflate_state FAR *)strm->state;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00039	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	74 1a		 je	 SHORT $LN1@inflateEnd
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  0004f	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00058	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00061	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  00064	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00069	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00072	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	ff 50 38	 call	 QWORD PTR [rax+56]

; 1247 :     strm->state = Z_NULL;

  0007e	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  00083	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  0008b	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1250 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+550
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT updatewindow
_TEXT	SEGMENT
dist$ = 32
copy$ = 36
state$ = 40
strm$ = 64
out$ = 72
updatewindow PROC					; COMDAT

; 361  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00012	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00016	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00025	75 4b		 jne	 SHORT $LN10@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0002c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	0f b6 c8	 movzx	 ecx, al
  00037	d3 e2		 shl	 edx, cl
  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00044	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0004d	ff 50 30	 call	 QWORD PTR [rax+48]
  00050	4c 8b d8	 mov	 r11, rax
  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00058	4c 89 58 38	 mov	 QWORD PTR [rax+56], r11

; 372  :         if (state->window == Z_NULL) return 1;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00061	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00066	75 0a		 jne	 SHORT $LN9@updatewind
  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	e9 af 01 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
$LN10@updatewind:

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00077	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0007b	75 31		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00082	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	d3 e0		 shl	 eax, cl
  0008c	8b c8		 mov	 ecx, eax
  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00093	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 378  :         state->wnext = 0;

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009b	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 379  :         state->whave = 0;

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000a7	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN8@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000b6	8b 44 24 48	 mov	 eax, DWORD PTR out$[rsp]
  000ba	2b c1		 sub	 eax, ecx
  000bc	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 384  :     if (copy >= state->wsize) {

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000c8	39 44 24 24	 cmp	 DWORD PTR copy$[rsp], eax
  000cc	72 4d		 jb	 SHORT $LN7@updatewind

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d3	44 8b 40 2c	 mov	 r8d, DWORD PTR [rax+44]
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000dc	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000df	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000e4	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000e8	48 2b d0	 sub	 rdx, rax
  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000f0	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000f4	e8 00 00 00 00	 call	 memcpy

; 386  :         state->wnext = 0;

  000f9	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  000fe	41 c7 43 34 00
	00 00 00	 mov	 DWORD PTR [r11+52], 0

; 387  :         state->whave = state->wsize;

  00106	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00110	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00113	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 388  :     }
; 389  :     else {

  00116	e9 04 01 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 390  :         dist = state->wsize - state->wnext;

  0011b	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00120	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00125	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00128	8b 42 2c	 mov	 eax, DWORD PTR [rdx+44]
  0012b	2b c1		 sub	 eax, ecx
  0012d	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 391  :         if (dist > copy) dist = copy;

  00131	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  00135	39 44 24 20	 cmp	 DWORD PTR dist$[rsp], eax
  00139	76 08		 jbe	 SHORT $LN5@updatewind
  0013b	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0013f	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax
$LN5@updatewind:

; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  00143	44 8b 44 24 20	 mov	 r8d, DWORD PTR dist$[rsp]
  00148	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0014c	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00151	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00155	48 2b d0	 sub	 rdx, rax
  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0015d	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00165	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  00169	e8 00 00 00 00	 call	 memcpy

; 393  :         copy -= dist;

  0016e	44 8b 5c 24 20	 mov	 r11d, DWORD PTR dist$[rsp]
  00173	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  00177	41 2b c3	 sub	 eax, r11d
  0017a	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 394  :         if (copy) {

  0017e	83 7c 24 24 00	 cmp	 DWORD PTR copy$[rsp], 0
  00183	74 42		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  00185	44 8b 44 24 24	 mov	 r8d, DWORD PTR copy$[rsp]
  0018a	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0018e	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00193	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00197	48 2b d0	 sub	 rdx, rax
  0019a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0019f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001a3	e8 00 00 00 00	 call	 memcpy

; 396  :             state->wnext = copy;

  001a8	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  001ad	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  001b1	41 89 43 34	 mov	 DWORD PTR [r11+52], eax

; 397  :             state->whave = state->wsize;

  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001bf	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  001c2	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 398  :         }
; 399  :         else {

  001c5	eb 58		 jmp	 SHORT $LN3@updatewind
$LN4@updatewind:

; 400  :             state->wnext += dist;

  001c7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001cc	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  001cf	03 4c 24 20	 add	 ecx, DWORD PTR dist$[rsp]
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001d8	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  001db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001e5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  001e8	39 41 34	 cmp	 DWORD PTR [rcx+52], eax
  001eb	75 0c		 jne	 SHORT $LN2@updatewind
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001f2	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0
$LN2@updatewind:

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  001f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001fe	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00203	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00206	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  00209	73 14		 jae	 SHORT $LN1@updatewind
  0020b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00210	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00213	03 4c 24 20	 add	 ecx, DWORD PTR dist$[rsp]
  00217	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0021c	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN1@updatewind:
$LN3@updatewind:
$LN6@updatewind:

; 403  :         }
; 404  :     }
; 405  :     return 0;

  0021f	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 406  : }

  00221	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00225	c3		 ret	 0
updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 242  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00005	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 278  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 279  :     state->distcode = distfix;

  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 280  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 281  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflatePrime
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN8
	DD	imagerel $LN8+207
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflatePrime
_TEXT	SEGMENT
state$ = 0
strm$ = 32
bits$ = 40
value$ = 48
inflatePrime PROC					; COMDAT

; 213  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00012	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00018	74 0c		 je	 SHORT $LN4@inflatePri
  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00024	75 0a		 jne	 SHORT $LN5@inflatePri
$LN4@inflatePri:
  00026	b8 fe ff ff ff	 mov	 eax, -2
  0002b	e9 9a 00 00 00	 jmp	 $LN6@inflatePri
$LN5@inflatePri:

; 217  :     state = (struct inflate_state FAR *)strm->state;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00039	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 218  :     if (bits < 0) {

  0003d	83 7c 24 28 00	 cmp	 DWORD PTR bits$[rsp], 0
  00042	7d 1a		 jge	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00044	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00048	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 220  :         state->bits = 0;

  0004f	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00053	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 221  :         return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 6c		 jmp	 SHORT $LN6@inflatePri
$LN3@inflatePri:

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0005e	83 7c 24 28 10	 cmp	 DWORD PTR bits$[rsp], 16
  00063	7f 10		 jg	 SHORT $LN1@inflatePri
  00065	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00069	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0006c	03 44 24 28	 add	 eax, DWORD PTR bits$[rsp]
  00070	83 f8 20	 cmp	 eax, 32			; 00000020H
  00073	76 07		 jbe	 SHORT $LN2@inflatePri
$LN1@inflatePri:
  00075	b8 fe ff ff ff	 mov	 eax, -2
  0007a	eb 4e		 jmp	 SHORT $LN6@inflatePri
$LN2@inflatePri:

; 224  :     value &= (1L << bits) - 1;

  0007c	8b 4c 24 28	 mov	 ecx, DWORD PTR bits$[rsp]
  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	d3 e0		 shl	 eax, cl
  00087	8b c8		 mov	 ecx, eax
  00089	83 e9 01	 sub	 ecx, 1
  0008c	8b 44 24 30	 mov	 eax, DWORD PTR value$[rsp]
  00090	23 c1		 and	 eax, ecx
  00092	89 44 24 30	 mov	 DWORD PTR value$[rsp], eax

; 225  :     state->hold += value << state->bits;

  00096	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0009a	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0009d	0f b6 c8	 movzx	 ecx, al
  000a0	8b 44 24 30	 mov	 eax, DWORD PTR value$[rsp]
  000a4	d3 e0		 shl	 eax, cl
  000a6	8b c8		 mov	 ecx, eax
  000a8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ac	03 48 40	 add	 ecx, DWORD PTR [rax+64]
  000af	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000b3	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 226  :     state->bits += bits;

  000b6	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ba	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  000bd	03 4c 24 28	 add	 ecx, DWORD PTR bits$[rsp]
  000c1	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000c5	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 227  :     return Z_OK;

  000c8	33 c0		 xor	 eax, eax
$LN6@inflatePri:

; 228  : }

  000ca	48 83 c4 18	 add	 rsp, 24
  000ce	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+314
	DD	imagerel $unwind$inflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateReset
_TEXT	SEGMENT
state$ = 0
strm$ = 32
inflateReset PROC					; COMDAT

; 105  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateRes
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN2@inflateRes
$LN1@inflateRes:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 0e 01 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 109  :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00038	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 111  :     strm->msg = Z_NULL;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1

; 113  :     state->mode = HEAD;

  00070	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 114  :     state->last = 0;

  0007a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 115  :     state->havedict = 0;

  00085	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 116  :     state->dmax = 32768U;

  00090	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00094	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 117  :     state->head = Z_NULL;

  0009b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0009f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 118  :     state->wsize = 0;

  000a7	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ab	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 119  :     state->whave = 0;

  000b2	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000b6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 120  :     state->wnext = 0;

  000bd	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000c1	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 121  :     state->hold = 0;

  000c8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000cc	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 122  :     state->bits = 0;

  000d3	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000d7	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 123  :     state->lencode = state->distcode = state->next = state->codes;

  000de	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000e2	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  000e9	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ed	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  000f4	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000f8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000fc	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00103	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  00107	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0010f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00113	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 124  :     state->sane = 1;

  00117	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0011b	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 125  :     state->back = -1;

  00125	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00129	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1

; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  00133	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 128  : }

  00135	48 83 c4 18	 add	 rsp, 24
  00139	c3		 ret	 0
inflateReset ENDP
PUBLIC	inflateSync
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN10
	DD	imagerel $LN10+485
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSync
_TEXT	SEGMENT
in$ = 32
len$ = 36
buf$ = 40
out$ = 44
state$ = 48
strm$ = 80
inflateSync PROC					; COMDAT

; 1347 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@inflateSyn@2
  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@inflateSyn@2
$LN6@inflateSyn@2:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 b9 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN7@inflateSyn@2:

; 1355 :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0003e	75 15		 jne	 SHORT $LN5@inflateSyn@2
  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00045	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  00049	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0004b	b8 fb ff ff ff	 mov	 eax, -5
  00050	e9 8b 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN5@inflateSyn@2:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005a	83 38 1f	 cmp	 DWORD PTR [rax], 31
  0005d	0f 84 c2 00 00
	00		 je	 $LN4@inflateSyn@2

; 1360 :         state->mode = SYNC;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00068	c7 00 1f 00 00
	00		 mov	 DWORD PTR [rax], 31

; 1361 :         state->hold <<= state->bits & 7;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00073	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00076	83 e1 07	 and	 ecx, 7
  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0007e	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00081	d3 e0		 shl	 eax, cl
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0008a	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 1362 :         state->bits -= state->bits & 7;

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00092	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  00095	83 e2 07	 and	 edx, 7
  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009d	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  000a0	2b ca		 sub	 ecx, edx
  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000a7	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 1363 :         len = 0;

  000aa	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN3@inflateSyn@2:

; 1364 :         while (state->bits >= 8) {

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b7	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  000bb	72 44		 jb	 SHORT $LN2@inflateSyn@2

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  000bd	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c6	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  000ca	88 44 0c 28	 mov	 BYTE PTR buf$[rsp+rcx], al
  000ce	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1366 :             state->hold >>= 8;

  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000de	8b 48 40	 mov	 ecx, DWORD PTR [rax+64]
  000e1	c1 e9 08	 shr	 ecx, 8
  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e9	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 1367 :             state->bits -= 8;

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000f1	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  000f4	83 e9 08	 sub	 ecx, 8
  000f7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000fc	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 1368 :         }

  000ff	eb b1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1369 :         state->have = 0;

  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00106	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 1370 :         syncsearch(&(state->have), buf, len);

  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00112	48 83 c1 7c	 add	 rcx, 124		; 0000007cH
  00116	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  0011b	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  00120	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn@2:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00125	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0012a	48 83 c1 7c	 add	 rcx, 124		; 0000007cH
  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00133	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  00137	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  0013c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0013f	e8 00 00 00 00	 call	 syncsearch
  00144	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1375 :     strm->avail_in -= len;

  00148	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0014d	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00151	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00154	2b c8		 sub	 ecx, eax
  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0015b	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1376 :     strm->next_in += len;

  0015e	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  00162	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00167	48 03 08	 add	 rcx, QWORD PTR [rax]
  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0016f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1377 :     strm->total_in += len;

  00172	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00177	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0017a	03 4c 24 24	 add	 ecx, DWORD PTR len$[rsp]
  0017e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00183	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0018b	83 78 7c 04	 cmp	 DWORD PTR [rax+124], 4
  0018f	74 07		 je	 SHORT $LN1@inflateSyn@2
  00191	b8 fd ff ff ff	 mov	 eax, -3
  00196	eb 48		 jmp	 SHORT $LN8@inflateSyn@2
$LN1@inflateSyn@2:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0019d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001a0	89 44 24 20	 mov	 DWORD PTR in$[rsp], eax
  001a4	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001a9	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  001ac	89 44 24 2c	 mov	 DWORD PTR out$[rsp], eax

; 1382 :     inflateReset(strm);

  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001b5	e8 00 00 00 00	 call	 inflateReset

; 1383 :     strm->total_in = in;  strm->total_out = out;

  001ba	4c 8b 5c 24 50	 mov	 r11, QWORD PTR strm$[rsp]
  001bf	8b 44 24 20	 mov	 eax, DWORD PTR in$[rsp]
  001c3	41 89 43 0c	 mov	 DWORD PTR [r11+12], eax
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001cc	8b 44 24 2c	 mov	 eax, DWORD PTR out$[rsp]
  001d0	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1384 :     state->mode = TYPE;

  001d3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001d8	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 1385 :     return Z_OK;

  001de	33 c0		 xor	 eax, eax
$LN8@inflateSyn@2:

; 1386 : }

  001e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e4	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
PUBLIC	inflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN11
	DD	imagerel $LN11+363
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
id$ = 32
state$ = 40
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateSetDictionary PROC				; COMDAT

; 1256 : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 0c		 je	 SHORT $LN7@inflateSet
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00020	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00025	75 0a		 jne	 SHORT $LN8@inflateSet
$LN7@inflateSet:
  00027	b8 fe ff ff ff	 mov	 eax, -2
  0002c	e9 35 01 00 00	 jmp	 $LN9@inflateSet
$LN8@inflateSet:

; 1262 :     state = (struct inflate_state FAR *)strm->state;

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00044	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00048	74 14		 je	 SHORT $LN6@inflateSet
  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004f	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00052	74 0a		 je	 SHORT $LN6@inflateSet

; 1264 :         return Z_STREAM_ERROR;

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 08 01 00 00	 jmp	 $LN9@inflateSet
$LN6@inflateSet:

; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00063	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00066	75 3f		 jne	 SHORT $LN5@inflateSet

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00068	45 33 c0	 xor	 r8d, r8d
  0006b	33 d2		 xor	 edx, edx
  0006d	33 c9		 xor	 ecx, ecx
  0006f	e8 00 00 00 00	 call	 adler32
  00074	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1269 :         id = adler32(id, dictionary, dictLength);

  00078	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  0007d	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00082	8b 4c 24 20	 mov	 ecx, DWORD PTR id$[rsp]
  00086	e8 00 00 00 00	 call	 adler32
  0008b	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1270 :         if (id != state->check)

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	39 44 24 20	 cmp	 DWORD PTR id$[rsp], eax
  0009b	74 0a		 je	 SHORT $LN4@inflateSet

; 1271 :             return Z_DATA_ERROR;

  0009d	b8 fd ff ff ff	 mov	 eax, -3
  000a2	e9 bf 00 00 00	 jmp	 $LN9@inflateSet
$LN4@inflateSet:
$LN5@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ac	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b4	e8 00 00 00 00	 call	 updatewindow
  000b9	85 c0		 test	 eax, eax
  000bb	74 15		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c2	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30

; 1277 :         return Z_MEM_ERROR;

  000c8	b8 fc ff ff ff	 mov	 eax, -4
  000cd	e9 94 00 00 00	 jmp	 $LN9@inflateSet
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d7	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000da	39 44 24 50	 cmp	 DWORD PTR dictLength$[rsp], eax
  000de	76 41		 jbe	 SHORT $LN2@inflateSet

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e5	44 8b 40 2c	 mov	 r8d, DWORD PTR [rax+44]
  000e9	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  000ed	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000f2	48 03 d0	 add	 rdx, rax
  000f5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000fa	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000fd	48 2b d0	 sub	 rdx, rax
  00100	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00105	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00109	e8 00 00 00 00	 call	 memcpy

; 1282 :         state->whave = state->wsize;

  0010e	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00118	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0011b	41 89 43 30	 mov	 DWORD PTR [r11+48], eax

; 1283 :     }
; 1284 :     else {

  0011f	eb 37		 jmp	 SHORT $LN1@inflateSet
$LN2@inflateSet:

; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  00121	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0012b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0012e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00133	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00137	48 03 c8	 add	 rcx, rax
  0013a	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  0013e	48 2b c8	 sub	 rcx, rax
  00141	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00146	e8 00 00 00 00	 call	 memcpy

; 1287 :         state->whave = dictLength;

  0014b	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  00150	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  00154	41 89 43 30	 mov	 DWORD PTR [r11+48], eax
$LN1@inflateSet:

; 1288 :     }
; 1289 :     state->havedict = 1;

  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0015d	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  00164	33 c0		 xor	 eax, eax
$LN9@inflateSet:

; 1292 : }

  00166	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016a	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	inflate
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN527
	DD	imagerel $LN527+12332
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 021001H
	DD	0170110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflate
_TEXT	SEGMENT
put$ = 48
last$ = 56
here$ = 60
have$ = 64
in$ = 68
len$ = 72
bits$ = 76
left$ = 80
next$ = 88
ret$ = 96
hold$ = 100
hbuf$ = 104
copy$ = 108
from$ = 112
out$ = 120
state$ = 128
tv80 = 136
tv185 = 140
tv351 = 144
tv565 = 148
tv1266 = 152
tv1280 = 156
tv1355 = 160
tv1360 = 164
tv1363 = 168
tv1367 = 172
strm$ = 192
flush$ = 200
inflate	PROC						; COMDAT

; 592  : {

$LN527:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00010	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 3a		 je	 SHORT $LN506@inflate
  0001b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 2b		 je	 SHORT $LN506@inflate
  0002a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00032	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00037	74 1c		 je	 SHORT $LN506@inflate
  00039	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	75 18		 jne	 SHORT $LN507@inflate
  00047	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00053	74 0a		 je	 SHORT $LN507@inflate
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2
  0005a	e9 49 2f 00 00	 jmp	 $LN508@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;

  0005f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR state$[rsp], rax

; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00073	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0007b	83 38 0b	 cmp	 DWORD PTR [rax], 11
  0007e	75 0e		 jne	 SHORT $LN505@inflate
  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00088	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12
$LN505@inflate:
$LN504@inflate:

; 618  :     LOAD();

  0008e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00096	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009a	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0009f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000aa	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax
  000ae	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  000be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  000cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000d5	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000d8	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  000dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000e4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000e7	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	75 9d		 jne	 SHORT $LN504@inflate

; 619  :     in = have;

  000f1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  000f5	89 44 24 44	 mov	 DWORD PTR in$[rsp], eax

; 620  :     out = left;

  000f9	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  000fd	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 621  :     ret = Z_OK;

  00101	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN501@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00109	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00111	8b 00		 mov	 eax, DWORD PTR [rax]
  00113	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
  0011a	83 bc 24 88 00
	00 00 1e	 cmp	 DWORD PTR tv80[rsp], 30
  00122	0f 87 bb 2b 00
	00		 ja	 $LN11@inflate
  00128	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv80[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00137	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN526@inflate[rcx+rax*4]
  0013e	48 03 c1	 add	 rax, rcx
  00141	ff e0		 jmp	 rax
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0014b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0014f	75 13		 jne	 SHORT $LN496@inflate

; 626  :                 state->mode = TYPEDO;

  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00159	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 627  :                 break;

  0015f	e9 89 2b 00 00	 jmp	 $LN498@inflate
$LN496@inflate:
$LN495@inflate:
$LN492@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  00164	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00169	73 57		 jae	 SHORT $LN491@inflate
$LN490@inflate:
  0016b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00170	75 05		 jne	 SHORT $LN487@inflate
  00172	e9 7b 2b 00 00	 jmp	 $inf_leave$78295
$LN487@inflate:
  00177	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0017b	83 e8 01	 sub	 eax, 1
  0017e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00182	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00187	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0018a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0018e	0f b6 c8	 movzx	 ecx, al
  00191	8b c2		 mov	 eax, edx
  00193	d3 e0		 shl	 eax, cl
  00195	8b c8		 mov	 ecx, eax
  00197	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0019b	03 c1		 add	 eax, ecx
  0019d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  001a1	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  001a6	48 83 c0 01	 add	 rax, 1
  001aa	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  001af	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  001b3	83 c0 08	 add	 eax, 8
  001b6	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  001ba	33 c0		 xor	 eax, eax
  001bc	85 c0		 test	 eax, eax
  001be	75 ab		 jne	 SHORT $LN490@inflate
  001c0	eb a2		 jmp	 SHORT $LN492@inflate
$LN491@inflate:
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 9c		 jne	 SHORT $LN495@inflate

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  001c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001d0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001d3	83 e0 02	 and	 eax, 2
  001d6	85 c0		 test	 eax, eax
  001d8	0f 84 96 00 00
	00		 je	 $LN486@inflate
  001de	81 7c 24 64 1f
	8b 00 00	 cmp	 DWORD PTR hold$[rsp], 35615 ; 00008b1fH
  001e6	0f 85 88 00 00
	00		 jne	 $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  001ec	45 33 c0	 xor	 r8d, r8d
  001ef	33 d2		 xor	 edx, edx
  001f1	33 c9		 xor	 ecx, ecx
  001f3	e8 00 00 00 00	 call	 crc32
  001f8	44 8b d8	 mov	 r11d, eax
  001fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00203	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN485@inflate:

; 633  :                 CRC2(state->check, hold);

  00207	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  0020c	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00210	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00214	c1 e8 08	 shr	 eax, 8
  00217	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  0021b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00221	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0022e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00231	e8 00 00 00 00	 call	 crc32
  00236	44 8b d8	 mov	 r11d, eax
  00239	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00241	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	75 bc		 jne	 SHORT $LN485@inflate
$LN482@inflate:

; 634  :                 INITBITS();

  0024b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00253	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  0025b	33 c0		 xor	 eax, eax
  0025d	85 c0		 test	 eax, eax
  0025f	75 ea		 jne	 SHORT $LN482@inflate

; 635  :                 state->mode = FLAGS;

  00261	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00269	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 636  :                 break;

  0026f	e9 79 2a 00 00	 jmp	 $LN498@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */

  00274	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0027c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 639  :             if (state->head != Z_NULL)

  00283	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0028b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00290	74 13		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  00292	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0029a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0029e	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  002a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002ad	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002b0	83 e0 01	 and	 eax, 1
  002b3	85 c0		 test	 eax, eax
  002b5	74 22		 je	 SHORT $LN477@inflate
  002b7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  002bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c0	c1 e0 08	 shl	 eax, 8
  002c3	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  002c7	c1 e9 08	 shr	 ecx, 8
  002ca	03 c1		 add	 eax, ecx
  002cc	33 d2		 xor	 edx, edx
  002ce	b9 1f 00 00 00	 mov	 ecx, 31
  002d3	f7 f1		 div	 ecx
  002d5	85 d2		 test	 edx, edx
  002d7	74 26		 je	 SHORT $LN478@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  002d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  002e8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 647  :                 state->mode = BAD;

  002ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002f4	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 648  :                 break;

  002fa	e9 ee 29 00 00	 jmp	 $LN498@inflate
$LN478@inflate:

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  002ff	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00303	83 e0 0f	 and	 eax, 15
  00306	83 f8 08	 cmp	 eax, 8
  00309	74 26		 je	 SHORT $LN476@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  0030b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00313	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0031a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 652  :                 state->mode = BAD;

  0031e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00326	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 653  :                 break;

  0032c	e9 bc 29 00 00	 jmp	 $LN498@inflate
$LN476@inflate:
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);

  00331	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00335	c1 e8 04	 shr	 eax, 4
  00338	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0033c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00340	83 e8 04	 sub	 eax, 4
  00343	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00347	33 c0		 xor	 eax, eax
  00349	85 c0		 test	 eax, eax
  0034b	75 e4		 jne	 SHORT $LN475@inflate

; 656  :             len = BITS(4) + 8;

  0034d	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00351	83 e0 0f	 and	 eax, 15
  00354	83 c0 08	 add	 eax, 8
  00357	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 657  :             if (state->wbits == 0)

  0035b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00363	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00367	75 11		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  00369	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00371	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  00375	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00378	eb 37		 jmp	 SHORT $LN471@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  0037a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00382	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00385	39 44 24 48	 cmp	 DWORD PTR len$[rsp], eax
  00389	76 26		 jbe	 SHORT $LN470@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  0038b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00393	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0039a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 661  :                 state->mode = BAD;

  0039e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003a6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 662  :                 break;

  003ac	e9 3c 29 00 00	 jmp	 $LN498@inflate
$LN470@inflate:
$LN471@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  003b1	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  003b5	b8 01 00 00 00	 mov	 eax, 1
  003ba	d3 e0		 shl	 eax, cl
  003bc	8b c8		 mov	 ecx, eax
  003be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003c6	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  003c9	45 33 c0	 xor	 r8d, r8d
  003cc	33 d2		 xor	 edx, edx
  003ce	33 c9		 xor	 ecx, ecx
  003d0	e8 00 00 00 00	 call	 adler32
  003d5	44 8b d8	 mov	 r11d, eax
  003d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003e0	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  003e4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003f4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003f7	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  003fa	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  003fe	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00403	85 c0		 test	 eax, eax
  00405	74 0d		 je	 SHORT $LN510@inflate
  00407	c7 84 24 8c 00
	00 00 09 00 00
	00		 mov	 DWORD PTR tv185[rsp], 9
  00412	eb 0b		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  00414	c7 84 24 8c 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv185[rsp], 11
$LN511@inflate:
  0041f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00427	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv185[rsp]
  0042e	89 01		 mov	 DWORD PTR [rcx], eax
$LN469@inflate:

; 668  :             INITBITS();

  00430	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00438	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00440	33 c0		 xor	 eax, eax
  00442	85 c0		 test	 eax, eax
  00444	75 ea		 jne	 SHORT $LN469@inflate

; 669  :             break;

  00446	e9 a2 28 00 00	 jmp	 $LN498@inflate
$LN466@inflate:
$LN465@inflate:
$LN462@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  0044b	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00450	73 57		 jae	 SHORT $LN461@inflate
$LN460@inflate:
  00452	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00457	75 05		 jne	 SHORT $LN457@inflate
  00459	e9 94 28 00 00	 jmp	 $inf_leave$78295
$LN457@inflate:
  0045e	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00462	83 e8 01	 sub	 eax, 1
  00465	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00469	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0046e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00471	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00475	0f b6 c8	 movzx	 ecx, al
  00478	8b c2		 mov	 eax, edx
  0047a	d3 e0		 shl	 eax, cl
  0047c	8b c8		 mov	 ecx, eax
  0047e	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00482	03 c1		 add	 eax, ecx
  00484	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00488	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0048d	48 83 c0 01	 add	 rax, 1
  00491	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00496	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0049a	83 c0 08	 add	 eax, 8
  0049d	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  004a1	33 c0		 xor	 eax, eax
  004a3	85 c0		 test	 eax, eax
  004a5	75 ab		 jne	 SHORT $LN460@inflate
  004a7	eb a2		 jmp	 SHORT $LN462@inflate
$LN461@inflate:
  004a9	33 c0		 xor	 eax, eax
  004ab	85 c0		 test	 eax, eax
  004ad	75 9c		 jne	 SHORT $LN465@inflate

; 673  :             state->flags = (int)(hold);

  004af	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  004b7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  004bb	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  004be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004c6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  004c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004ce	83 f8 08	 cmp	 eax, 8
  004d1	74 26		 je	 SHORT $LN456@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  004d3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  004db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  004e2	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 676  :                 state->mode = BAD;

  004e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004ee	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 677  :                 break;

  004f4	e9 f4 27 00 00	 jmp	 $LN498@inflate
$LN456@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  004f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00501	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00504	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00509	85 c0		 test	 eax, eax
  0050b	74 26		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0050d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00515	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0051c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 681  :                 state->mode = BAD;

  00520	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00528	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 682  :                 break;

  0052e	e9 ba 27 00 00	 jmp	 $LN498@inflate
$LN455@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00533	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0053b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00540	74 18		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  00542	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00546	c1 e9 08	 shr	 ecx, 8
  00549	83 e1 01	 and	 ecx, 1
  0054c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00554	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00558	89 08		 mov	 DWORD PTR [rax], ecx
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0055a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00562	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00565	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0056a	85 c0		 test	 eax, eax
  0056c	74 44		 je	 SHORT $LN453@inflate
$LN452@inflate:
  0056e	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  00573	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00577	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0057b	c1 e8 08	 shr	 eax, 8
  0057e	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  00582	41 b8 02 00 00
	00		 mov	 r8d, 2
  00588	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0058d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00595	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00598	e8 00 00 00 00	 call	 crc32
  0059d	44 8b d8	 mov	 r11d, eax
  005a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005a8	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  005ac	33 c0		 xor	 eax, eax
  005ae	85 c0		 test	 eax, eax
  005b0	75 bc		 jne	 SHORT $LN452@inflate
$LN453@inflate:
$LN449@inflate:

; 687  :             INITBITS();

  005b2	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  005ba	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  005c2	33 c0		 xor	 eax, eax
  005c4	85 c0		 test	 eax, eax
  005c6	75 ea		 jne	 SHORT $LN449@inflate

; 688  :             state->mode = TIME;

  005c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005d0	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN446@inflate:
$LN445@inflate:
$LN442@inflate:

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  005d6	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  005db	73 57		 jae	 SHORT $LN441@inflate
$LN440@inflate:
  005dd	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  005e2	75 05		 jne	 SHORT $LN437@inflate
  005e4	e9 09 27 00 00	 jmp	 $inf_leave$78295
$LN437@inflate:
  005e9	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  005ed	83 e8 01	 sub	 eax, 1
  005f0	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  005f4	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  005f9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  005fc	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00600	0f b6 c8	 movzx	 ecx, al
  00603	8b c2		 mov	 eax, edx
  00605	d3 e0		 shl	 eax, cl
  00607	8b c8		 mov	 ecx, eax
  00609	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0060d	03 c1		 add	 eax, ecx
  0060f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00613	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00618	48 83 c0 01	 add	 rax, 1
  0061c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00621	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00625	83 c0 08	 add	 eax, 8
  00628	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0062c	33 c0		 xor	 eax, eax
  0062e	85 c0		 test	 eax, eax
  00630	75 ab		 jne	 SHORT $LN440@inflate
  00632	eb a2		 jmp	 SHORT $LN442@inflate
$LN441@inflate:
  00634	33 c0		 xor	 eax, eax
  00636	85 c0		 test	 eax, eax
  00638	75 9c		 jne	 SHORT $LN445@inflate

; 691  :             if (state->head != Z_NULL)

  0063a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00642	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00647	74 13		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  00649	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00651	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00655	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00659	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0065c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00664	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00667	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0066c	85 c0		 test	 eax, eax
  0066e	74 5a		 je	 SHORT $LN435@inflate
$LN434@inflate:
  00670	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  00675	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00679	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0067d	c1 e8 08	 shr	 eax, 8
  00680	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  00684	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00688	c1 e8 10	 shr	 eax, 16
  0068b	88 44 24 6a	 mov	 BYTE PTR hbuf$[rsp+2], al
  0068f	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00693	c1 e8 18	 shr	 eax, 24
  00696	88 44 24 6b	 mov	 BYTE PTR hbuf$[rsp+3], al
  0069a	41 b8 04 00 00
	00		 mov	 r8d, 4
  006a0	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  006a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006ad	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  006b0	e8 00 00 00 00	 call	 crc32
  006b5	44 8b d8	 mov	 r11d, eax
  006b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006c0	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  006c4	33 c0		 xor	 eax, eax
  006c6	85 c0		 test	 eax, eax
  006c8	75 a6		 jne	 SHORT $LN434@inflate
$LN435@inflate:
$LN431@inflate:

; 694  :             INITBITS();

  006ca	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  006d2	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  006da	33 c0		 xor	 eax, eax
  006dc	85 c0		 test	 eax, eax
  006de	75 ea		 jne	 SHORT $LN431@inflate

; 695  :             state->mode = OS;

  006e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006e8	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN428@inflate:
$LN427@inflate:
$LN424@inflate:

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  006ee	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  006f3	73 57		 jae	 SHORT $LN423@inflate
$LN422@inflate:
  006f5	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  006fa	75 05		 jne	 SHORT $LN419@inflate
  006fc	e9 f1 25 00 00	 jmp	 $inf_leave$78295
$LN419@inflate:
  00701	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00705	83 e8 01	 sub	 eax, 1
  00708	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0070c	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00711	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00714	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00718	0f b6 c8	 movzx	 ecx, al
  0071b	8b c2		 mov	 eax, edx
  0071d	d3 e0		 shl	 eax, cl
  0071f	8b c8		 mov	 ecx, eax
  00721	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00725	03 c1		 add	 eax, ecx
  00727	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0072b	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00730	48 83 c0 01	 add	 rax, 1
  00734	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00739	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0073d	83 c0 08	 add	 eax, 8
  00740	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00744	33 c0		 xor	 eax, eax
  00746	85 c0		 test	 eax, eax
  00748	75 ab		 jne	 SHORT $LN422@inflate
  0074a	eb a2		 jmp	 SHORT $LN424@inflate
$LN423@inflate:
  0074c	33 c0		 xor	 eax, eax
  0074e	85 c0		 test	 eax, eax
  00750	75 9c		 jne	 SHORT $LN427@inflate

; 698  :             if (state->head != Z_NULL) {

  00752	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0075a	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0075f	74 2f		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  00761	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00765	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0076b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00773	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00777	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 700  :                 state->head->os = (int)(hold >> 8);

  0077a	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0077e	c1 e9 08	 shr	 ecx, 8
  00781	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00789	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0078d	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00790	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00798	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0079b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  007a0	85 c0		 test	 eax, eax
  007a2	74 44		 je	 SHORT $LN417@inflate
$LN416@inflate:
  007a4	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  007a9	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  007ad	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  007b1	c1 e8 08	 shr	 eax, 8
  007b4	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  007b8	41 b8 02 00 00
	00		 mov	 r8d, 2
  007be	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  007c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007cb	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  007ce	e8 00 00 00 00	 call	 crc32
  007d3	44 8b d8	 mov	 r11d, eax
  007d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007de	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  007e2	33 c0		 xor	 eax, eax
  007e4	85 c0		 test	 eax, eax
  007e6	75 bc		 jne	 SHORT $LN416@inflate
$LN417@inflate:
$LN413@inflate:

; 703  :             INITBITS();

  007e8	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  007f0	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  007f8	33 c0		 xor	 eax, eax
  007fa	85 c0		 test	 eax, eax
  007fc	75 ea		 jne	 SHORT $LN413@inflate

; 704  :             state->mode = EXLEN;

  007fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00806	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  0080c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00814	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00817	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0081c	85 c0		 test	 eax, eax
  0081e	0f 84 05 01 00
	00		 je	 $LN409@inflate
$LN408@inflate:
$LN405@inflate:

; 707  :                 NEEDBITS(16);

  00824	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00829	73 57		 jae	 SHORT $LN404@inflate
$LN403@inflate:
  0082b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00830	75 05		 jne	 SHORT $LN400@inflate
  00832	e9 bb 24 00 00	 jmp	 $inf_leave$78295
$LN400@inflate:
  00837	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0083b	83 e8 01	 sub	 eax, 1
  0083e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00842	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00847	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0084a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0084e	0f b6 c8	 movzx	 ecx, al
  00851	8b c2		 mov	 eax, edx
  00853	d3 e0		 shl	 eax, cl
  00855	8b c8		 mov	 ecx, eax
  00857	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0085b	03 c1		 add	 eax, ecx
  0085d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00861	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00866	48 83 c0 01	 add	 rax, 1
  0086a	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0086f	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00873	83 c0 08	 add	 eax, 8
  00876	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0087a	33 c0		 xor	 eax, eax
  0087c	85 c0		 test	 eax, eax
  0087e	75 ab		 jne	 SHORT $LN403@inflate
  00880	eb a2		 jmp	 SHORT $LN405@inflate
$LN404@inflate:
  00882	33 c0		 xor	 eax, eax
  00884	85 c0		 test	 eax, eax
  00886	75 9c		 jne	 SHORT $LN408@inflate

; 708  :                 state->length = (unsigned)(hold);

  00888	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00890	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00894	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 709  :                 if (state->head != Z_NULL)

  00897	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0089f	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  008a4	74 13		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  008a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  008ae	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  008b2	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  008b6	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  008b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008c1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  008c4	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008c9	85 c0		 test	 eax, eax
  008cb	74 44		 je	 SHORT $LN398@inflate
$LN397@inflate:
  008cd	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  008d2	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  008d6	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  008da	c1 e8 08	 shr	 eax, 8
  008dd	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  008e1	41 b8 02 00 00
	00		 mov	 r8d, 2
  008e7	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  008ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008f4	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  008f7	e8 00 00 00 00	 call	 crc32
  008fc	44 8b d8	 mov	 r11d, eax
  008ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00907	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  0090b	33 c0		 xor	 eax, eax
  0090d	85 c0		 test	 eax, eax
  0090f	75 bc		 jne	 SHORT $LN397@inflate
$LN398@inflate:
$LN394@inflate:

; 712  :                 INITBITS();

  00911	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00919	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00921	33 c0		 xor	 eax, eax
  00923	85 c0		 test	 eax, eax
  00925	75 ea		 jne	 SHORT $LN394@inflate

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  00927	eb 23		 jmp	 SHORT $LN391@inflate
$LN409@inflate:
  00929	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00931	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00936	74 14		 je	 SHORT $LN390@inflate

; 715  :                 state->head->extra = Z_NULL;

  00938	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00940	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00944	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN390@inflate:
$LN391@inflate:

; 716  :             state->mode = EXTRA;

  0094c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00954	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  0095a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00962	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00965	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0096a	85 c0		 test	 eax, eax
  0096c	0f 84 6b 01 00
	00		 je	 $LN388@inflate

; 719  :                 copy = state->length;

  00972	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0097a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0097d	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 720  :                 if (copy > have) copy = have;

  00981	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00985	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00989	76 08		 jbe	 SHORT $LN387@inflate
  0098b	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0098f	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN387@inflate:

; 721  :                 if (copy) {

  00993	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  00998	0f 84 2c 01 00
	00		 je	 $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  0099e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009a6	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  009ab	0f 84 a1 00 00
	00		 je	 $LN385@inflate
  009b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009b9	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009bd	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  009c2	0f 84 8a 00 00
	00		 je	 $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  009c8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  009d0	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  009d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009dc	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  009df	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  009e2	2b c1		 sub	 eax, ecx
  009e4	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  009e8	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  009ec	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  009f0	03 c8		 add	 ecx, eax
  009f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009fa	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009fe	3b 48 1c	 cmp	 ecx, DWORD PTR [rax+28]
  00a01	76 1e		 jbe	 SHORT $LN512@inflate
  00a03	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a0b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a0f	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  00a13	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00a16	2b c1		 sub	 eax, ecx
  00a18	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
  00a1f	eb 0b		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  00a21	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00a25	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
$LN513@inflate:
  00a2c	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR tv351[rsp]
  00a34	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a3c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a40	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  00a44	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  00a48	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00a4d	e8 00 00 00 00	 call	 memcpy
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  00a52	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a5a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00a5d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a62	85 c0		 test	 eax, eax
  00a64	74 29		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  00a66	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00a6b	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00a70	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a78	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00a7b	e8 00 00 00 00	 call	 crc32
  00a80	44 8b d8	 mov	 r11d, eax
  00a83	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a8b	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN384@inflate:

; 731  :                     have -= copy;

  00a8f	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00a93	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00a97	2b c1		 sub	 eax, ecx
  00a99	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 732  :                     next += copy;

  00a9d	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00aa1	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00aa6	48 03 c1	 add	 rax, rcx
  00aa9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 733  :                     state->length -= copy;

  00aae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00ab6	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00aba	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00abd	2b c8		 sub	 ecx, eax
  00abf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ac7	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  00aca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ad2	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00ad6	74 05		 je	 SHORT $LN383@inflate
  00ad8	e9 15 22 00 00	 jmp	 $inf_leave$78295
$LN383@inflate:
$LN388@inflate:

; 736  :             }
; 737  :             state->length = 0;

  00add	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ae5	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 738  :             state->mode = NAME;

  00aec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00af4	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  00afa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b02	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00b05	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00b0a	85 c0		 test	 eax, eax
  00b0c	0f 84 29 01 00
	00		 je	 $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  00b12	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00b17	75 05		 jne	 SHORT $LN380@inflate
  00b19	e9 d4 21 00 00	 jmp	 $inf_leave$78295
$LN380@inflate:

; 742  :                 copy = 0;

  00b1e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN379@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00b26	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00b2a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00b2f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00b33	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00b37	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00b3b	83 c0 01	 add	 eax, 1
  00b3e	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00b42	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b4a	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b4f	74 6b		 je	 SHORT $LN376@inflate
  00b51	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b59	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b5d	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b62	74 58		 je	 SHORT $LN376@inflate
  00b64	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b6c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b70	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b78	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b7b	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00b7e	73 3c		 jae	 SHORT $LN376@inflate

; 748  :                         state->head->name[state->length++] = len;

  00b80	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b88	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00b8c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b94	8b 50 48	 mov	 edx, DWORD PTR [rax+72]
  00b97	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00b9b	0f b6 44 24 48	 movzx	 eax, BYTE PTR len$[rsp]
  00ba0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ba3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bab	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00bae	83 c1 01	 add	 ecx, 1
  00bb1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bb9	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN376@inflate:

; 749  :                 } while (len && copy < have);

  00bbc	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00bc1	74 0e		 je	 SHORT $LN375@inflate
  00bc3	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00bc7	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00bcb	0f 82 55 ff ff
	ff		 jb	 $LN379@inflate
$LN375@inflate:

; 750  :                 if (state->flags & 0x0200)

  00bd1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bd9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00bdc	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00be1	85 c0		 test	 eax, eax
  00be3	74 29		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  00be5	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00bea	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00bef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bf7	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00bfa	e8 00 00 00 00	 call	 crc32
  00bff	44 8b d8	 mov	 r11d, eax
  00c02	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c0a	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN374@inflate:

; 752  :                 have -= copy;

  00c0e	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00c12	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00c16	2b c1		 sub	 eax, ecx
  00c18	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 753  :                 next += copy;

  00c1c	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00c20	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00c25	48 03 c1	 add	 rax, rcx
  00c28	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 754  :                 if (len) goto inf_leave;

  00c2d	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00c32	74 05		 je	 SHORT $LN373@inflate
  00c34	e9 b9 20 00 00	 jmp	 $inf_leave$78295
$LN373@inflate:

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  00c39	eb 23		 jmp	 SHORT $LN372@inflate
$LN381@inflate:
  00c3b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c43	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00c48	74 14		 je	 SHORT $LN371@inflate

; 757  :                 state->head->name = Z_NULL;

  00c4a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c52	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00c56	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN371@inflate:
$LN372@inflate:

; 758  :             state->length = 0;

  00c5e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c66	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 759  :             state->mode = COMMENT;

  00c6d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c75	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  00c7b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c83	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00c86	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00c8b	85 c0		 test	 eax, eax
  00c8d	0f 84 29 01 00
	00		 je	 $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  00c93	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00c98	75 05		 jne	 SHORT $LN368@inflate
  00c9a	e9 53 20 00 00	 jmp	 $inf_leave$78295
$LN368@inflate:

; 763  :                 copy = 0;

  00c9f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN367@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  00ca7	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00cab	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00cb0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00cb4	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00cb8	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00cbc	83 c0 01	 add	 eax, 1
  00cbf	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  00cc3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ccb	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00cd0	74 6b		 je	 SHORT $LN364@inflate
  00cd2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cda	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cde	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00ce3	74 58		 je	 SHORT $LN364@inflate
  00ce5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ced	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cf1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00cf9	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00cfc	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00cff	73 3c		 jae	 SHORT $LN364@inflate

; 769  :                         state->head->comment[state->length++] = len;

  00d01	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00d09	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00d0d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d15	8b 50 48	 mov	 edx, DWORD PTR [rax+72]
  00d18	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00d1c	0f b6 44 24 48	 movzx	 eax, BYTE PTR len$[rsp]
  00d21	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00d24	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d2c	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00d2f	83 c1 01	 add	 ecx, 1
  00d32	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d3a	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN364@inflate:

; 770  :                 } while (len && copy < have);

  00d3d	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00d42	74 0e		 je	 SHORT $LN363@inflate
  00d44	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00d48	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00d4c	0f 82 55 ff ff
	ff		 jb	 $LN367@inflate
$LN363@inflate:

; 771  :                 if (state->flags & 0x0200)

  00d52	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d5a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00d5d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d62	85 c0		 test	 eax, eax
  00d64	74 29		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  00d66	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00d6b	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00d70	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d78	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00d7b	e8 00 00 00 00	 call	 crc32
  00d80	44 8b d8	 mov	 r11d, eax
  00d83	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d8b	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN362@inflate:

; 773  :                 have -= copy;

  00d8f	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00d93	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00d97	2b c1		 sub	 eax, ecx
  00d99	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 774  :                 next += copy;

  00d9d	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00da1	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00da6	48 03 c1	 add	 rax, rcx
  00da9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 775  :                 if (len) goto inf_leave;

  00dae	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00db3	74 05		 je	 SHORT $LN361@inflate
  00db5	e9 38 1f 00 00	 jmp	 $inf_leave$78295
$LN361@inflate:

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00dba	eb 23		 jmp	 SHORT $LN360@inflate
$LN369@inflate:
  00dbc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dc4	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00dc9	74 14		 je	 SHORT $LN359@inflate

; 778  :                 state->head->comment = Z_NULL;

  00dcb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dd3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00dd7	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
$LN359@inflate:
$LN360@inflate:

; 779  :             state->mode = HCRC;

  00ddf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00de7	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00ded	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00df5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00df8	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00dfd	85 c0		 test	 eax, eax
  00dff	0f 84 b6 00 00
	00		 je	 $LN357@inflate
$LN356@inflate:
$LN353@inflate:

; 782  :                 NEEDBITS(16);

  00e05	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00e0a	73 57		 jae	 SHORT $LN352@inflate
$LN351@inflate:
  00e0c	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00e11	75 05		 jne	 SHORT $LN348@inflate
  00e13	e9 da 1e 00 00	 jmp	 $inf_leave$78295
$LN348@inflate:
  00e18	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00e1c	83 e8 01	 sub	 eax, 1
  00e1f	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00e23	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00e28	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00e2b	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00e2f	0f b6 c8	 movzx	 ecx, al
  00e32	8b c2		 mov	 eax, edx
  00e34	d3 e0		 shl	 eax, cl
  00e36	8b c8		 mov	 ecx, eax
  00e38	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00e3c	03 c1		 add	 eax, ecx
  00e3e	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00e42	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00e47	48 83 c0 01	 add	 rax, 1
  00e4b	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00e50	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00e54	83 c0 08	 add	 eax, 8
  00e57	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00e5b	33 c0		 xor	 eax, eax
  00e5d	85 c0		 test	 eax, eax
  00e5f	75 ab		 jne	 SHORT $LN351@inflate
  00e61	eb a2		 jmp	 SHORT $LN353@inflate
$LN352@inflate:
  00e63	33 c0		 xor	 eax, eax
  00e65	85 c0		 test	 eax, eax
  00e67	75 9c		 jne	 SHORT $LN356@inflate

; 783  :                 if (hold != (state->check & 0xffff)) {

  00e69	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e71	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e74	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e79	39 44 24 64	 cmp	 DWORD PTR hold$[rsp], eax
  00e7d	74 26		 je	 SHORT $LN347@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  00e7f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e87	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00e8e	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 785  :                     state->mode = BAD;

  00e92	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e9a	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 786  :                     break;

  00ea0	e9 48 1e 00 00	 jmp	 $LN498@inflate
$LN347@inflate:
$LN346@inflate:

; 787  :                 }
; 788  :                 INITBITS();

  00ea5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00ead	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00eb5	33 c0		 xor	 eax, eax
  00eb7	85 c0		 test	 eax, eax
  00eb9	75 ea		 jne	 SHORT $LN346@inflate
$LN357@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  00ebb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ec3	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00ec8	74 33		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00eca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ed2	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00ed5	c1 f9 09	 sar	 ecx, 9
  00ed8	83 e1 01	 and	 ecx, 1
  00edb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ee3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00ee7	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 792  :                 state->head->done = 1;

  00eea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ef2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00ef6	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00efd	45 33 c0	 xor	 r8d, r8d
  00f00	33 d2		 xor	 edx, edx
  00f02	33 c9		 xor	 ecx, ecx
  00f04	e8 00 00 00 00	 call	 crc32
  00f09	44 8b d8	 mov	 r11d, eax
  00f0c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f14	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  00f18	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00f20	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f28	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00f2b	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 795  :             state->mode = TYPE;

  00f2e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f36	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 796  :             break;

  00f3c	e9 ac 1d 00 00	 jmp	 $LN498@inflate
$LN342@inflate:
$LN341@inflate:
$LN338@inflate:

; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  00f41	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00f46	73 57		 jae	 SHORT $LN337@inflate
$LN336@inflate:
  00f48	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00f4d	75 05		 jne	 SHORT $LN333@inflate
  00f4f	e9 9e 1d 00 00	 jmp	 $inf_leave$78295
$LN333@inflate:
  00f54	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00f58	83 e8 01	 sub	 eax, 1
  00f5b	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00f5f	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00f64	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00f67	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00f6b	0f b6 c8	 movzx	 ecx, al
  00f6e	8b c2		 mov	 eax, edx
  00f70	d3 e0		 shl	 eax, cl
  00f72	8b c8		 mov	 ecx, eax
  00f74	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00f78	03 c1		 add	 eax, ecx
  00f7a	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00f7e	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00f83	48 83 c0 01	 add	 rax, 1
  00f87	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00f8c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00f90	83 c0 08	 add	 eax, 8
  00f93	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00f97	33 c0		 xor	 eax, eax
  00f99	85 c0		 test	 eax, eax
  00f9b	75 ab		 jne	 SHORT $LN336@inflate
  00f9d	eb a2		 jmp	 SHORT $LN338@inflate
$LN337@inflate:
  00f9f	33 c0		 xor	 eax, eax
  00fa1	85 c0		 test	 eax, eax
  00fa3	75 9c		 jne	 SHORT $LN341@inflate

; 800  :             strm->adler = state->check = REVERSE(hold);

  00fa5	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00fa9	c1 e9 18	 shr	 ecx, 24
  00fac	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00fb2	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00fb6	c1 e8 08	 shr	 eax, 8
  00fb9	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00fbe	03 c8		 add	 ecx, eax
  00fc0	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00fc4	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00fc9	c1 e0 08	 shl	 eax, 8
  00fcc	03 c8		 add	 ecx, eax
  00fce	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00fd2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fd7	c1 e0 18	 shl	 eax, 24
  00fda	03 c8		 add	 ecx, eax
  00fdc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00fe4	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00fe7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00fef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ff7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00ffa	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN332@inflate:

; 801  :             INITBITS();

  00ffd	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  01005	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  0100d	33 c0		 xor	 eax, eax
  0100f	85 c0		 test	 eax, eax
  01011	75 ea		 jne	 SHORT $LN332@inflate

; 802  :             state->mode = DICT;

  01013	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0101b	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  01021	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01029	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  0102d	75 6d		 jne	 SHORT $LN328@inflate
$LN327@inflate:

; 805  :                 RESTORE();

  0102f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01037	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  0103c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  01040	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01048	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  0104c	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  0104f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01057	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0105c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0105f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01067	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0106b	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0106e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01076	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0107a	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  0107d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01085	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01089	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  0108c	33 c0		 xor	 eax, eax
  0108e	85 c0		 test	 eax, eax
  01090	75 9d		 jne	 SHORT $LN327@inflate

; 806  :                 return Z_NEED_DICT;

  01092	b8 02 00 00 00	 mov	 eax, 2
  01097	e9 0c 1f 00 00	 jmp	 $LN508@inflate
$LN328@inflate:

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0109c	45 33 c0	 xor	 r8d, r8d
  0109f	33 d2		 xor	 edx, edx
  010a1	33 c9		 xor	 ecx, ecx
  010a3	e8 00 00 00 00	 call	 adler32
  010a8	44 8b d8	 mov	 r11d, eax
  010ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010b3	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  010b7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010c7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  010ca	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 809  :             state->mode = TYPE;

  010cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010d5	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN324@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  010db	83 bc 24 c8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  010e3	74 0a		 je	 SHORT $LN322@inflate
  010e5	83 bc 24 c8 00
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  010ed	75 05		 jne	 SHORT $LN323@inflate
$LN322@inflate:
  010ef	e9 fe 1b 00 00	 jmp	 $inf_leave$78295
$LN323@inflate:
$LN321@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  010f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010fc	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  01100	74 3e		 je	 SHORT $LN320@inflate
$LN319@inflate:

; 814  :                 BYTEBITS();

  01102	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01106	83 e0 07	 and	 eax, 7
  01109	0f b6 c8	 movzx	 ecx, al
  0110c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01110	d3 e8		 shr	 eax, cl
  01112	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01116	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0111a	83 e1 07	 and	 ecx, 7
  0111d	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01121	2b c1		 sub	 eax, ecx
  01123	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01127	33 c0		 xor	 eax, eax
  01129	85 c0		 test	 eax, eax
  0112b	75 d5		 jne	 SHORT $LN319@inflate

; 815  :                 state->mode = CHECK;

  0112d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01135	c7 00 1a 00 00
	00		 mov	 DWORD PTR [rax], 26

; 816  :                 break;

  0113b	e9 ad 1b 00 00	 jmp	 $LN498@inflate
$LN320@inflate:
$LN316@inflate:
$LN313@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  01140	83 7c 24 4c 03	 cmp	 DWORD PTR bits$[rsp], 3
  01145	73 57		 jae	 SHORT $LN312@inflate
$LN311@inflate:
  01147	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0114c	75 05		 jne	 SHORT $LN308@inflate
  0114e	e9 9f 1b 00 00	 jmp	 $inf_leave$78295
$LN308@inflate:
  01153	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01157	83 e8 01	 sub	 eax, 1
  0115a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0115e	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01163	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01166	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0116a	0f b6 c8	 movzx	 ecx, al
  0116d	8b c2		 mov	 eax, edx
  0116f	d3 e0		 shl	 eax, cl
  01171	8b c8		 mov	 ecx, eax
  01173	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01177	03 c1		 add	 eax, ecx
  01179	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0117d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01182	48 83 c0 01	 add	 rax, 1
  01186	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0118b	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0118f	83 c0 08	 add	 eax, 8
  01192	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01196	33 c0		 xor	 eax, eax
  01198	85 c0		 test	 eax, eax
  0119a	75 ab		 jne	 SHORT $LN311@inflate
  0119c	eb a2		 jmp	 SHORT $LN313@inflate
$LN312@inflate:
  0119e	33 c0		 xor	 eax, eax
  011a0	85 c0		 test	 eax, eax
  011a2	75 9c		 jne	 SHORT $LN316@inflate

; 819  :             state->last = BITS(1);

  011a4	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  011a8	83 e1 01	 and	 ecx, 1
  011ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  011b3	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN307@inflate:

; 820  :             DROPBITS(1);

  011b6	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  011ba	d1 e8		 shr	 eax, 1
  011bc	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  011c0	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  011c4	83 e8 01	 sub	 eax, 1
  011c7	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  011cb	33 c0		 xor	 eax, eax
  011cd	85 c0		 test	 eax, eax
  011cf	75 e5		 jne	 SHORT $LN307@inflate

; 821  :             switch (BITS(2)) {

  011d1	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  011d5	83 e0 03	 and	 eax, 3
  011d8	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv565[rsp], eax
  011df	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv565[rsp], 0
  011e7	74 23		 je	 SHORT $LN302@inflate
  011e9	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv565[rsp], 1
  011f1	74 29		 je	 SHORT $LN301@inflate
  011f3	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv565[rsp], 2
  011fb	74 68		 je	 SHORT $LN296@inflate
  011fd	83 bc 24 94 00
	00 00 03	 cmp	 DWORD PTR tv565[rsp], 3
  01205	74 6e		 je	 SHORT $LN295@inflate
  01207	e9 8a 00 00 00	 jmp	 $LN303@inflate
$LN302@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;

  0120c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01214	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 826  :                 break;

  0121a	eb 7a		 jmp	 SHORT $LN303@inflate
$LN301@inflate:

; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  0121c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01224	e8 00 00 00 00	 call	 fixedtables

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */

  01229	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR state$[rsp]
  01231	41 c7 03 13 00
	00 00		 mov	 DWORD PTR [r11], 19

; 832  :                 if (flush == Z_TREES) {

  01238	83 bc 24 c8 00
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01240	75 21		 jne	 SHORT $LN300@inflate
$LN299@inflate:

; 833  :                     DROPBITS(2);

  01242	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01246	c1 e8 02	 shr	 eax, 2
  01249	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0124d	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01251	83 e8 02	 sub	 eax, 2
  01254	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01258	33 c0		 xor	 eax, eax
  0125a	85 c0		 test	 eax, eax
  0125c	75 e4		 jne	 SHORT $LN299@inflate

; 834  :                     goto inf_leave;

  0125e	e9 8f 1a 00 00	 jmp	 $inf_leave$78295
$LN300@inflate:

; 835  :                 }
; 836  :                 break;

  01263	eb 31		 jmp	 SHORT $LN303@inflate
$LN296@inflate:

; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;

  01265	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0126d	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 841  :                 break;

  01273	eb 21		 jmp	 SHORT $LN303@inflate
$LN295@inflate:

; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  01275	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0127d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  01284	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 844  :                 state->mode = BAD;

  01288	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01290	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29
$LN303@inflate:
$LN294@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  01296	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0129a	c1 e8 02	 shr	 eax, 2
  0129d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  012a1	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  012a5	83 e8 02	 sub	 eax, 2
  012a8	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  012ac	33 c0		 xor	 eax, eax
  012ae	85 c0		 test	 eax, eax
  012b0	75 e4		 jne	 SHORT $LN294@inflate

; 847  :             break;

  012b2	e9 36 1a 00 00	 jmp	 $LN498@inflate
$LN291@inflate:
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  012b7	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  012bb	83 e0 07	 and	 eax, 7
  012be	0f b6 c8	 movzx	 ecx, al
  012c1	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  012c5	d3 e8		 shr	 eax, cl
  012c7	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  012cb	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  012cf	83 e1 07	 and	 ecx, 7
  012d2	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  012d6	2b c1		 sub	 eax, ecx
  012d8	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  012dc	33 c0		 xor	 eax, eax
  012de	85 c0		 test	 eax, eax
  012e0	75 d5		 jne	 SHORT $LN290@inflate
$LN287@inflate:
$LN284@inflate:

; 850  :             NEEDBITS(32);

  012e2	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  012e7	73 57		 jae	 SHORT $LN283@inflate
$LN282@inflate:
  012e9	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  012ee	75 05		 jne	 SHORT $LN279@inflate
  012f0	e9 fd 19 00 00	 jmp	 $inf_leave$78295
$LN279@inflate:
  012f5	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  012f9	83 e8 01	 sub	 eax, 1
  012fc	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01300	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01305	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01308	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0130c	0f b6 c8	 movzx	 ecx, al
  0130f	8b c2		 mov	 eax, edx
  01311	d3 e0		 shl	 eax, cl
  01313	8b c8		 mov	 ecx, eax
  01315	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01319	03 c1		 add	 eax, ecx
  0131b	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0131f	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01324	48 83 c0 01	 add	 rax, 1
  01328	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0132d	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01331	83 c0 08	 add	 eax, 8
  01334	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01338	33 c0		 xor	 eax, eax
  0133a	85 c0		 test	 eax, eax
  0133c	75 ab		 jne	 SHORT $LN282@inflate
  0133e	eb a2		 jmp	 SHORT $LN284@inflate
$LN283@inflate:
  01340	33 c0		 xor	 eax, eax
  01342	85 c0		 test	 eax, eax
  01344	75 9c		 jne	 SHORT $LN287@inflate

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  01346	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0134a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01350	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01354	c1 e8 10	 shr	 eax, 16
  01357	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  0135c	3b c8		 cmp	 ecx, eax
  0135e	74 26		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  01360	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01368	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0136f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 853  :                 state->mode = BAD;

  01373	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0137b	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 854  :                 break;

  01381	e9 67 19 00 00	 jmp	 $LN498@inflate
$LN278@inflate:

; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  01386	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0138a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01390	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01398	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN277@inflate:

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  0139b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  013a3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  013ab	33 c0		 xor	 eax, eax
  013ad	85 c0		 test	 eax, eax
  013af	75 ea		 jne	 SHORT $LN277@inflate

; 860  :             state->mode = COPY_;

  013b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  013b9	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14

; 861  :             if (flush == Z_TREES) goto inf_leave;

  013bf	83 bc 24 c8 00
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  013c7	75 05		 jne	 SHORT $LN274@inflate
  013c9	e9 24 19 00 00	 jmp	 $inf_leave$78295
$LN274@inflate:
$LN273@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  013ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  013d6	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  013dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  013e4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  013e7	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 866  :             if (copy) {

  013eb	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  013f0	0f 84 a5 00 00
	00		 je	 $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  013f6	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  013fa	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  013fe	76 08		 jbe	 SHORT $LN270@inflate
  01400	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01404	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN270@inflate:

; 868  :                 if (copy > left) copy = left;

  01408	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  0140c	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  01410	76 08		 jbe	 SHORT $LN269@inflate
  01412	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  01416	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN269@inflate:

; 869  :                 if (copy == 0) goto inf_leave;

  0141a	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  0141f	75 05		 jne	 SHORT $LN268@inflate
  01421	e9 cc 18 00 00	 jmp	 $inf_leave$78295
$LN268@inflate:

; 870  :                 zmemcpy(put, next, copy);

  01426	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  0142b	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  01430	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01435	e8 00 00 00 00	 call	 memcpy

; 871  :                 have -= copy;

  0143a	44 8b 5c 24 6c	 mov	 r11d, DWORD PTR copy$[rsp]
  0143f	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01443	41 2b c3	 sub	 eax, r11d
  01446	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 872  :                 next += copy;

  0144a	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0144e	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01453	48 03 c1	 add	 rax, rcx
  01456	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 873  :                 left -= copy;

  0145b	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0145f	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  01463	2b c1		 sub	 eax, ecx
  01465	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 874  :                 put += copy;

  01469	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0146d	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01472	48 03 c1	 add	 rax, rcx
  01475	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 875  :                 state->length -= copy;

  0147a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01482	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01486	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01489	2b c8		 sub	 ecx, eax
  0148b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01493	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 876  :                 break;

  01496	e9 52 18 00 00	 jmp	 $LN498@inflate
$LN271@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;

  0149b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  014a3	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 880  :             break;

  014a9	e9 3f 18 00 00	 jmp	 $LN498@inflate
$LN267@inflate:
$LN266@inflate:
$LN263@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  014ae	83 7c 24 4c 0e	 cmp	 DWORD PTR bits$[rsp], 14
  014b3	73 57		 jae	 SHORT $LN262@inflate
$LN261@inflate:
  014b5	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  014ba	75 05		 jne	 SHORT $LN258@inflate
  014bc	e9 31 18 00 00	 jmp	 $inf_leave$78295
$LN258@inflate:
  014c1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  014c5	83 e8 01	 sub	 eax, 1
  014c8	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  014cc	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  014d1	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  014d4	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  014d8	0f b6 c8	 movzx	 ecx, al
  014db	8b c2		 mov	 eax, edx
  014dd	d3 e0		 shl	 eax, cl
  014df	8b c8		 mov	 ecx, eax
  014e1	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  014e5	03 c1		 add	 eax, ecx
  014e7	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  014eb	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  014f0	48 83 c0 01	 add	 rax, 1
  014f4	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  014f9	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  014fd	83 c0 08	 add	 eax, 8
  01500	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01504	33 c0		 xor	 eax, eax
  01506	85 c0		 test	 eax, eax
  01508	75 ab		 jne	 SHORT $LN261@inflate
  0150a	eb a2		 jmp	 SHORT $LN263@inflate
$LN262@inflate:
  0150c	33 c0		 xor	 eax, eax
  0150e	85 c0		 test	 eax, eax
  01510	75 9c		 jne	 SHORT $LN266@inflate

; 883  :             state->nlen = BITS(5) + 257;

  01512	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01516	83 e1 1f	 and	 ecx, 31
  01519	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0151f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01527	89 48 74	 mov	 DWORD PTR [rax+116], ecx
$LN257@inflate:

; 884  :             DROPBITS(5);

  0152a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0152e	c1 e8 05	 shr	 eax, 5
  01531	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01535	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01539	83 e8 05	 sub	 eax, 5
  0153c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01540	33 c0		 xor	 eax, eax
  01542	85 c0		 test	 eax, eax
  01544	75 e4		 jne	 SHORT $LN257@inflate

; 885  :             state->ndist = BITS(5) + 1;

  01546	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0154a	83 e1 1f	 and	 ecx, 31
  0154d	83 c1 01	 add	 ecx, 1
  01550	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01558	89 48 78	 mov	 DWORD PTR [rax+120], ecx
$LN254@inflate:

; 886  :             DROPBITS(5);

  0155b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0155f	c1 e8 05	 shr	 eax, 5
  01562	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01566	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0156a	83 e8 05	 sub	 eax, 5
  0156d	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01571	33 c0		 xor	 eax, eax
  01573	85 c0		 test	 eax, eax
  01575	75 e4		 jne	 SHORT $LN254@inflate

; 887  :             state->ncode = BITS(4) + 4;

  01577	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0157b	83 e1 0f	 and	 ecx, 15
  0157e	83 c1 04	 add	 ecx, 4
  01581	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01589	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN251@inflate:

; 888  :             DROPBITS(4);

  0158c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01590	c1 e8 04	 shr	 eax, 4
  01593	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01597	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0159b	83 e8 04	 sub	 eax, 4
  0159e	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  015a2	33 c0		 xor	 eax, eax
  015a4	85 c0		 test	 eax, eax
  015a6	75 e4		 jne	 SHORT $LN251@inflate

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  015a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015b0	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  015b7	77 0e		 ja	 SHORT $LN247@inflate
  015b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015c1	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  015c5	76 26		 jbe	 SHORT $LN248@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  015c7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  015cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  015d6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 892  :                 state->mode = BAD;

  015da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015e2	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 893  :                 break;

  015e8	e9 00 17 00 00	 jmp	 $LN498@inflate
$LN248@inflate:

; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  015ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015f5	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 898  :             state->mode = LENLENS;

  015fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01604	c7 00 11 00 00
	00		 mov	 DWORD PTR [rax], 17
$LN246@inflate:
$LN245@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  0160a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01612	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0161a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0161d	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  01620	0f 83 cb 00 00
	00		 jae	 $LN244@inflate
$LN243@inflate:
$LN240@inflate:

; 901  :                 NEEDBITS(3);

  01626	83 7c 24 4c 03	 cmp	 DWORD PTR bits$[rsp], 3
  0162b	73 57		 jae	 SHORT $LN239@inflate
$LN238@inflate:
  0162d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01632	75 05		 jne	 SHORT $LN235@inflate
  01634	e9 b9 16 00 00	 jmp	 $inf_leave$78295
$LN235@inflate:
  01639	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0163d	83 e8 01	 sub	 eax, 1
  01640	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01644	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01649	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0164c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01650	0f b6 c8	 movzx	 ecx, al
  01653	8b c2		 mov	 eax, edx
  01655	d3 e0		 shl	 eax, cl
  01657	8b c8		 mov	 ecx, eax
  01659	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0165d	03 c1		 add	 eax, ecx
  0165f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01663	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01668	48 83 c0 01	 add	 rax, 1
  0166c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01671	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01675	83 c0 08	 add	 eax, 8
  01678	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0167c	33 c0		 xor	 eax, eax
  0167e	85 c0		 test	 eax, eax
  01680	75 ab		 jne	 SHORT $LN238@inflate
  01682	eb a2		 jmp	 SHORT $LN240@inflate
$LN239@inflate:
  01684	33 c0		 xor	 eax, eax
  01686	85 c0		 test	 eax, eax
  01688	75 9c		 jne	 SHORT $LN243@inflate

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0168a	8b 54 24 64	 mov	 edx, DWORD PTR hold$[rsp]
  0168e	83 e2 07	 and	 edx, 7
  01691	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01699	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  0169c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflate@@9@9
  016a3	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  016a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016af	66 89 94 48 88
	00 00 00	 mov	 WORD PTR [rax+rcx*2+136], dx
  016b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016bf	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  016c2	83 c1 01	 add	 ecx, 1
  016c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016cd	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN234@inflate:

; 903  :                 DROPBITS(3);

  016d0	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  016d4	c1 e8 03	 shr	 eax, 3
  016d7	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  016db	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  016df	83 e8 03	 sub	 eax, 3
  016e2	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  016e6	33 c0		 xor	 eax, eax
  016e8	85 c0		 test	 eax, eax
  016ea	75 e4		 jne	 SHORT $LN234@inflate

; 904  :             }

  016ec	e9 19 ff ff ff	 jmp	 $LN245@inflate
$LN244@inflate:
$LN231@inflate:

; 905  :             while (state->have < 19)

  016f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016f9	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  016fd	73 43		 jae	 SHORT $LN230@inflate

; 906  :                 state->lens[order[state->have++]] = 0;

  016ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01707	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  0170a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflate@@9@9
  01711	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  01715	33 c9		 xor	 ecx, ecx
  01717	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0171f	66 89 8c 50 88
	00 00 00	 mov	 WORD PTR [rax+rdx*2+136], cx
  01727	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0172f	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  01732	83 c1 01	 add	 ecx, 1
  01735	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0173d	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  01740	eb af		 jmp	 SHORT $LN231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;

  01742	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0174a	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  01751	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01759	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 908  :             state->lencode = (code const FAR *)(state->next);

  01760	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01768	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01770	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01777	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 909  :             state->lenbits = 7;

  0177b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01783	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  0178a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01792	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  01799	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017a1	48 83 c0 68	 add	 rax, 104		; 00000068H
  017a5	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  017ad	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  017b4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  017bc	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  017c3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017cd	41 b8 13 00 00
	00		 mov	 r8d, 19
  017d3	33 c9		 xor	 ecx, ecx
  017d5	e8 00 00 00 00	 call	 inflate_table
  017da	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 912  :             if (ret) {

  017de	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  017e3	74 26		 je	 SHORT $LN229@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  017e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  017ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  017f4	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 914  :                 state->mode = BAD;

  017f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01800	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 915  :                 break;

  01806	e9 e2 14 00 00	 jmp	 $LN498@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  0180b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01813	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 919  :             state->mode = CODELENS;

  0181a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01822	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18
$LN228@inflate:
$LN227@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  01828	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01830	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  01833	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0183b	03 48 78	 add	 ecx, DWORD PTR [rax+120]
  0183e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01846	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  01849	0f 83 d5 04 00
	00		 jae	 $LN226@inflate
$LN225@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  0184f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01857	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  0185a	b8 01 00 00 00	 mov	 eax, 1
  0185f	d3 e0		 shl	 eax, cl
  01861	8b c8		 mov	 ecx, eax
  01863	83 e9 01	 sub	 ecx, 1
  01866	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0186a	23 c1		 and	 eax, ecx
  0186c	8b c8		 mov	 ecx, eax
  0186e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01876	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0187a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0187d	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  01881	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01886	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  0188a	77 02		 ja	 SHORT $LN223@inflate
  0188c	eb 5a		 jmp	 SHORT $LN224@inflate
$LN223@inflate:
$LN222@inflate:

; 925  :                     PULLBYTE();

  0188e	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01893	75 05		 jne	 SHORT $LN219@inflate
  01895	e9 58 14 00 00	 jmp	 $inf_leave$78295
$LN219@inflate:
  0189a	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0189e	83 e8 01	 sub	 eax, 1
  018a1	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  018a5	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  018aa	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  018ad	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  018b1	0f b6 c8	 movzx	 ecx, al
  018b4	8b c2		 mov	 eax, edx
  018b6	d3 e0		 shl	 eax, cl
  018b8	8b c8		 mov	 ecx, eax
  018ba	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  018be	03 c1		 add	 eax, ecx
  018c0	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  018c4	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  018c9	48 83 c0 01	 add	 rax, 1
  018cd	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  018d2	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  018d6	83 c0 08	 add	 eax, 8
  018d9	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  018dd	33 c0		 xor	 eax, eax
  018df	85 c0		 test	 eax, eax
  018e1	75 ab		 jne	 SHORT $LN222@inflate

; 926  :                 }

  018e3	e9 67 ff ff ff	 jmp	 $LN225@inflate
$LN224@inflate:

; 927  :                 if (here.val < 16) {

  018e8	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  018ed	83 f8 10	 cmp	 eax, 16
  018f0	0f 8d cd 00 00
	00		 jge	 $LN218@inflate
$LN217@inflate:
$LN214@inflate:

; 928  :                     NEEDBITS(here.bits);

  018f6	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  018fb	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  018ff	73 57		 jae	 SHORT $LN213@inflate
$LN212@inflate:
  01901	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01906	75 05		 jne	 SHORT $LN209@inflate
  01908	e9 e5 13 00 00	 jmp	 $inf_leave$78295
$LN209@inflate:
  0190d	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01911	83 e8 01	 sub	 eax, 1
  01914	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01918	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0191d	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01920	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01924	0f b6 c8	 movzx	 ecx, al
  01927	8b c2		 mov	 eax, edx
  01929	d3 e0		 shl	 eax, cl
  0192b	8b c8		 mov	 ecx, eax
  0192d	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01931	03 c1		 add	 eax, ecx
  01933	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01937	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0193c	48 83 c0 01	 add	 rax, 1
  01940	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01945	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01949	83 c0 08	 add	 eax, 8
  0194c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01950	33 c0		 xor	 eax, eax
  01952	85 c0		 test	 eax, eax
  01954	75 ab		 jne	 SHORT $LN212@inflate
  01956	eb 9e		 jmp	 SHORT $LN214@inflate
$LN213@inflate:
  01958	33 c0		 xor	 eax, eax
  0195a	85 c0		 test	 eax, eax
  0195c	75 98		 jne	 SHORT $LN217@inflate
$LN208@inflate:

; 929  :                     DROPBITS(here.bits);

  0195e	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01963	0f b6 c8	 movzx	 ecx, al
  01966	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0196a	d3 e8		 shr	 eax, cl
  0196c	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01970	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01975	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01979	2b c1		 sub	 eax, ecx
  0197b	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0197f	33 c0		 xor	 eax, eax
  01981	85 c0		 test	 eax, eax
  01983	75 d9		 jne	 SHORT $LN208@inflate

; 930  :                     state->lens[state->have++] = here.val;

  01985	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0198d	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  01990	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01998	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  0199d	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  019a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  019ad	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  019b0	83 c1 01	 add	 ecx, 1
  019b3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  019bb	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 931  :                 }
; 932  :                 else {

  019be	e9 5c 03 00 00	 jmp	 $LN205@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  019c3	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  019c8	83 f8 10	 cmp	 eax, 16
  019cb	0f 85 19 01 00
	00		 jne	 $LN204@inflate
$LN203@inflate:
$LN200@inflate:

; 934  :                         NEEDBITS(here.bits + 2);

  019d1	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  019d6	83 c0 02	 add	 eax, 2
  019d9	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  019dd	73 57		 jae	 SHORT $LN199@inflate
$LN198@inflate:
  019df	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  019e4	75 05		 jne	 SHORT $LN195@inflate
  019e6	e9 07 13 00 00	 jmp	 $inf_leave$78295
$LN195@inflate:
  019eb	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  019ef	83 e8 01	 sub	 eax, 1
  019f2	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  019f6	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  019fb	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  019fe	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01a02	0f b6 c8	 movzx	 ecx, al
  01a05	8b c2		 mov	 eax, edx
  01a07	d3 e0		 shl	 eax, cl
  01a09	8b c8		 mov	 ecx, eax
  01a0b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01a0f	03 c1		 add	 eax, ecx
  01a11	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01a15	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01a1a	48 83 c0 01	 add	 rax, 1
  01a1e	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01a23	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01a27	83 c0 08	 add	 eax, 8
  01a2a	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01a2e	33 c0		 xor	 eax, eax
  01a30	85 c0		 test	 eax, eax
  01a32	75 ab		 jne	 SHORT $LN198@inflate
  01a34	eb 9b		 jmp	 SHORT $LN200@inflate
$LN199@inflate:
  01a36	33 c0		 xor	 eax, eax
  01a38	85 c0		 test	 eax, eax
  01a3a	75 95		 jne	 SHORT $LN203@inflate
$LN194@inflate:

; 935  :                         DROPBITS(here.bits);

  01a3c	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01a41	0f b6 c8	 movzx	 ecx, al
  01a44	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01a48	d3 e8		 shr	 eax, cl
  01a4a	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01a4e	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01a53	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01a57	2b c1		 sub	 eax, ecx
  01a59	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01a5d	33 c0		 xor	 eax, eax
  01a5f	85 c0		 test	 eax, eax
  01a61	75 d9		 jne	 SHORT $LN194@inflate

; 936  :                         if (state->have == 0) {

  01a63	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a6b	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  01a6f	75 26		 jne	 SHORT $LN191@inflate

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  01a71	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01a79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01a80	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 938  :                             state->mode = BAD;

  01a84	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a8c	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 939  :                             break;

  01a92	e9 8d 02 00 00	 jmp	 $LN226@inflate
$LN191@inflate:

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];

  01a97	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a9f	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01aa2	83 e8 01	 sub	 eax, 1
  01aa5	8b c8		 mov	 ecx, eax
  01aa7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01aaf	0f b7 84 48 88
	00 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+136]
  01ab7	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 942  :                         copy = 3 + BITS(2);

  01abb	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01abf	83 e0 03	 and	 eax, 3
  01ac2	83 c0 03	 add	 eax, 3
  01ac5	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN190@inflate:

; 943  :                         DROPBITS(2);

  01ac9	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01acd	c1 e8 02	 shr	 eax, 2
  01ad0	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01ad4	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01ad8	83 e8 02	 sub	 eax, 2
  01adb	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01adf	33 c0		 xor	 eax, eax
  01ae1	85 c0		 test	 eax, eax
  01ae3	75 e4		 jne	 SHORT $LN190@inflate

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  01ae5	e9 9b 01 00 00	 jmp	 $LN187@inflate
$LN204@inflate:
  01aea	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  01aef	83 f8 11	 cmp	 eax, 17
  01af2	0f 85 c9 00 00
	00		 jne	 $LN186@inflate
$LN185@inflate:
$LN182@inflate:

; 946  :                         NEEDBITS(here.bits + 3);

  01af8	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01afd	83 c0 03	 add	 eax, 3
  01b00	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  01b04	73 57		 jae	 SHORT $LN181@inflate
$LN180@inflate:
  01b06	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01b0b	75 05		 jne	 SHORT $LN177@inflate
  01b0d	e9 e0 11 00 00	 jmp	 $inf_leave$78295
$LN177@inflate:
  01b12	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01b16	83 e8 01	 sub	 eax, 1
  01b19	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01b1d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01b22	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01b25	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01b29	0f b6 c8	 movzx	 ecx, al
  01b2c	8b c2		 mov	 eax, edx
  01b2e	d3 e0		 shl	 eax, cl
  01b30	8b c8		 mov	 ecx, eax
  01b32	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b36	03 c1		 add	 eax, ecx
  01b38	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01b3c	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01b41	48 83 c0 01	 add	 rax, 1
  01b45	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01b4a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01b4e	83 c0 08	 add	 eax, 8
  01b51	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01b55	33 c0		 xor	 eax, eax
  01b57	85 c0		 test	 eax, eax
  01b59	75 ab		 jne	 SHORT $LN180@inflate
  01b5b	eb 9b		 jmp	 SHORT $LN182@inflate
$LN181@inflate:
  01b5d	33 c0		 xor	 eax, eax
  01b5f	85 c0		 test	 eax, eax
  01b61	75 95		 jne	 SHORT $LN185@inflate
$LN176@inflate:

; 947  :                         DROPBITS(here.bits);

  01b63	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01b68	0f b6 c8	 movzx	 ecx, al
  01b6b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b6f	d3 e8		 shr	 eax, cl
  01b71	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01b75	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01b7a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01b7e	2b c1		 sub	 eax, ecx
  01b80	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01b84	33 c0		 xor	 eax, eax
  01b86	85 c0		 test	 eax, eax
  01b88	75 d9		 jne	 SHORT $LN176@inflate

; 948  :                         len = 0;

  01b8a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 949  :                         copy = 3 + BITS(3);

  01b92	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b96	83 e0 07	 and	 eax, 7
  01b99	83 c0 03	 add	 eax, 3
  01b9c	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN173@inflate:

; 950  :                         DROPBITS(3);

  01ba0	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01ba4	c1 e8 03	 shr	 eax, 3
  01ba7	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01bab	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01baf	83 e8 03	 sub	 eax, 3
  01bb2	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01bb6	33 c0		 xor	 eax, eax
  01bb8	85 c0		 test	 eax, eax
  01bba	75 e4		 jne	 SHORT $LN173@inflate

; 951  :                     }
; 952  :                     else {

  01bbc	e9 c4 00 00 00	 jmp	 $LN170@inflate
$LN186@inflate:
$LN169@inflate:
$LN166@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  01bc1	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01bc6	83 c0 07	 add	 eax, 7
  01bc9	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  01bcd	73 57		 jae	 SHORT $LN165@inflate
$LN164@inflate:
  01bcf	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01bd4	75 05		 jne	 SHORT $LN161@inflate
  01bd6	e9 17 11 00 00	 jmp	 $inf_leave$78295
$LN161@inflate:
  01bdb	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01bdf	83 e8 01	 sub	 eax, 1
  01be2	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01be6	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01beb	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01bee	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01bf2	0f b6 c8	 movzx	 ecx, al
  01bf5	8b c2		 mov	 eax, edx
  01bf7	d3 e0		 shl	 eax, cl
  01bf9	8b c8		 mov	 ecx, eax
  01bfb	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01bff	03 c1		 add	 eax, ecx
  01c01	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01c05	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01c0a	48 83 c0 01	 add	 rax, 1
  01c0e	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01c13	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01c17	83 c0 08	 add	 eax, 8
  01c1a	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01c1e	33 c0		 xor	 eax, eax
  01c20	85 c0		 test	 eax, eax
  01c22	75 ab		 jne	 SHORT $LN164@inflate
  01c24	eb 9b		 jmp	 SHORT $LN166@inflate
$LN165@inflate:
  01c26	33 c0		 xor	 eax, eax
  01c28	85 c0		 test	 eax, eax
  01c2a	75 95		 jne	 SHORT $LN169@inflate
$LN160@inflate:

; 954  :                         DROPBITS(here.bits);

  01c2c	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01c31	0f b6 c8	 movzx	 ecx, al
  01c34	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c38	d3 e8		 shr	 eax, cl
  01c3a	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01c3e	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  01c43	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01c47	2b c1		 sub	 eax, ecx
  01c49	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01c4d	33 c0		 xor	 eax, eax
  01c4f	85 c0		 test	 eax, eax
  01c51	75 d9		 jne	 SHORT $LN160@inflate

; 955  :                         len = 0;

  01c53	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 956  :                         copy = 11 + BITS(7);

  01c5b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c5f	83 e0 7f	 and	 eax, 127		; 0000007fH
  01c62	83 c0 0b	 add	 eax, 11
  01c65	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN157@inflate:

; 957  :                         DROPBITS(7);

  01c69	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c6d	c1 e8 07	 shr	 eax, 7
  01c70	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01c74	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01c78	83 e8 07	 sub	 eax, 7
  01c7b	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01c7f	33 c0		 xor	 eax, eax
  01c81	85 c0		 test	 eax, eax
  01c83	75 e4		 jne	 SHORT $LN157@inflate
$LN170@inflate:
$LN187@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  01c85	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c8d	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  01c90	03 54 24 6c	 add	 edx, DWORD PTR copy$[rsp]
  01c94	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c9c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01c9f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01ca7	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  01caa	3b d0		 cmp	 edx, eax
  01cac	76 23		 jbe	 SHORT $LN154@inflate

; 960  :                         strm->msg = (char *)"invalid bit length repeat";

  01cae	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01cb6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01cbd	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 961  :                         state->mode = BAD;

  01cc1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cc9	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 962  :                         break;

  01ccf	eb 53		 jmp	 SHORT $LN226@inflate
$LN154@inflate:
$LN153@inflate:

; 963  :                     }
; 964  :                     while (copy--)

  01cd1	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  01cd5	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01cd9	83 e8 01	 sub	 eax, 1
  01cdc	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
  01ce0	85 c9		 test	 ecx, ecx
  01ce2	74 3b		 je	 SHORT $LN152@inflate

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  01ce4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cec	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  01cef	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01cf7	0f b7 44 24 48	 movzx	 eax, WORD PTR len$[rsp]
  01cfc	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  01d04	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d0c	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  01d0f	83 c1 01	 add	 ecx, 1
  01d12	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d1a	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  01d1d	eb b2		 jmp	 SHORT $LN153@inflate
$LN152@inflate:
$LN205@inflate:

; 966  :                 }
; 967  :             }

  01d1f	e9 04 fb ff ff	 jmp	 $LN227@inflate
$LN226@inflate:

; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  01d24	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d2c	83 38 1d	 cmp	 DWORD PTR [rax], 29
  01d2f	75 05		 jne	 SHORT $LN151@inflate
  01d31	e9 b7 0f 00 00	 jmp	 $LN498@inflate
$LN151@inflate:

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  01d36	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d3e	0f b7 80 88 02
	00 00		 movzx	 eax, WORD PTR [rax+648]
  01d45	85 c0		 test	 eax, eax
  01d47	75 26		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  01d49	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01d51	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  01d58	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 975  :                 state->mode = BAD;

  01d5c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d64	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 976  :                 break;

  01d6a	e9 7e 0f 00 00	 jmp	 $LN498@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;

  01d6f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d77	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  01d7e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d86	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 983  :             state->lencode = (code const FAR *)(state->next);

  01d8d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d95	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d9d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01da4	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 984  :             state->lenbits = 9;

  01da8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01db0	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  01db7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01dbf	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  01dc6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01dce	48 83 c0 68	 add	 rax, 104		; 00000068H
  01dd2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01dda	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01de1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01de9	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  01df0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01df5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01dfa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e02	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  01e06	b9 01 00 00 00	 mov	 ecx, 1
  01e0b	e8 00 00 00 00	 call	 inflate_table
  01e10	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 987  :             if (ret) {

  01e14	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  01e19	74 26		 je	 SHORT $LN149@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  01e1b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01e23	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  01e2a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 989  :                 state->mode = BAD;

  01e2e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e36	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 990  :                 break;

  01e3c	e9 ac 0e 00 00	 jmp	 $LN498@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  01e41	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01e49	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e51	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01e58	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 993  :             state->distbits = 6;

  01e5c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e64	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  01e6b	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR state$[rsp]
  01e73	49 81 c2 08 03
	00 00		 add	 r10, 776		; 00000308H
  01e7a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR state$[rsp]
  01e82	49 83 c0 6c	 add	 r8, 108			; 0000006cH
  01e86	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01e8e	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01e95	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e9d	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  01ea0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ea8	48 8d 94 48 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx*2+136]
  01eb0	4c 89 54 24 28	 mov	 QWORD PTR [rsp+40], r10
  01eb5	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  01eba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ec2	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01ec6	b9 02 00 00 00	 mov	 ecx, 2
  01ecb	e8 00 00 00 00	 call	 inflate_table
  01ed0	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 996  :             if (ret) {

  01ed4	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  01ed9	74 26		 je	 SHORT $LN148@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  01edb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01ee3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  01eea	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 998  :                 state->mode = BAD;

  01eee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ef6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 999  :                 break;

  01efc	e9 ec 0d 00 00	 jmp	 $LN498@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;

  01f01	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f09	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19

; 1003 :             if (flush == Z_TREES) goto inf_leave;

  01f0f	83 bc 24 c8 00
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01f17	75 05		 jne	 SHORT $LN147@inflate
  01f19	e9 d4 0d 00 00	 jmp	 $inf_leave$78295
$LN147@inflate:
$LN146@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  01f1e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f26	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  01f2c	83 7c 24 40 06	 cmp	 DWORD PTR have$[rsp], 6
  01f31	0f 82 09 01 00
	00		 jb	 $LN144@inflate
  01f37	81 7c 24 50 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  01f3f	0f 82 fb 00 00
	00		 jb	 $LN144@inflate
$LN143@inflate:

; 1008 :                 RESTORE();

  01f45	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01f4d	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01f52	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  01f56	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01f5e	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  01f62	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  01f65	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01f6d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01f72	48 89 01	 mov	 QWORD PTR [rcx], rax
  01f75	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01f7d	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01f81	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  01f84	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01f8c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01f90	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  01f93	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01f9b	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01f9f	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  01fa2	33 c0		 xor	 eax, eax
  01fa4	85 c0		 test	 eax, eax
  01fa6	75 9d		 jne	 SHORT $LN143@inflate

; 1009 :                 inflate_fast(strm, out);

  01fa8	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  01fac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01fb4	e8 00 00 00 00	 call	 inflate_fast
$LN140@inflate:

; 1010 :                 LOAD();

  01fb9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fc1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01fc5	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01fca	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fd2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01fd5	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax
  01fd9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fe1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01fe4	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01fe9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01ff1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01ff4	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01ff8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02000	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  02003	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02007	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0200f	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  02012	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02016	33 c0		 xor	 eax, eax
  02018	85 c0		 test	 eax, eax
  0201a	75 9d		 jne	 SHORT $LN140@inflate

; 1011 :                 if (state->mode == TYPE)

  0201c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02024	83 38 0b	 cmp	 DWORD PTR [rax], 11
  02027	75 12		 jne	 SHORT $LN137@inflate

; 1012 :                     state->back = -1;

  02029	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02031	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1
$LN137@inflate:

; 1013 :                 break;

  0203b	e9 ad 0c 00 00	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;

  02040	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02048	c7 80 dc 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+7132], 0
$LN136@inflate:

; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  02052	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0205a	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  0205d	b8 01 00 00 00	 mov	 eax, 1
  02062	d3 e0		 shl	 eax, cl
  02064	8b c8		 mov	 ecx, eax
  02066	83 e9 01	 sub	 ecx, 1
  02069	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0206d	23 c1		 and	 eax, ecx
  0206f	8b c8		 mov	 ecx, eax
  02071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02079	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0207d	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  02080	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  02084	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02089	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  0208d	77 02		 ja	 SHORT $LN134@inflate
  0208f	eb 5a		 jmp	 SHORT $LN135@inflate
$LN134@inflate:
$LN133@inflate:

; 1019 :                 PULLBYTE();

  02091	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02096	75 05		 jne	 SHORT $LN130@inflate
  02098	e9 55 0c 00 00	 jmp	 $inf_leave$78295
$LN130@inflate:
  0209d	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  020a1	83 e8 01	 sub	 eax, 1
  020a4	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  020a8	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  020ad	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  020b0	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  020b4	0f b6 c8	 movzx	 ecx, al
  020b7	8b c2		 mov	 eax, edx
  020b9	d3 e0		 shl	 eax, cl
  020bb	8b c8		 mov	 ecx, eax
  020bd	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  020c1	03 c1		 add	 eax, ecx
  020c3	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  020c7	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  020cc	48 83 c0 01	 add	 rax, 1
  020d0	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  020d5	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  020d9	83 c0 08	 add	 eax, 8
  020dc	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  020e0	33 c0		 xor	 eax, eax
  020e2	85 c0		 test	 eax, eax
  020e4	75 ab		 jne	 SHORT $LN133@inflate

; 1020 :             }

  020e6	e9 67 ff ff ff	 jmp	 $LN136@inflate
$LN135@inflate:

; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  020eb	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  020f0	85 c0		 test	 eax, eax
  020f2	0f 84 1a 01 00
	00		 je	 $LN129@inflate
  020f8	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  020fd	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02102	85 c0		 test	 eax, eax
  02104	0f 85 08 01 00
	00		 jne	 $LN129@inflate

; 1022 :                 last = here;

  0210a	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  0210e	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN128@inflate:

; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  02112	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  02118	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0211d	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  02122	03 c8		 add	 ecx, eax
  02124	b8 01 00 00 00	 mov	 eax, 1
  02129	d3 e0		 shl	 eax, cl
  0212b	83 e8 01	 sub	 eax, 1
  0212e	8b 54 24 64	 mov	 edx, DWORD PTR hold$[rsp]
  02132	23 d0		 and	 edx, eax
  02134	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02139	0f b6 c8	 movzx	 ecx, al
  0213c	8b c2		 mov	 eax, edx
  0213e	d3 e8		 shr	 eax, cl
  02140	8b c8		 mov	 ecx, eax
  02142	41 8b c0	 mov	 eax, r8d
  02145	03 c1		 add	 eax, ecx
  02147	8b c8		 mov	 ecx, eax
  02149	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02151	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  02155	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  02158	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0215c	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02161	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  02166	03 c1		 add	 eax, ecx
  02168	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  0216c	77 02		 ja	 SHORT $LN126@inflate
  0216e	eb 5a		 jmp	 SHORT $LN127@inflate
$LN126@inflate:
$LN125@inflate:

; 1027 :                     PULLBYTE();

  02170	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02175	75 05		 jne	 SHORT $LN122@inflate
  02177	e9 76 0b 00 00	 jmp	 $inf_leave$78295
$LN122@inflate:
  0217c	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02180	83 e8 01	 sub	 eax, 1
  02183	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02187	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0218c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0218f	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02193	0f b6 c8	 movzx	 ecx, al
  02196	8b c2		 mov	 eax, edx
  02198	d3 e0		 shl	 eax, cl
  0219a	8b c8		 mov	 ecx, eax
  0219c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  021a0	03 c1		 add	 eax, ecx
  021a2	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  021a6	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  021ab	48 83 c0 01	 add	 rax, 1
  021af	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  021b4	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  021b8	83 c0 08	 add	 eax, 8
  021bb	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  021bf	33 c0		 xor	 eax, eax
  021c1	85 c0		 test	 eax, eax
  021c3	75 ab		 jne	 SHORT $LN125@inflate

; 1028 :                 }

  021c5	e9 48 ff ff ff	 jmp	 $LN128@inflate
$LN127@inflate:
$LN121@inflate:

; 1029 :                 DROPBITS(last.bits);

  021ca	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  021cf	0f b6 c8	 movzx	 ecx, al
  021d2	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  021d6	d3 e8		 shr	 eax, cl
  021d8	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  021dc	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  021e1	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  021e5	2b c1		 sub	 eax, ecx
  021e7	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  021eb	33 c0		 xor	 eax, eax
  021ed	85 c0		 test	 eax, eax
  021ef	75 d9		 jne	 SHORT $LN121@inflate

; 1030 :                 state->back += last.bits;

  021f1	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  021f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  021fe	03 88 dc 1b 00
	00		 add	 ecx, DWORD PTR [rax+7132]
  02204	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0220c	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx
$LN129@inflate:
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  02212	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02217	0f b6 c8	 movzx	 ecx, al
  0221a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0221e	d3 e8		 shr	 eax, cl
  02220	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02224	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  02229	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0222d	2b c1		 sub	 eax, ecx
  0222f	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02233	33 c0		 xor	 eax, eax
  02235	85 c0		 test	 eax, eax
  02237	75 d9		 jne	 SHORT $LN118@inflate

; 1033 :             state->back += here.bits;

  02239	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0223e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02246	03 88 dc 1b 00
	00		 add	 ecx, DWORD PTR [rax+7132]
  0224c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02254	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx

; 1034 :             state->length = (unsigned)here.val;

  0225a	0f b7 4c 24 3e	 movzx	 ecx, WORD PTR here$[rsp+2]
  0225f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02267	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 1035 :             if ((int)(here.op) == 0) {

  0226a	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0226f	85 c0		 test	 eax, eax
  02271	75 13		 jne	 SHORT $LN115@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  02273	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0227b	c7 00 19 00 00
	00		 mov	 DWORD PTR [rax], 25

; 1040 :                 break;

  02281	e9 67 0a 00 00	 jmp	 $LN498@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  02286	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0228b	83 e0 20	 and	 eax, 32			; 00000020H
  0228e	85 c0		 test	 eax, eax
  02290	74 25		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  02292	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0229a	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1

; 1045 :                 state->mode = TYPE;

  022a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022ac	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 1046 :                 break;

  022b2	e9 36 0a 00 00	 jmp	 $LN498@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  022b7	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  022bc	83 e0 40	 and	 eax, 64			; 00000040H
  022bf	85 c0		 test	 eax, eax
  022c1	74 26		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  022c3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  022cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  022d2	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1050 :                 state->mode = BAD;

  022d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022de	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1051 :                 break;

  022e4	e9 04 0a 00 00	 jmp	 $LN498@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  022e9	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR here$[rsp]
  022ee	83 e1 0f	 and	 ecx, 15
  022f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022f9	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1054 :             state->mode = LENEXT;

  022fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02304	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  0230a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02312	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  02316	0f 84 f9 00 00
	00		 je	 $LN111@inflate
$LN110@inflate:
$LN107@inflate:

; 1057 :                 NEEDBITS(state->extra);

  0231c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02324	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02327	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  0232b	73 57		 jae	 SHORT $LN106@inflate
$LN105@inflate:
  0232d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02332	75 05		 jne	 SHORT $LN102@inflate
  02334	e9 b9 09 00 00	 jmp	 $inf_leave$78295
$LN102@inflate:
  02339	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0233d	83 e8 01	 sub	 eax, 1
  02340	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02344	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02349	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0234c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02350	0f b6 c8	 movzx	 ecx, al
  02353	8b c2		 mov	 eax, edx
  02355	d3 e0		 shl	 eax, cl
  02357	8b c8		 mov	 ecx, eax
  02359	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0235d	03 c1		 add	 eax, ecx
  0235f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02363	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02368	48 83 c0 01	 add	 rax, 1
  0236c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02371	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02375	83 c0 08	 add	 eax, 8
  02378	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0237c	33 c0		 xor	 eax, eax
  0237e	85 c0		 test	 eax, eax
  02380	75 ab		 jne	 SHORT $LN105@inflate
  02382	eb 98		 jmp	 SHORT $LN107@inflate
$LN106@inflate:
  02384	33 c0		 xor	 eax, eax
  02386	85 c0		 test	 eax, eax
  02388	75 92		 jne	 SHORT $LN110@inflate

; 1058 :                 state->length += BITS(state->extra);

  0238a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02392	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  02395	b8 01 00 00 00	 mov	 eax, 1
  0239a	d3 e0		 shl	 eax, cl
  0239c	83 e8 01	 sub	 eax, 1
  0239f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  023a3	23 c8		 and	 ecx, eax
  023a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023ad	03 48 48	 add	 ecx, DWORD PTR [rax+72]
  023b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023b8	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN101@inflate:

; 1059 :                 DROPBITS(state->extra);

  023bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023c3	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  023c6	0f b6 c8	 movzx	 ecx, al
  023c9	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  023cd	d3 e8		 shr	 eax, cl
  023cf	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  023d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023db	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  023de	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  023e2	2b c1		 sub	 eax, ecx
  023e4	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  023e8	33 c0		 xor	 eax, eax
  023ea	85 c0		 test	 eax, eax
  023ec	75 cd		 jne	 SHORT $LN101@inflate

; 1060 :                 state->back += state->extra;

  023ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023f6	8b 88 dc 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7132]
  023fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02404	03 48 50	 add	 ecx, DWORD PTR [rax+80]
  02407	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0240f	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  02415	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0241d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02425	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02428	89 81 e0 1b 00
	00		 mov	 DWORD PTR [rcx+7136], eax

; 1064 :             state->mode = DIST;

  0242e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02436	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN98@inflate:
$LN97@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  0243c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02444	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  02447	b8 01 00 00 00	 mov	 eax, 1
  0244c	d3 e0		 shl	 eax, cl
  0244e	8b c8		 mov	 ecx, eax
  02450	83 e9 01	 sub	 ecx, 1
  02453	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02457	23 c1		 and	 eax, ecx
  02459	8b c8		 mov	 ecx, eax
  0245b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02463	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  02467	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0246a	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  0246e	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02473	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  02477	77 02		 ja	 SHORT $LN95@inflate
  02479	eb 5a		 jmp	 SHORT $LN96@inflate
$LN95@inflate:
$LN94@inflate:

; 1069 :                 PULLBYTE();

  0247b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02480	75 05		 jne	 SHORT $LN91@inflate
  02482	e9 6b 08 00 00	 jmp	 $inf_leave$78295
$LN91@inflate:
  02487	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0248b	83 e8 01	 sub	 eax, 1
  0248e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02492	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02497	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0249a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0249e	0f b6 c8	 movzx	 ecx, al
  024a1	8b c2		 mov	 eax, edx
  024a3	d3 e0		 shl	 eax, cl
  024a5	8b c8		 mov	 ecx, eax
  024a7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  024ab	03 c1		 add	 eax, ecx
  024ad	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  024b1	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  024b6	48 83 c0 01	 add	 rax, 1
  024ba	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  024bf	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  024c3	83 c0 08	 add	 eax, 8
  024c6	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  024ca	33 c0		 xor	 eax, eax
  024cc	85 c0		 test	 eax, eax
  024ce	75 ab		 jne	 SHORT $LN94@inflate

; 1070 :             }

  024d0	e9 67 ff ff ff	 jmp	 $LN97@inflate
$LN96@inflate:

; 1071 :             if ((here.op & 0xf0) == 0) {

  024d5	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  024da	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  024df	85 c0		 test	 eax, eax
  024e1	0f 85 08 01 00
	00		 jne	 $LN90@inflate

; 1072 :                 last = here;

  024e7	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  024eb	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN89@inflate:

; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  024ef	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  024f5	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  024fa	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  024ff	03 c8		 add	 ecx, eax
  02501	b8 01 00 00 00	 mov	 eax, 1
  02506	d3 e0		 shl	 eax, cl
  02508	83 e8 01	 sub	 eax, 1
  0250b	8b 54 24 64	 mov	 edx, DWORD PTR hold$[rsp]
  0250f	23 d0		 and	 edx, eax
  02511	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02516	0f b6 c8	 movzx	 ecx, al
  02519	8b c2		 mov	 eax, edx
  0251b	d3 e8		 shr	 eax, cl
  0251d	8b c8		 mov	 ecx, eax
  0251f	41 8b c0	 mov	 eax, r8d
  02522	03 c1		 add	 eax, ecx
  02524	8b c8		 mov	 ecx, eax
  02526	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0252e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  02532	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  02535	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  02539	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0253e	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  02543	03 c1		 add	 eax, ecx
  02545	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  02549	77 02		 ja	 SHORT $LN87@inflate
  0254b	eb 5a		 jmp	 SHORT $LN88@inflate
$LN87@inflate:
$LN86@inflate:

; 1077 :                     PULLBYTE();

  0254d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02552	75 05		 jne	 SHORT $LN83@inflate
  02554	e9 99 07 00 00	 jmp	 $inf_leave$78295
$LN83@inflate:
  02559	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0255d	83 e8 01	 sub	 eax, 1
  02560	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02564	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02569	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0256c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02570	0f b6 c8	 movzx	 ecx, al
  02573	8b c2		 mov	 eax, edx
  02575	d3 e0		 shl	 eax, cl
  02577	8b c8		 mov	 ecx, eax
  02579	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0257d	03 c1		 add	 eax, ecx
  0257f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02583	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02588	48 83 c0 01	 add	 rax, 1
  0258c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02591	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02595	83 c0 08	 add	 eax, 8
  02598	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0259c	33 c0		 xor	 eax, eax
  0259e	85 c0		 test	 eax, eax
  025a0	75 ab		 jne	 SHORT $LN86@inflate

; 1078 :                 }

  025a2	e9 48 ff ff ff	 jmp	 $LN89@inflate
$LN88@inflate:
$LN82@inflate:

; 1079 :                 DROPBITS(last.bits);

  025a7	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  025ac	0f b6 c8	 movzx	 ecx, al
  025af	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  025b3	d3 e8		 shr	 eax, cl
  025b5	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  025b9	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  025be	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  025c2	2b c1		 sub	 eax, ecx
  025c4	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  025c8	33 c0		 xor	 eax, eax
  025ca	85 c0		 test	 eax, eax
  025cc	75 d9		 jne	 SHORT $LN82@inflate

; 1080 :                 state->back += last.bits;

  025ce	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  025d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025db	03 88 dc 1b 00
	00		 add	 ecx, DWORD PTR [rax+7132]
  025e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025e9	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx
$LN90@inflate:
$LN79@inflate:

; 1081 :             }
; 1082 :             DROPBITS(here.bits);

  025ef	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  025f4	0f b6 c8	 movzx	 ecx, al
  025f7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  025fb	d3 e8		 shr	 eax, cl
  025fd	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02601	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  02606	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0260a	2b c1		 sub	 eax, ecx
  0260c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02610	33 c0		 xor	 eax, eax
  02612	85 c0		 test	 eax, eax
  02614	75 d9		 jne	 SHORT $LN79@inflate

; 1083 :             state->back += here.bits;

  02616	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0261b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02623	03 88 dc 1b 00
	00		 add	 ecx, DWORD PTR [rax+7132]
  02629	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02631	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx

; 1084 :             if (here.op & 64) {

  02637	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0263c	83 e0 40	 and	 eax, 64			; 00000040H
  0263f	85 c0		 test	 eax, eax
  02641	74 26		 je	 SHORT $LN76@inflate

; 1085 :                 strm->msg = (char *)"invalid distance code";

  02643	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0264b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  02652	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1086 :                 state->mode = BAD;

  02656	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0265e	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1087 :                 break;

  02664	e9 84 06 00 00	 jmp	 $LN498@inflate
$LN76@inflate:

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  02669	0f b7 4c 24 3e	 movzx	 ecx, WORD PTR here$[rsp+2]
  0266e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02676	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 1090 :             state->extra = (unsigned)(here.op) & 15;

  02679	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR here$[rsp]
  0267e	83 e1 0f	 and	 ecx, 15
  02681	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02689	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1091 :             state->mode = DISTEXT;

  0268c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02694	c7 00 17 00 00
	00		 mov	 DWORD PTR [rax], 23
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  0269a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026a2	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  026a6	0f 84 f9 00 00
	00		 je	 $LN74@inflate
$LN73@inflate:
$LN70@inflate:

; 1094 :                 NEEDBITS(state->extra);

  026ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026b4	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  026b7	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  026bb	73 57		 jae	 SHORT $LN69@inflate
$LN68@inflate:
  026bd	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  026c2	75 05		 jne	 SHORT $LN65@inflate
  026c4	e9 29 06 00 00	 jmp	 $inf_leave$78295
$LN65@inflate:
  026c9	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  026cd	83 e8 01	 sub	 eax, 1
  026d0	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  026d4	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  026d9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  026dc	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  026e0	0f b6 c8	 movzx	 ecx, al
  026e3	8b c2		 mov	 eax, edx
  026e5	d3 e0		 shl	 eax, cl
  026e7	8b c8		 mov	 ecx, eax
  026e9	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  026ed	03 c1		 add	 eax, ecx
  026ef	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  026f3	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  026f8	48 83 c0 01	 add	 rax, 1
  026fc	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02701	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02705	83 c0 08	 add	 eax, 8
  02708	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0270c	33 c0		 xor	 eax, eax
  0270e	85 c0		 test	 eax, eax
  02710	75 ab		 jne	 SHORT $LN68@inflate
  02712	eb 98		 jmp	 SHORT $LN70@inflate
$LN69@inflate:
  02714	33 c0		 xor	 eax, eax
  02716	85 c0		 test	 eax, eax
  02718	75 92		 jne	 SHORT $LN73@inflate

; 1095 :                 state->offset += BITS(state->extra);

  0271a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02722	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  02725	b8 01 00 00 00	 mov	 eax, 1
  0272a	d3 e0		 shl	 eax, cl
  0272c	83 e8 01	 sub	 eax, 1
  0272f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02733	23 c8		 and	 ecx, eax
  02735	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0273d	03 48 4c	 add	 ecx, DWORD PTR [rax+76]
  02740	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02748	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN64@inflate:

; 1096 :                 DROPBITS(state->extra);

  0274b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02753	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02756	0f b6 c8	 movzx	 ecx, al
  02759	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0275d	d3 e8		 shr	 eax, cl
  0275f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02763	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0276b	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0276e	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02772	2b c1		 sub	 eax, ecx
  02774	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02778	33 c0		 xor	 eax, eax
  0277a	85 c0		 test	 eax, eax
  0277c	75 cd		 jne	 SHORT $LN64@inflate

; 1097 :                 state->back += state->extra;

  0277e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02786	8b 88 dc 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7132]
  0278c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02794	03 48 50	 add	 ecx, DWORD PTR [rax+80]
  02797	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0279f	89 88 dc 1b 00
	00		 mov	 DWORD PTR [rax+7132], ecx
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  027a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027ad	c7 00 18 00 00
	00		 mov	 DWORD PTR [rax], 24
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  027b3	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  027b8	75 05		 jne	 SHORT $LN60@inflate
  027ba	e9 33 05 00 00	 jmp	 $inf_leave$78295
$LN60@inflate:

; 1110 :             copy = out - left;

  027bf	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  027c3	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  027c7	2b c1		 sub	 eax, ecx
  027c9	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1111 :             if (state->offset > copy) {         /* copy from window */

  027cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  027d5	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  027d9	39 41 4c	 cmp	 DWORD PTR [rcx+76], eax
  027dc	0f 86 ef 00 00
	00		 jbe	 $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  027e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027ea	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  027ee	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  027f1	2b c1		 sub	 eax, ecx
  027f3	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1113 :                 if (copy > state->whave) {

  027f7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027ff	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  02802	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02806	76 37		 jbe	 SHORT $LN58@inflate

; 1114 :                     if (state->sane) {

  02808	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02810	83 b8 d8 1b 00
	00 00		 cmp	 DWORD PTR [rax+7128], 0
  02817	74 26		 je	 SHORT $LN57@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  02819	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02821	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  02828	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1116 :                         state->mode = BAD;

  0282c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02834	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1117 :                         break;

  0283a	e9 ae 04 00 00	 jmp	 $LN498@inflate
$LN57@inflate:
$LN58@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  0283f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02847	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0284a	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  0284e	76 3b		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;

  02850	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02858	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  0285b	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  0285f	2b c1		 sub	 eax, ecx
  02861	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1135 :                     from = state->window + (state->wsize - copy);

  02865	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0286d	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  02871	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  02874	2b c1		 sub	 eax, ecx
  02876	8b c0		 mov	 eax, eax
  02878	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02880	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  02884	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1136 :                 }
; 1137 :                 else

  02889	eb 24		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  0288b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02893	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  02897	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0289a	2b c1		 sub	 eax, ecx
  0289c	8b c0		 mov	 eax, eax
  0289e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  028a6	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  028aa	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax
$LN55@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  028af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028b7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  028ba	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  028be	76 0f		 jbe	 SHORT $LN54@inflate
  028c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028c8	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  028cb	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN54@inflate:

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  028cf	eb 27		 jmp	 SHORT $LN53@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;

  028d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028d9	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  028dc	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  028e1	48 2b c1	 sub	 rax, rcx
  028e4	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1143 :                 copy = state->length;

  028e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028f1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  028f4	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  028f8	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  028fc	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02900	76 08		 jbe	 SHORT $LN52@inflate
  02902	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02906	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN52@inflate:

; 1146 :             left -= copy;

  0290a	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0290e	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02912	2b c1		 sub	 eax, ecx
  02914	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 1147 :             state->length -= copy;

  02918	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02920	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  02924	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  02927	2b c8		 sub	 ecx, eax
  02929	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02931	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  02934	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  02939	48 8b 44 24 70	 mov	 rax, QWORD PTR from$[rsp]
  0293e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02941	88 01		 mov	 BYTE PTR [rcx], al
  02943	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  02948	48 83 c0 01	 add	 rax, 1
  0294c	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  02951	48 8b 44 24 70	 mov	 rax, QWORD PTR from$[rsp]
  02956	48 83 c0 01	 add	 rax, 1
  0295a	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1150 :             } while (--copy);

  0295f	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  02963	83 e8 01	 sub	 eax, 1
  02966	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
  0296a	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  0296f	75 c3		 jne	 SHORT $LN51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  02971	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02979	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0297d	75 0e		 jne	 SHORT $LN48@inflate
  0297f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02987	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN48@inflate:

; 1152 :             break;

  0298d	e9 5b 03 00 00	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  02992	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  02997	75 05		 jne	 SHORT $LN46@inflate
  02999	e9 54 03 00 00	 jmp	 $inf_leave$78295
$LN46@inflate:

; 1155 :             *put++ = (unsigned char)(state->length);

  0299e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  029a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029ab	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  029af	88 01		 mov	 BYTE PTR [rcx], al
  029b1	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  029b6	48 83 c0 01	 add	 rax, 1
  029ba	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 1156 :             left--;

  029bf	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  029c3	83 e8 01	 sub	 eax, 1
  029c6	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 1157 :             state->mode = LEN;

  029ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029d2	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 1158 :             break;

  029d8	e9 10 03 00 00	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  029dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029e5	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  029e9	0f 84 e8 01 00
	00		 je	 $LN44@inflate
$LN43@inflate:
$LN40@inflate:

; 1161 :                 NEEDBITS(32);

  029ef	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  029f4	73 57		 jae	 SHORT $LN39@inflate
$LN38@inflate:
  029f6	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  029fb	75 05		 jne	 SHORT $LN35@inflate
  029fd	e9 f0 02 00 00	 jmp	 $inf_leave$78295
$LN35@inflate:
  02a02	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02a06	83 e8 01	 sub	 eax, 1
  02a09	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02a0d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02a12	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  02a15	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02a19	0f b6 c8	 movzx	 ecx, al
  02a1c	8b c2		 mov	 eax, edx
  02a1e	d3 e0		 shl	 eax, cl
  02a20	8b c8		 mov	 ecx, eax
  02a22	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02a26	03 c1		 add	 eax, ecx
  02a28	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02a2c	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02a31	48 83 c0 01	 add	 rax, 1
  02a35	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02a3a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02a3e	83 c0 08	 add	 eax, 8
  02a41	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02a45	33 c0		 xor	 eax, eax
  02a47	85 c0		 test	 eax, eax
  02a49	75 ab		 jne	 SHORT $LN38@inflate
  02a4b	eb a2		 jmp	 SHORT $LN40@inflate
$LN39@inflate:
  02a4d	33 c0		 xor	 eax, eax
  02a4f	85 c0		 test	 eax, eax
  02a51	75 9c		 jne	 SHORT $LN43@inflate

; 1162 :                 out -= left;

  02a53	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  02a57	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02a5b	2b c1		 sub	 eax, ecx
  02a5d	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1163 :                 strm->total_out += out;

  02a61	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02a69	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02a6c	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02a70	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02a78	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1164 :                 state->total += out;

  02a7b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a83	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02a86	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02a8a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a92	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1165 :                 if (out)

  02a95	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02a9a	0f 84 84 00 00
	00		 je	 $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  02aa0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02aa8	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02aac	74 2a		 je	 SHORT $LN514@inflate
  02aae	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02ab2	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  02ab7	48 2b d0	 sub	 rdx, rax
  02aba	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02abf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ac7	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02aca	e8 00 00 00 00	 call	 crc32
  02acf	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv1266[rsp], eax
  02ad6	eb 28		 jmp	 SHORT $LN515@inflate
$LN514@inflate:
  02ad8	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02adc	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  02ae1	48 2b d0	 sub	 rdx, rax
  02ae4	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02ae9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02af1	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02af4	e8 00 00 00 00	 call	 adler32
  02af9	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv1266[rsp], eax
$LN515@inflate:
  02b00	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02b08	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv1266[rsp]
  02b0f	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02b12	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b1a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv1266[rsp]
  02b21	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN34@inflate:

; 1168 :                 out = left;

  02b24	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02b28	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  02b2c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b34	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02b38	74 0d		 je	 SHORT $LN516@inflate
  02b3a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02b3e	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv1280[rsp], eax
  02b45	eb 40		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  02b47	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02b4b	c1 e8 18	 shr	 eax, 24
  02b4e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02b53	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02b57	c1 e9 08	 shr	 ecx, 8
  02b5a	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02b60	03 c1		 add	 eax, ecx
  02b62	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02b66	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02b6c	c1 e1 08	 shl	 ecx, 8
  02b6f	03 c1		 add	 eax, ecx
  02b71	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02b75	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02b7b	c1 e1 18	 shl	 ecx, 24
  02b7e	03 c1		 add	 eax, ecx
  02b80	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv1280[rsp], eax
$LN517@inflate:
  02b87	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b8f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02b92	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR tv1280[rsp], eax
  02b99	74 26		 je	 SHORT $LN33@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  02b9b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02ba3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  02baa	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1175 :                     state->mode = BAD;

  02bae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02bb6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1176 :                     break;

  02bbc	e9 2c 01 00 00	 jmp	 $LN498@inflate
$LN33@inflate:
$LN32@inflate:

; 1177 :                 }
; 1178 :                 INITBITS();

  02bc1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02bc9	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02bd1	33 c0		 xor	 eax, eax
  02bd3	85 c0		 test	 eax, eax
  02bd5	75 ea		 jne	 SHORT $LN32@inflate
$LN44@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  02bd7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02bdf	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  02be5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02bed	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02bf1	0f 84 c0 00 00
	00		 je	 $LN28@inflate
  02bf7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02bff	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02c03	0f 84 ae 00 00
	00		 je	 $LN28@inflate
$LN27@inflate:
$LN24@inflate:

; 1185 :                 NEEDBITS(32);

  02c09	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02c0e	73 57		 jae	 SHORT $LN23@inflate
$LN22@inflate:
  02c10	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02c15	75 05		 jne	 SHORT $LN19@inflate
  02c17	e9 d6 00 00 00	 jmp	 $inf_leave$78295
$LN19@inflate:
  02c1c	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02c20	83 e8 01	 sub	 eax, 1
  02c23	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02c27	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02c2c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  02c2f	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02c33	0f b6 c8	 movzx	 ecx, al
  02c36	8b c2		 mov	 eax, edx
  02c38	d3 e0		 shl	 eax, cl
  02c3a	8b c8		 mov	 ecx, eax
  02c3c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02c40	03 c1		 add	 eax, ecx
  02c42	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02c46	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02c4b	48 83 c0 01	 add	 rax, 1
  02c4f	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02c54	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02c58	83 c0 08	 add	 eax, 8
  02c5b	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02c5f	33 c0		 xor	 eax, eax
  02c61	85 c0		 test	 eax, eax
  02c63	75 ab		 jne	 SHORT $LN22@inflate
  02c65	eb a2		 jmp	 SHORT $LN24@inflate
$LN23@inflate:
  02c67	33 c0		 xor	 eax, eax
  02c69	85 c0		 test	 eax, eax
  02c6b	75 9c		 jne	 SHORT $LN27@inflate

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  02c6d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c75	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02c78	39 44 24 64	 cmp	 DWORD PTR hold$[rsp], eax
  02c7c	74 23		 je	 SHORT $LN18@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  02c7e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02c86	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  02c8d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1188 :                     state->mode = BAD;

  02c91	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c99	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1189 :                     break;

  02c9f	eb 4c		 jmp	 SHORT $LN498@inflate
$LN18@inflate:
$LN17@inflate:

; 1190 :                 }
; 1191 :                 INITBITS();

  02ca1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02ca9	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02cb1	33 c0		 xor	 eax, eax
  02cb3	85 c0		 test	 eax, eax
  02cb5	75 ea		 jne	 SHORT $LN17@inflate
$LN28@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  02cb7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02cbf	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  02cc5	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 1198 :             goto inf_leave;

  02ccd	eb 23		 jmp	 SHORT $inf_leave$78295
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  02ccf	c7 44 24 60 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 1201 :             goto inf_leave;

  02cd7	eb 19		 jmp	 SHORT $inf_leave$78295
$LN12@inflate:

; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;

  02cd9	b8 fc ff ff ff	 mov	 eax, -4
  02cde	e9 c5 02 00 00	 jmp	 $LN508@inflate
$LN11@inflate:

; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  02ce3	b8 fe ff ff ff	 mov	 eax, -2
  02ce8	e9 bb 02 00 00	 jmp	 $LN508@inflate
$LN498@inflate:

; 1207 :         }

  02ced	e9 17 d4 ff ff	 jmp	 $LN501@inflate
$inf_leave$78295:
$LN10@inflate:

; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  02cf2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02cfa	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  02cff	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  02d03	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d0b	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02d0f	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02d12	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d1a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02d1f	48 89 01	 mov	 QWORD PTR [rcx], rax
  02d22	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d2a	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02d2e	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  02d31	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02d39	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02d3d	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  02d40	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02d48	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02d4c	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  02d4f	33 c0		 xor	 eax, eax
  02d51	85 c0		 test	 eax, eax
  02d53	75 9d		 jne	 SHORT $LN10@inflate

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  02d55	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d5d	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  02d61	75 1e		 jne	 SHORT $LN6@inflate
  02d63	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d6b	83 38 1a	 cmp	 DWORD PTR [rax], 26
  02d6e	7d 3e		 jge	 SHORT $LN7@inflate
  02d70	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d78	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02d7b	39 44 24 78	 cmp	 DWORD PTR out$[rsp], eax
  02d7f	74 2d		 je	 SHORT $LN7@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  02d81	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  02d85	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d8d	e8 00 00 00 00	 call	 updatewindow
  02d92	85 c0		 test	 eax, eax
  02d94	74 18		 je	 SHORT $LN5@inflate

; 1219 :             state->mode = MEM;

  02d96	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d9e	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30

; 1220 :             return Z_MEM_ERROR;

  02da4	b8 fc ff ff ff	 mov	 eax, -4
  02da9	e9 fa 01 00 00	 jmp	 $LN508@inflate
$LN5@inflate:
$LN7@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;

  02dae	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02db6	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  02db9	8b 44 24 44	 mov	 eax, DWORD PTR in$[rsp]
  02dbd	2b c1		 sub	 eax, ecx
  02dbf	89 44 24 44	 mov	 DWORD PTR in$[rsp], eax

; 1223 :     out -= strm->avail_out;

  02dc3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02dcb	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02dce	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02dd2	2b c1		 sub	 eax, ecx
  02dd4	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1224 :     strm->total_in += in;

  02dd8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02de0	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  02de3	03 4c 24 44	 add	 ecx, DWORD PTR in$[rsp]
  02de7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02def	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1225 :     strm->total_out += out;

  02df2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02dfa	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02dfd	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02e01	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02e09	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1226 :     state->total += out;

  02e0c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e14	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02e17	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02e1b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e23	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1227 :     if (state->wrap && out)

  02e26	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e2e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02e32	0f 84 9d 00 00
	00		 je	 $LN4@inflate
  02e38	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02e3d	0f 84 92 00 00
	00		 je	 $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  02e43	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e4b	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02e4f	74 31		 je	 SHORT $LN518@inflate
  02e51	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02e55	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  02e5d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  02e61	48 2b d0	 sub	 rdx, rax
  02e64	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02e69	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e71	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02e74	e8 00 00 00 00	 call	 crc32
  02e79	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv1355[rsp], eax
  02e80	eb 2f		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  02e82	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02e86	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  02e8e	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  02e92	48 2b d0	 sub	 rdx, rax
  02e95	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02e9a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ea2	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02ea5	e8 00 00 00 00	 call	 adler32
  02eaa	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv1355[rsp], eax
$LN519@inflate:
  02eb1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02eb9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv1355[rsp]
  02ec0	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02ec3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02ecb	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv1355[rsp]
  02ed2	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  02ed5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02edd	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  02ee1	74 0d		 je	 SHORT $LN520@inflate
  02ee3	c7 84 24 a4 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1360[rsp], 64 ; 00000040H
  02eee	eb 0b		 jmp	 SHORT $LN521@inflate
$LN520@inflate:
  02ef0	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1360[rsp], 0
$LN521@inflate:
  02efb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f03	83 38 0b	 cmp	 DWORD PTR [rax], 11
  02f06	75 0d		 jne	 SHORT $LN522@inflate
  02f08	c7 84 24 a8 00
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1363[rsp], 128 ; 00000080H
  02f13	eb 0b		 jmp	 SHORT $LN523@inflate
$LN522@inflate:
  02f15	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1363[rsp], 0
$LN523@inflate:
  02f20	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f28	83 38 13	 cmp	 DWORD PTR [rax], 19
  02f2b	74 1a		 je	 SHORT $LN524@inflate
  02f2d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f35	83 38 0e	 cmp	 DWORD PTR [rax], 14
  02f38	74 0d		 je	 SHORT $LN524@inflate
  02f3a	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1367[rsp], 0
  02f45	eb 0b		 jmp	 SHORT $LN525@inflate
$LN524@inflate:
  02f47	c7 84 24 ac 00
	00 00 00 01 00
	00		 mov	 DWORD PTR tv1367[rsp], 256 ; 00000100H
$LN525@inflate:
  02f52	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f5a	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  02f5d	03 8c 24 a4 00
	00 00		 add	 ecx, DWORD PTR tv1360[rsp]
  02f64	03 8c 24 a8 00
	00 00		 add	 ecx, DWORD PTR tv1363[rsp]
  02f6b	03 8c 24 ac 00
	00 00		 add	 ecx, DWORD PTR tv1367[rsp]
  02f72	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02f7a	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  02f7d	83 7c 24 44 00	 cmp	 DWORD PTR in$[rsp], 0
  02f82	75 07		 jne	 SHORT $LN1@inflate
  02f84	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02f89	74 0a		 je	 SHORT $LN2@inflate
$LN1@inflate:
  02f8b	83 bc 24 c8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  02f93	75 0f		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  02f95	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  02f9a	75 08		 jne	 SHORT $LN3@inflate

; 1234 :         ret = Z_BUF_ERROR;

  02f9c	c7 44 24 60 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflate:

; 1235 :     return ret;

  02fa4	8b 44 24 60	 mov	 eax, DWORD PTR ret$[rsp]
$LN508@inflate:

; 1236 : }

  02fa8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  02faf	c3		 ret	 0
$LN526@inflate:
  02fb0	00 00 00 00	 DD	 $LN497@inflate
  02fb4	00 00 00 00	 DD	 $LN466@inflate
  02fb8	00 00 00 00	 DD	 $LN446@inflate
  02fbc	00 00 00 00	 DD	 $LN428@inflate
  02fc0	00 00 00 00	 DD	 $LN410@inflate
  02fc4	00 00 00 00	 DD	 $LN389@inflate
  02fc8	00 00 00 00	 DD	 $LN382@inflate
  02fcc	00 00 00 00	 DD	 $LN370@inflate
  02fd0	00 00 00 00	 DD	 $LN358@inflate
  02fd4	00 00 00 00	 DD	 $LN342@inflate
  02fd8	00 00 00 00	 DD	 $LN329@inflate
  02fdc	00 00 00 00	 DD	 $LN324@inflate
  02fe0	00 00 00 00	 DD	 $LN321@inflate
  02fe4	00 00 00 00	 DD	 $LN291@inflate
  02fe8	00 00 00 00	 DD	 $LN273@inflate
  02fec	00 00 00 00	 DD	 $LN272@inflate
  02ff0	00 00 00 00	 DD	 $LN267@inflate
  02ff4	00 00 00 00	 DD	 $LN246@inflate
  02ff8	00 00 00 00	 DD	 $LN228@inflate
  02ffc	00 00 00 00	 DD	 $LN146@inflate
  03000	00 00 00 00	 DD	 $LN145@inflate
  03004	00 00 00 00	 DD	 $LN112@inflate
  03008	00 00 00 00	 DD	 $LN98@inflate
  0300c	00 00 00 00	 DD	 $LN75@inflate
  03010	00 00 00 00	 DD	 $LN61@inflate
  03014	00 00 00 00	 DD	 $LN47@inflate
  03018	00 00 00 00	 DD	 $LN45@inflate
  0301c	00 00 00 00	 DD	 $LN29@inflate
  03020	00 00 00 00	 DD	 $LN14@inflate
  03024	00 00 00 00	 DD	 $LN13@inflate
  03028	00 00 00 00	 DD	 $LN12@inflate
inflate	ENDP
_TEXT	ENDS
PUBLIC	inflateReset2
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN11
	DD	imagerel $LN11+248
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateReset2
_TEXT	SEGMENT
wrap$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
inflateReset2 PROC					; COMDAT

; 133  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00013	74 0c		 je	 SHORT $LN7@inflateRes@2
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0001a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001f	75 0a		 jne	 SHORT $LN8@inflateRes@2
$LN7@inflateRes@2:
  00021	b8 fe ff ff ff	 mov	 eax, -2
  00026	e9 c8 00 00 00	 jmp	 $LN9@inflateRes@2
$LN8@inflateRes@2:

; 139  :     state = (struct inflate_state FAR *)strm->state;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00030	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00034	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00039	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  0003e	7d 14		 jge	 SHORT $LN6@inflateRes@2

; 143  :         wrap = 0;

  00040	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 144  :         windowBits = -windowBits;

  00048	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0004c	f7 d8		 neg	 eax
  0004e	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax

; 145  :     }
; 146  :     else {

  00052	eb 20		 jmp	 SHORT $LN5@inflateRes@2
$LN6@inflateRes@2:

; 147  :         wrap = (windowBits >> 4) + 1;

  00054	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00058	c1 f8 04	 sar	 eax, 4
  0005b	83 c0 01	 add	 eax, 1
  0005e	89 44 24 20	 mov	 DWORD PTR wrap$[rsp], eax

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00062	83 7c 24 48 30	 cmp	 DWORD PTR windowBits$[rsp], 48 ; 00000030H
  00067	7d 0b		 jge	 SHORT $LN4@inflateRes@2

; 150  :             windowBits &= 15;

  00069	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0006d	83 e0 0f	 and	 eax, 15
  00070	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax
$LN4@inflateRes@2:
$LN5@inflateRes@2:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00074	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  00079	74 15		 je	 SHORT $LN3@inflateRes@2
  0007b	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00080	7c 07		 jl	 SHORT $LN2@inflateRes@2
  00082	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00087	7e 07		 jle	 SHORT $LN3@inflateRes@2
$LN2@inflateRes@2:

; 156  :         return Z_STREAM_ERROR;

  00089	b8 fe ff ff ff	 mov	 eax, -2
  0008e	eb 63		 jmp	 SHORT $LN9@inflateRes@2
$LN3@inflateRes@2:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00095	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0009a	74 35		 je	 SHORT $LN1@inflateRes@2
  0009c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000a1	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  000a5	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  000a8	74 27		 je	 SHORT $LN1@inflateRes@2

; 158  :         ZFREE(strm, state->window);

  000aa	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  000af	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b8	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c1	ff 50 38	 call	 QWORD PTR [rax+56]

; 159  :         state->window = Z_NULL;

  000c4	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  000c9	49 c7 43 38 00
	00 00 00	 mov	 QWORD PTR [r11+56], 0
$LN1@inflateRes@2:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;

  000d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000d6	8b 44 24 20	 mov	 eax, DWORD PTR wrap$[rsp]
  000da	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 164  :     state->wbits = (unsigned)windowBits;

  000dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000e2	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  000e6	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 165  :     return inflateReset(strm);

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000ee	e8 00 00 00 00	 call	 inflateReset
$LN9@inflateRes@2:

; 166  : }

  000f3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f7	c3		 ret	 0
inflateReset2 ENDP
PUBLIC	inflateInit2_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN10
	DD	imagerel $LN10+311
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateInit2_
_TEXT	SEGMENT
ret$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
version$ = 80
stream_size$ = 88
inflateInit2_ PROC					; COMDAT

; 173  : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN6@inflateIni
  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00027	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 07		 jne	 SHORT $LN6@inflateIni
  00032	83 7c 24 58 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN7@inflateIni
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 ef 00 00 00	 jmp	 $LN8@inflateIni
$LN7@inflateIni:

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	75 0a		 jne	 SHORT $LN5@inflateIni
  0004b	b8 fe ff ff ff	 mov	 eax, -2
  00050	e9 dd 00 00 00	 jmp	 $LN8@inflateIni
$LN5@inflateIni:

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 182  :     if (strm->zalloc == (alloc_func)0) {

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0006c	75 1d		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  0007a	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 184  :         strm->opaque = (voidpf)0;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00083	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00090	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00095	75 10		 jne	 SHORT $LN3@inflateIni
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000a3	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@inflateIni:

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  000a7	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b7	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c0	ff 50 30	 call	 QWORD PTR [rax+48]
  000c3	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  000c8	48 83 7c 24 28
	00		 cmp	 QWORD PTR state$[rsp], 0
  000ce	75 07		 jne	 SHORT $LN2@inflateIni
  000d0	b8 fc ff ff ff	 mov	 eax, -4
  000d5	eb 5b		 jmp	 SHORT $LN8@inflateIni
$LN2@inflateIni:

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;

  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e1	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 192  :     state->window = Z_NULL;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ea	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 193  :     ret = inflateReset2(strm, windowBits);

  000f2	8b 54 24 48	 mov	 edx, DWORD PTR windowBits$[rsp]
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000fb	e8 00 00 00 00	 call	 inflateReset2
  00100	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 194  :     if (ret != Z_OK) {

  00104	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  00109	74 23		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  0010b	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00110	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00115	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0011e	ff 50 38	 call	 QWORD PTR [rax+56]

; 196  :         strm->state = Z_NULL;

  00121	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  00126	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  0012e	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN8@inflateIni:

; 199  : }

  00132	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00136	c3		 ret	 0
inflateInit2_ ENDP
PUBLIC	inflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$inflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit_ DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 48
version$ = 56
stream_size$ = 64
inflateInit_ PROC					; COMDAT

; 205  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR stream_size$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR version$[rsp]
  0001d	ba 0f 00 00 00	 mov	 edx, 15
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00027	e8 00 00 00 00	 call	 inflateInit2_

; 207  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
inflateInit_ ENDP
END
