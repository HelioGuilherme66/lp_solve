; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_copyright
inflate_copyright DB ' inflate 1.2.5 Copyright 1995-2010 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+10
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	inflate_table
;	COMDAT pdata
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\inftrees.c
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN71
	DD	imagerel $LN71+2297
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 021a01H
	DD	015011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflate_table
_TEXT	SEGMENT
count$ = 0
here$ = 32
extra$ = 40
base$ = 48
huff$ = 56
min$ = 60
mask$ = 64
drop$ = 68
curr$ = 72
root$ = 76
next$ = 80
left$ = 88
len$ = 92
end$ = 96
incr$ = 100
offs$ = 104
fill$ = 136
sym$ = 140
low$ = 144
used$ = 148
max$ = 152
tv201 = 156
type$ = 176
lens$ = 184
codes$ = 192
table$ = 200
bits$ = 208
work$ = 216
inflate_table PROC					; COMDAT

; 39   : {

$LN71:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0001a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00022	eb 0b		 jmp	 SHORT $LN68@inflate_ta
$LN67@inflate_ta:
  00024	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN68@inflate_ta:
  0002f	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  00034	77 0c		 ja	 SHORT $LN66@inflate_ta

; 108  :         count[len] = 0;

  00036	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  0003a	33 c0		 xor	 eax, eax
  0003c	66 89 04 4c	 mov	 WORD PTR count$[rsp+rcx*2], ax
  00040	eb e2		 jmp	 SHORT $LN67@inflate_ta
$LN66@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  00042	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  0004d	eb 11		 jmp	 SHORT $LN65@inflate_ta
$LN64@inflate_ta:
  0004f	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN65@inflate_ta:
  00060	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  00067	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  0006e	73 34		 jae	 SHORT $LN63@inflate_ta

; 110  :         count[lens[sym]]++;

  00070	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00077	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0007f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00083	0f b7 14 44	 movzx	 edx, WORD PTR count$[rsp+rax*2]
  00087	66 83 c2 01	 add	 dx, 1
  0008b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00092	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0009a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0009e	66 89 14 44	 mov	 WORD PTR count$[rsp+rax*2], dx
  000a2	eb ab		 jmp	 SHORT $LN64@inflate_ta
$LN63@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  000a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  000ac	8b 00		 mov	 eax, DWORD PTR [rax]
  000ae	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000b2	c7 84 24 98 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR max$[rsp], 15
  000bd	eb 11		 jmp	 SHORT $LN62@inflate_ta
$LN61@inflate_ta:
  000bf	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000c6	83 e8 01	 sub	 eax, 1
  000c9	89 84 24 98 00
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN62@inflate_ta:
  000d0	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  000d8	72 13		 jb	 SHORT $LN60@inflate_ta

; 115  :         if (count[max] != 0) break;

  000da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000e1	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  000e5	85 c0		 test	 eax, eax
  000e7	74 02		 je	 SHORT $LN59@inflate_ta
  000e9	eb 02		 jmp	 SHORT $LN60@inflate_ta
$LN59@inflate_ta:

; 116  :     if (root > max) root = max;

  000eb	eb d2		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:
  000ed	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000f4	39 44 24 4c	 cmp	 DWORD PTR root$[rsp], eax
  000f8	76 0b		 jbe	 SHORT $LN58@inflate_ta
  000fa	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00101	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax
$LN58@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  00105	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR max$[rsp], 0
  0010d	75 7c		 jne	 SHORT $LN57@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  0010f	c6 44 24 20 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 119  :         here.bits = (unsigned char)1;

  00114	c6 44 24 21 01	 mov	 BYTE PTR here$[rsp+1], 1

; 120  :         here.val = (unsigned short)0;

  00119	33 c0		 xor	 eax, eax
  0011b	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  00120	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00128	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR here$[rsp]
  0012f	89 01		 mov	 DWORD PTR [rcx], eax
  00131	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00139	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0013c	48 83 c1 04	 add	 rcx, 4
  00140	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00148	48 89 08	 mov	 QWORD PTR [rax], rcx

; 122  :         *(*table)++ = here;

  0014b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00153	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00156	8b 44 24 20	 mov	 eax, DWORD PTR here$[rsp]
  0015a	89 01		 mov	 DWORD PTR [rcx], eax
  0015c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00164	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00167	48 83 c1 04	 add	 rcx, 4
  0016b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00173	48 89 08	 mov	 QWORD PTR [rax], rcx

; 123  :         *bits = 1;

  00176	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  0017e	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00184	33 c0		 xor	 eax, eax
  00186	e9 66 07 00 00	 jmp	 $LN69@inflate_ta
$LN57@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  0018b	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR min$[rsp], 1
  00193	eb 0b		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:
  00195	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  00199	83 c0 01	 add	 eax, 1
  0019c	89 44 24 3c	 mov	 DWORD PTR min$[rsp], eax
$LN56@inflate_ta:
  001a0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  001a7	39 44 24 3c	 cmp	 DWORD PTR min$[rsp], eax
  001ab	73 10		 jae	 SHORT $LN54@inflate_ta

; 127  :         if (count[min] != 0) break;

  001ad	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001b1	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  001b5	85 c0		 test	 eax, eax
  001b7	74 02		 je	 SHORT $LN53@inflate_ta
  001b9	eb 02		 jmp	 SHORT $LN54@inflate_ta
$LN53@inflate_ta:

; 128  :     if (root < min) root = min;

  001bb	eb d8		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:
  001bd	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001c1	39 44 24 4c	 cmp	 DWORD PTR root$[rsp], eax
  001c5	73 08		 jae	 SHORT $LN52@inflate_ta
  001c7	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  001cb	89 44 24 4c	 mov	 DWORD PTR root$[rsp], eax
$LN52@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  001cf	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR left$[rsp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  001d7	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  001df	eb 0b		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:
  001e1	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  001e5	83 c0 01	 add	 eax, 1
  001e8	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN51@inflate_ta:
  001ec	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  001f1	77 2f		 ja	 SHORT $LN49@inflate_ta

; 133  :         left <<= 1;

  001f3	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  001f7	d1 e0		 shl	 eax, 1
  001f9	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 134  :         left -= count[len];

  001fd	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00201	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  00205	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  00209	2b c1		 sub	 eax, ecx
  0020b	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0020f	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  00214	7d 0a		 jge	 SHORT $LN48@inflate_ta
  00216	b8 ff ff ff ff	 mov	 eax, -1
  0021b	e9 d1 06 00 00	 jmp	 $LN69@inflate_ta
$LN48@inflate_ta:

; 136  :     }

  00220	eb bf		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  00222	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  00227	7e 1e		 jle	 SHORT $LN47@inflate_ta
  00229	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  00231	74 0a		 je	 SHORT $LN46@inflate_ta
  00233	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  0023b	74 0a		 je	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  0023d	b8 ff ff ff ff	 mov	 eax, -1
  00242	e9 aa 06 00 00	 jmp	 $LN69@inflate_ta
$LN47@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00247	33 c0		 xor	 eax, eax
  00249	66 89 44 24 6a	 mov	 WORD PTR offs$[rsp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  0024e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  00256	eb 0b		 jmp	 SHORT $LN45@inflate_ta
$LN44@inflate_ta:
  00258	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  0025c	83 c0 01	 add	 eax, 1
  0025f	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN45@inflate_ta:
  00263	83 7c 24 5c 0f	 cmp	 DWORD PTR len$[rsp], 15
  00268	73 23		 jae	 SHORT $LN43@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  0026a	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  0026e	0f b7 4c 44 68	 movzx	 ecx, WORD PTR offs$[rsp+rax*2]
  00273	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00277	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  0027b	03 c8		 add	 ecx, eax
  0027d	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00281	83 c0 01	 add	 eax, 1
  00284	8b c0		 mov	 eax, eax
  00286	66 89 4c 44 68	 mov	 WORD PTR offs$[rsp+rax*2], cx
  0028b	eb cb		 jmp	 SHORT $LN44@inflate_ta
$LN43@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0028d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  00298	eb 11		 jmp	 SHORT $LN42@inflate_ta
$LN41@inflate_ta:
  0029a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  002a1	83 c0 01	 add	 eax, 1
  002a4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN42@inflate_ta:
  002ab	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  002b2	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  002b9	73 7c		 jae	 SHORT $LN40@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  002bb	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  002c2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  002ca	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  002ce	85 c0		 test	 eax, eax
  002d0	74 60		 je	 SHORT $LN39@inflate_ta
  002d2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  002d9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  002e1	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  002e5	0f b7 54 44 68	 movzx	 edx, WORD PTR offs$[rsp+rax*2]
  002ea	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  002f2	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR sym$[rsp]
  002fa	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  002fe	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00305	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0030d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00311	0f b7 54 44 68	 movzx	 edx, WORD PTR offs$[rsp+rax*2]
  00316	66 83 c2 01	 add	 dx, 1
  0031a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00321	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  00329	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0032d	66 89 54 44 68	 mov	 WORD PTR offs$[rsp+rax*2], dx
$LN39@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00332	e9 63 ff ff ff	 jmp	 $LN41@inflate_ta
$LN40@inflate_ta:
  00337	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  0033e	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  00345	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv201[rsp], 0
  0034d	74 0c		 je	 SHORT $LN36@inflate_ta
  0034f	83 bc 24 9c 00
	00 00 01	 cmp	 DWORD PTR tv201[rsp], 1
  00357	74 23		 je	 SHORT $LN35@inflate_ta
  00359	eb 63		 jmp	 SHORT $LN34@inflate_ta
$LN36@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  0035b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  00363	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax
  00368	48 8b 44 24 28	 mov	 rax, QWORD PTR extra$[rsp]
  0036d	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 184  :         end = 19;

  00372	c7 44 24 60 13
	00 00 00	 mov	 DWORD PTR end$[rsp], 19

; 185  :         break;

  0037a	eb 62		 jmp	 SHORT $LN37@inflate_ta
$LN35@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  0037c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9
  00383	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 188  :         base -= 257;

  00388	48 8b 44 24 30	 mov	 rax, QWORD PTR base$[rsp]
  0038d	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  00393	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 189  :         extra = lext;

  00398	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  0039f	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 190  :         extra -= 257;

  003a4	48 8b 44 24 28	 mov	 rax, QWORD PTR extra$[rsp]
  003a9	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  003af	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 191  :         end = 256;

  003b4	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR end$[rsp], 256 ; 00000100H

; 192  :         break;

  003bc	eb 20		 jmp	 SHORT $LN37@inflate_ta
$LN34@inflate_ta:

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  003be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  003c5	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 195  :         extra = dext;

  003ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  003d1	48 89 44 24 28	 mov	 QWORD PTR extra$[rsp], rax

; 196  :         end = -1;

  003d6	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR end$[rsp], -1
$LN37@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */

  003de	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0

; 201  :     sym = 0;                    /* starting code symbol */

  003e6	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0

; 202  :     len = min;                  /* starting code length */

  003f1	8b 44 24 3c	 mov	 eax, DWORD PTR min$[rsp]
  003f5	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax

; 203  :     next = *table;              /* current table to fill in */

  003f9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00401	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00404	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 204  :     curr = root;                /* current table index bits */

  00409	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  0040d	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 205  :     drop = 0;                   /* current bits to drop from code for index */

  00411	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  00419	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR low$[rsp], -1	; ffffffffH

; 207  :     used = 1U << root;          /* use root table entries */

  00424	8b 4c 24 4c	 mov	 ecx, DWORD PTR root$[rsp]
  00428	b8 01 00 00 00	 mov	 eax, 1
  0042d	d3 e0		 shl	 eax, cl
  0042f	89 84 24 94 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 208  :     mask = used - 1;            /* mask for comparing low */

  00436	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  0043d	83 e8 01	 sub	 eax, 1
  00440	89 44 24 40	 mov	 DWORD PTR mask$[rsp], eax

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  00444	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  0044c	75 0d		 jne	 SHORT $LN31@inflate_ta
  0044e	81 bc 24 94 00
	00 00 54 03 00
	00		 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  00459	73 17		 jae	 SHORT $LN32@inflate_ta
$LN31@inflate_ta:
  0045b	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00463	75 17		 jne	 SHORT $LN33@inflate_ta
  00465	81 bc 24 94 00
	00 00 50 02 00
	00		 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  00470	72 0a		 jb	 SHORT $LN33@inflate_ta
$LN32@inflate_ta:

; 213  :         return 1;

  00472	b8 01 00 00 00	 mov	 eax, 1
  00477	e9 75 04 00 00	 jmp	 $LN69@inflate_ta
$LN33@inflate_ta:
$LN30@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  0047c	8b 4c 24 44	 mov	 ecx, DWORD PTR drop$[rsp]
  00480	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00484	2b c1		 sub	 eax, ecx
  00486	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al

; 219  :         if ((int)(work[sym]) < end) {

  0048a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00491	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  00499	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0049d	3b 44 24 60	 cmp	 eax, DWORD PTR end$[rsp]
  004a1	7d 1f		 jge	 SHORT $LN28@inflate_ta

; 220  :             here.op = (unsigned char)0;

  004a3	c6 44 24 20 00	 mov	 BYTE PTR here$[rsp], 0

; 221  :             here.val = work[sym];

  004a8	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004af	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004b7	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004bb	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
  004c0	eb 68		 jmp	 SHORT $LN27@inflate_ta
$LN28@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  004c2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004c9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004d1	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004d5	3b 44 24 60	 cmp	 eax, DWORD PTR end$[rsp]
  004d9	7e 43		 jle	 SHORT $LN26@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  004db	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004e2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004ea	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  004ee	48 8b 44 24 28	 mov	 rax, QWORD PTR extra$[rsp]
  004f3	0f b6 04 48	 movzx	 eax, BYTE PTR [rax+rcx*2]
  004f7	88 44 24 20	 mov	 BYTE PTR here$[rsp], al

; 225  :             here.val = base[work[sym]];

  004fb	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00502	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  0050a	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  0050e	48 8b 44 24 30	 mov	 rax, QWORD PTR base$[rsp]
  00513	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00517	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax

; 226  :         }
; 227  :         else {

  0051c	eb 0c		 jmp	 SHORT $LN25@inflate_ta
$LN26@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  0051e	c6 44 24 20 60	 mov	 BYTE PTR here$[rsp], 96	; 00000060H

; 229  :             here.val = 0;

  00523	33 c0		 xor	 eax, eax
  00525	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
$LN25@inflate_ta:
$LN27@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  0052a	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  0052e	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  00532	2b c8		 sub	 ecx, eax
  00534	b8 01 00 00 00	 mov	 eax, 1
  00539	d3 e0		 shl	 eax, cl
  0053b	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax

; 234  :         fill = 1U << curr;

  0053f	8b 4c 24 48	 mov	 ecx, DWORD PTR curr$[rsp]
  00543	b8 01 00 00 00	 mov	 eax, 1
  00548	d3 e0		 shl	 eax, cl
  0054a	89 84 24 88 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 235  :         min = fill;                 /* save offset to next table */

  00551	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR fill$[rsp]
  00558	89 44 24 3c	 mov	 DWORD PTR min$[rsp], eax
$LN24@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  0055c	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  00560	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR fill$[rsp]
  00567	2b c1		 sub	 eax, ecx
  00569	89 84 24 88 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 238  :             next[(huff >> drop) + fill] = here;

  00570	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00574	0f b6 c8	 movzx	 ecx, al
  00577	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  0057b	d3 e8		 shr	 eax, cl
  0057d	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR fill$[rsp]
  00584	8b d0		 mov	 edx, eax
  00586	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  0058b	8b 44 24 20	 mov	 eax, DWORD PTR here$[rsp]
  0058f	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 239  :         } while (fill != 0);

  00592	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR fill$[rsp], 0
  0059a	75 c0		 jne	 SHORT $LN24@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  0059c	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  005a0	83 e9 01	 sub	 ecx, 1
  005a3	b8 01 00 00 00	 mov	 eax, 1
  005a8	d3 e0		 shl	 eax, cl
  005aa	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
$LN21@inflate_ta:

; 243  :         while (huff & incr)

  005ae	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  005b2	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  005b6	23 c1		 and	 eax, ecx
  005b8	85 c0		 test	 eax, eax
  005ba	74 0c		 je	 SHORT $LN20@inflate_ta

; 244  :             incr >>= 1;

  005bc	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  005c0	d1 e8		 shr	 eax, 1
  005c2	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
  005c6	eb e6		 jmp	 SHORT $LN21@inflate_ta
$LN20@inflate_ta:

; 245  :         if (incr != 0) {

  005c8	83 7c 24 64 00	 cmp	 DWORD PTR incr$[rsp], 0
  005cd	74 21		 je	 SHORT $LN19@inflate_ta

; 246  :             huff &= incr - 1;

  005cf	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  005d3	83 e9 01	 sub	 ecx, 1
  005d6	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  005da	23 c1		 and	 eax, ecx
  005dc	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 247  :             huff += incr;

  005e0	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  005e4	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  005e8	03 c1		 add	 eax, ecx
  005ea	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 248  :         }
; 249  :         else

  005ee	eb 08		 jmp	 SHORT $LN18@inflate_ta
$LN19@inflate_ta:

; 250  :             huff = 0;

  005f0	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN18@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  005f8	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  005ff	83 c0 01	 add	 eax, 1
  00602	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax

; 254  :         if (--(count[len]) == 0) {

  00609	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  0060d	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  00611	66 83 e9 01	 sub	 cx, 1
  00615	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00619	66 89 0c 44	 mov	 WORD PTR count$[rsp+rax*2], cx
  0061d	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  00621	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00625	85 c0		 test	 eax, eax
  00627	75 35		 jne	 SHORT $LN17@inflate_ta

; 255  :             if (len == max) break;

  00629	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00630	39 44 24 5c	 cmp	 DWORD PTR len$[rsp], eax
  00634	75 05		 jne	 SHORT $LN16@inflate_ta
  00636	e9 a1 01 00 00	 jmp	 $LN29@inflate_ta
$LN16@inflate_ta:

; 256  :             len = lens[work[sym]];

  0063b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00642	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  0064a	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  0064e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  00656	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0065a	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax
$LN17@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  0065e	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  00662	39 44 24 5c	 cmp	 DWORD PTR len$[rsp], eax
  00666	0f 86 6b 01 00
	00		 jbe	 $LN15@inflate_ta
  0066c	8b 4c 24 40	 mov	 ecx, DWORD PTR mask$[rsp]
  00670	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  00674	23 c1		 and	 eax, ecx
  00676	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  0067d	0f 84 54 01 00
	00		 je	 $LN15@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  00683	83 7c 24 44 00	 cmp	 DWORD PTR drop$[rsp], 0
  00688	75 08		 jne	 SHORT $LN14@inflate_ta

; 263  :                 drop = root;

  0068a	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  0068e	89 44 24 44	 mov	 DWORD PTR drop$[rsp], eax
$LN14@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  00692	8b 4c 24 3c	 mov	 ecx, DWORD PTR min$[rsp]
  00696	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0069b	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0069f	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  006a4	8b 4c 24 44	 mov	 ecx, DWORD PTR drop$[rsp]
  006a8	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  006ac	2b c1		 sub	 eax, ecx
  006ae	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 270  :             left = (int)(1 << curr);

  006b2	8b 4c 24 48	 mov	 ecx, DWORD PTR curr$[rsp]
  006b6	b8 01 00 00 00	 mov	 eax, 1
  006bb	d3 e0		 shl	 eax, cl
  006bd	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax
$LN13@inflate_ta:

; 271  :             while (curr + drop < max) {

  006c1	8b 4c 24 44	 mov	 ecx, DWORD PTR drop$[rsp]
  006c5	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  006c9	03 c1		 add	 eax, ecx
  006cb	3b 84 24 98 00
	00 00		 cmp	 eax, DWORD PTR max$[rsp]
  006d2	73 3a		 jae	 SHORT $LN12@inflate_ta

; 272  :                 left -= count[curr + drop];

  006d4	8b 4c 24 44	 mov	 ecx, DWORD PTR drop$[rsp]
  006d8	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  006dc	03 c1		 add	 eax, ecx
  006de	8b c0		 mov	 eax, eax
  006e0	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  006e4	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  006e8	2b c1		 sub	 eax, ecx
  006ea	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 273  :                 if (left <= 0) break;

  006ee	83 7c 24 58 00	 cmp	 DWORD PTR left$[rsp], 0
  006f3	7f 02		 jg	 SHORT $LN11@inflate_ta
  006f5	eb 17		 jmp	 SHORT $LN12@inflate_ta
$LN11@inflate_ta:

; 274  :                 curr++;

  006f7	8b 44 24 48	 mov	 eax, DWORD PTR curr$[rsp]
  006fb	83 c0 01	 add	 eax, 1
  006fe	89 44 24 48	 mov	 DWORD PTR curr$[rsp], eax

; 275  :                 left <<= 1;

  00702	8b 44 24 58	 mov	 eax, DWORD PTR left$[rsp]
  00706	d1 e0		 shl	 eax, 1
  00708	89 44 24 58	 mov	 DWORD PTR left$[rsp], eax

; 276  :             }

  0070c	eb b3		 jmp	 SHORT $LN13@inflate_ta
$LN12@inflate_ta:

; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  0070e	8b 4c 24 48	 mov	 ecx, DWORD PTR curr$[rsp]
  00712	b8 01 00 00 00	 mov	 eax, 1
  00717	d3 e0		 shl	 eax, cl
  00719	8b c8		 mov	 ecx, eax
  0071b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  00722	03 c1		 add	 eax, ecx
  00724	89 84 24 94 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))

  0072b	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00733	75 0d		 jne	 SHORT $LN8@inflate_ta
  00735	81 bc 24 94 00
	00 00 54 03 00
	00		 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  00740	73 17		 jae	 SHORT $LN9@inflate_ta
$LN8@inflate_ta:
  00742	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  0074a	75 17		 jne	 SHORT $LN10@inflate_ta
  0074c	81 bc 24 94 00
	00 00 50 02 00
	00		 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  00757	72 0a		 jb	 SHORT $LN10@inflate_ta
$LN9@inflate_ta:

; 282  :                 return 1;

  00759	b8 01 00 00 00	 mov	 eax, 1
  0075e	e9 8e 01 00 00	 jmp	 $LN69@inflate_ta
$LN10@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  00763	8b 4c 24 40	 mov	 ecx, DWORD PTR mask$[rsp]
  00767	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  0076b	23 c1		 and	 eax, ecx
  0076d	89 84 24 90 00
	00 00		 mov	 DWORD PTR low$[rsp], eax

; 286  :             (*table)[low].op = (unsigned char)curr;

  00774	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR low$[rsp]
  0077b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00783	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00786	0f b6 44 24 48	 movzx	 eax, BYTE PTR curr$[rsp]
  0078b	88 04 91	 mov	 BYTE PTR [rcx+rdx*4], al

; 287  :             (*table)[low].bits = (unsigned char)root;

  0078e	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR low$[rsp]
  00795	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0079d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007a0	0f b6 44 24 4c	 movzx	 eax, BYTE PTR root$[rsp]
  007a5	88 44 91 01	 mov	 BYTE PTR [rcx+rdx*4+1], al

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  007a9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  007b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  007b9	48 2b d0	 sub	 rdx, rax
  007bc	48 c1 fa 02	 sar	 rdx, 2
  007c0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  007c7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  007cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007d2	66 89 54 88 02	 mov	 WORD PTR [rax+rcx*4+2], dx
$LN15@inflate_ta:

; 289  :         }
; 290  :     }

  007d7	e9 a0 fc ff ff	 jmp	 $LN30@inflate_ta
$LN29@inflate_ta:

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */

  007dc	c6 44 24 20 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 300  :     here.bits = (unsigned char)(len - drop);

  007e1	8b 4c 24 44	 mov	 ecx, DWORD PTR drop$[rsp]
  007e5	8b 44 24 5c	 mov	 eax, DWORD PTR len$[rsp]
  007e9	2b c1		 sub	 eax, ecx
  007eb	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al

; 301  :     here.val = (unsigned short)0;

  007ef	33 c0		 xor	 eax, eax
  007f1	66 89 44 24 22	 mov	 WORD PTR here$[rsp+2], ax
$LN7@inflate_ta:

; 302  :     while (huff != 0) {

  007f6	83 7c 24 38 00	 cmp	 DWORD PTR huff$[rsp], 0
  007fb	0f 84 bf 00 00
	00		 je	 $LN6@inflate_ta

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  00801	83 7c 24 44 00	 cmp	 DWORD PTR drop$[rsp], 0
  00806	74 3c		 je	 SHORT $LN5@inflate_ta
  00808	8b 4c 24 40	 mov	 ecx, DWORD PTR mask$[rsp]
  0080c	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  00810	23 c1		 and	 eax, ecx
  00812	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  00819	74 29		 je	 SHORT $LN5@inflate_ta

; 305  :             drop = 0;

  0081b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 306  :             len = root;

  00823	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  00827	89 44 24 5c	 mov	 DWORD PTR len$[rsp], eax

; 307  :             next = *table;

  0082b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00833	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00836	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 308  :             here.bits = (unsigned char)len;

  0083b	0f b6 44 24 5c	 movzx	 eax, BYTE PTR len$[rsp]
  00840	88 44 24 21	 mov	 BYTE PTR here$[rsp+1], al
$LN5@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  00844	8b 44 24 44	 mov	 eax, DWORD PTR drop$[rsp]
  00848	0f b6 c8	 movzx	 ecx, al
  0084b	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  0084f	d3 e8		 shr	 eax, cl
  00851	8b d0		 mov	 edx, eax
  00853	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00858	8b 44 24 20	 mov	 eax, DWORD PTR here$[rsp]
  0085c	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  0085f	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$[rsp]
  00863	83 e9 01	 sub	 ecx, 1
  00866	b8 01 00 00 00	 mov	 eax, 1
  0086b	d3 e0		 shl	 eax, cl
  0086d	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
$LN4@inflate_ta:

; 316  :         while (huff & incr)

  00871	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  00875	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  00879	23 c1		 and	 eax, ecx
  0087b	85 c0		 test	 eax, eax
  0087d	74 0c		 je	 SHORT $LN3@inflate_ta

; 317  :             incr >>= 1;

  0087f	8b 44 24 64	 mov	 eax, DWORD PTR incr$[rsp]
  00883	d1 e8		 shr	 eax, 1
  00885	89 44 24 64	 mov	 DWORD PTR incr$[rsp], eax
  00889	eb e6		 jmp	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 318  :         if (incr != 0) {

  0088b	83 7c 24 64 00	 cmp	 DWORD PTR incr$[rsp], 0
  00890	74 21		 je	 SHORT $LN2@inflate_ta

; 319  :             huff &= incr - 1;

  00892	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  00896	83 e9 01	 sub	 ecx, 1
  00899	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  0089d	23 c1		 and	 eax, ecx
  0089f	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 320  :             huff += incr;

  008a3	8b 4c 24 64	 mov	 ecx, DWORD PTR incr$[rsp]
  008a7	8b 44 24 38	 mov	 eax, DWORD PTR huff$[rsp]
  008ab	03 c1		 add	 eax, ecx
  008ad	89 44 24 38	 mov	 DWORD PTR huff$[rsp], eax

; 321  :         }
; 322  :         else

  008b1	eb 08		 jmp	 SHORT $LN1@inflate_ta
$LN2@inflate_ta:

; 323  :             huff = 0;

  008b3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN1@inflate_ta:

; 324  :     }

  008bb	e9 36 ff ff ff	 jmp	 $LN7@inflate_ta
$LN6@inflate_ta:

; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  008c0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  008c7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  008cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008d2	48 8d 0c 88	 lea	 rcx, QWORD PTR [rax+rcx*4]
  008d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  008de	48 89 08	 mov	 QWORD PTR [rax], rcx

; 328  :     *bits = root;

  008e1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR bits$[rsp]
  008e9	8b 44 24 4c	 mov	 eax, DWORD PTR root$[rsp]
  008ed	89 01		 mov	 DWORD PTR [rcx], eax

; 329  :     return 0;

  008ef	33 c0		 xor	 eax, eax
$LN69@inflate_ta:

; 330  : }

  008f1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  008f8	c3		 ret	 0
inflate_table ENDP
END
