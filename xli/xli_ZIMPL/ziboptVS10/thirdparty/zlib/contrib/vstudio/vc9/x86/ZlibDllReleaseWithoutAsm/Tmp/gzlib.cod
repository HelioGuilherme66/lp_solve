; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\lp_solve_5.5\xli\xli_ZIMPL\ziboptVS10\thirdparty\zlib\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp__sprintf:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__lseek:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	_gz_error
; Function compile flags: /Odtp
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 490  :     /* free previously allocated message and clear */
; 491  :     if (state->msg != NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0000b	74 23		 je	 SHORT $LN5@gz_error

; 492  :         if (state->err != Z_MEM_ERROR)

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 4c fc	 cmp	 DWORD PTR [ecx+76], -4	; fffffffcH
  00014	74 10		 je	 SHORT $LN4@gz_error

; 493  :             free(state->msg);

  00016	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00019	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00023	83 c4 04	 add	 esp, 4
$LN4@gz_error:

; 494  :         state->msg = NULL;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00029	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
$LN5@gz_error:

; 495  :     }
; 496  : 
; 497  :     /* set error code, and if no message, then done */
; 498  :     state->err = err;

  00030	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00033	8b 45 0c	 mov	 eax, DWORD PTR _err$[ebp]
  00036	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 499  :     if (msg == NULL)

  00039	83 7d 10 00	 cmp	 DWORD PTR _msg$[ebp], 0
  0003d	75 05		 jne	 SHORT $LN3@gz_error

; 500  :         return;

  0003f	e9 a1 00 00 00	 jmp	 $LN6@gz_error
$LN3@gz_error:

; 501  : 
; 502  :     /* for an out of memory error, save as static string */
; 503  :     if (err == Z_MEM_ERROR) {

  00044	83 7d 0c fc	 cmp	 DWORD PTR _err$[ebp], -4 ; fffffffcH
  00048	75 0e		 jne	 SHORT $LN2@gz_error

; 504  :         state->msg = (char *)msg;

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	8b 55 10	 mov	 edx, DWORD PTR _msg$[ebp]
  00050	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 505  :         return;

  00053	e9 8d 00 00 00	 jmp	 $LN6@gz_error
$LN2@gz_error:

; 506  :     }
; 507  : 
; 508  :     /* construct error message with path */
; 509  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00058	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _strlen
  00064	83 c4 04	 add	 esp, 4
  00067	8b f0		 mov	 esi, eax
  00069	8b 55 10	 mov	 edx, DWORD PTR _msg$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _strlen
  00072	83 c4 04	 add	 esp, 4
  00075	8d 44 06 03	 lea	 eax, DWORD PTR [esi+eax+3]
  00079	50		 push	 eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00080	83 c4 04	 add	 esp, 4
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00086	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00089	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008c	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  00090	75 16		 jne	 SHORT $LN1@gz_error

; 510  :         state->err = Z_MEM_ERROR;

  00092	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00095	c7 40 4c fc ff
	ff ff		 mov	 DWORD PTR [eax+76], -4	; fffffffcH

; 511  :         state->msg = (char *)"out of memory";

  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0009f	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@

; 512  :         return;

  000a6	eb 3d		 jmp	 SHORT $LN6@gz_error
$LN1@gz_error:

; 513  :     }
; 514  :     strcpy(state->msg, state->path);

  000a8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ae	50		 push	 eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000b2	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _strcpy
  000bb	83 c4 08	 add	 esp, 8

; 515  :     strcat(state->msg, ": ");

  000be	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  000c3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _strcat
  000cf	83 c4 08	 add	 esp, 8

; 516  :     strcat(state->msg, msg);

  000d2	8b 55 10	 mov	 edx, DWORD PTR _msg$[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _strcat
  000e2	83 c4 08	 add	 esp, 8
$LN6@gz_error:

; 517  :     return;
; 518  : }

  000e5	5e		 pop	 esi
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Odtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 464  :     gz_statep state;
; 465  : 
; 466  :     /* get internal structure and check integrity */
; 467  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 02		 jne	 SHORT $LN3@gzclearerr

; 468  :         return;

  0000a	eb 43		 jmp	 SHORT $LN4@gzclearerr
$LN3@gzclearerr:

; 469  :     state = (gz_statep)file;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 470  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001b	74 0d		 je	 SHORT $LN2@gzclearerr
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00020	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  00026	74 02		 je	 SHORT $LN2@gzclearerr

; 471  :         return;

  00028	eb 25		 jmp	 SHORT $LN4@gzclearerr
$LN2@gzclearerr:

; 472  : 
; 473  :     /* clear error and end-of-file */
; 474  :     if (state->mode == GZ_READ)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002d	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [eax], 7247	; 00001c4fH
  00033	75 0a		 jne	 SHORT $LN1@gzclearerr

; 475  :         state->eof = 0;

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00038	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
$LN1@gzclearerr:

; 476  :     gz_error(state, Z_OK, NULL);

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _gz_error
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzclearerr:

; 477  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Odtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 445  :     gz_statep state;
; 446  : 
; 447  :     /* get internal structure and check integrity */
; 448  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN3@gzerror

; 449  :         return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 4f		 jmp	 SHORT $LN4@gzerror
$LN3@gzerror:

; 450  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 451  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001f	74 0f		 je	 SHORT $LN2@gzerror
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002a	74 04		 je	 SHORT $LN2@gzerror

; 452  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 2f		 jmp	 SHORT $LN4@gzerror
$LN2@gzerror:

; 453  : 
; 454  :     /* return error information */
; 455  :     if (errnum != NULL)

  00030	83 7d 0c 00	 cmp	 DWORD PTR _errnum$[ebp], 0
  00034	74 0b		 je	 SHORT $LN1@gzerror

; 456  :         *errnum = state->err;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003c	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0003f	89 10		 mov	 DWORD PTR [eax], edx
$LN1@gzerror:

; 457  :     return state->msg == NULL ? "" : state->msg;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00044	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00048	75 09		 jne	 SHORT $LN6@gzerror
  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
  00051	eb 09		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00056	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00059	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
$LN7@gzerror:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN4@gzerror:

; 458  : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Odtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
tv75 = -12						; size = 4
tv74 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 426  :     gz_statep state;
; 427  : 
; 428  :     /* get internal structure and check integrity */
; 429  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN2@gzeof

; 430  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 68		 jmp	 SHORT $LN3@gzeof
$LN2@gzeof:

; 431  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 432  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001f	74 0f		 je	 SHORT $LN1@gzeof
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002a	74 04		 je	 SHORT $LN1@gzeof

; 433  :         return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 48		 jmp	 SHORT $LN3@gzeof
$LN1@gzeof:

; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00033	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [eax], 7247	; 00001c4fH
  00039	75 33		 jne	 SHORT $LN7@gzeof
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00042	74 1b		 je	 SHORT $LN5@gzeof
  00044	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  0004b	75 12		 jne	 SHORT $LN5@gzeof
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00050	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00054	75 09		 jne	 SHORT $LN5@gzeof
  00056	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  0005d	eb 07		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  0005f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN6@gzeof:
  00066	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  00069	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
  0006c	eb 07		 jmp	 SHORT $LN8@gzeof
$LN7@gzeof:
  0006e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN8@gzeof:
  00075	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
$LN3@gzeof:

; 438  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_offset$ = -4						; size = 4
_file$ = 8						; size = 4
_gzoffset64@4 PROC					; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 393  :     z_off64_t offset;
; 394  :     gz_statep state;
; 395  : 
; 396  :     /* get internal structure and check integrity */
; 397  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN4@gzoffset64

; 398  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 5d		 jmp	 SHORT $LN5@gzoffset64
$LN4@gzoffset64:

; 399  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 400  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00017	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00020	74 10		 je	 SHORT $LN3@gzoffset64
  00022	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002b	74 05		 je	 SHORT $LN3@gzoffset64

; 401  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 3c		 jmp	 SHORT $LN5@gzoffset64
$LN3@gzoffset64:

; 402  : 
; 403  :     /* compute and return effective offset in file */
; 404  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00032	6a 01		 push	 1
  00034	6a 00		 push	 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lseek
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 45 fc	 mov	 DWORD PTR _offset$[ebp], eax

; 405  :     if (offset == -1)

  00049	83 7d fc ff	 cmp	 DWORD PTR _offset$[ebp], -1
  0004d	75 05		 jne	 SHORT $LN2@gzoffset64

; 406  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1
  00052	eb 1a		 jmp	 SHORT $LN5@gzoffset64
$LN2@gzoffset64:

; 407  :     if (state->mode == GZ_READ)             /* reading */

  00054	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00057	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [edx], 7247	; 00001c4fH
  0005d	75 0c		 jne	 SHORT $LN1@gzoffset64

; 408  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _offset$[ebp]
  00065	2b 48 58	 sub	 ecx, DWORD PTR [eax+88]
  00068	89 4d fc	 mov	 DWORD PTR _offset$[ebp], ecx
$LN1@gzoffset64:

; 409  :     return offset;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
$LN5@gzoffset64:

; 410  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Odtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
tv71 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell64@4 PROC					; COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 366  :     gz_statep state;
; 367  : 
; 368  :     /* get internal structure and check integrity */
; 369  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN2@gztell64

; 370  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 45		 jmp	 SHORT $LN3@gztell64
$LN2@gztell64:

; 371  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 372  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00020	74 10		 je	 SHORT $LN1@gztell64
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002b	74 05		 je	 SHORT $LN1@gztell64

; 373  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 24		 jmp	 SHORT $LN3@gztell64
$LN1@gztell64:

; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00039	74 0b		 je	 SHORT $LN5@gztell64
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00041	89 55 f8	 mov	 DWORD PTR tv71[ebp], edx
  00044	eb 07		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00046	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN6@gztell64:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00050	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00053	03 45 f8	 add	 eax, DWORD PTR tv71[ebp]
$LN3@gztell64:

; 377  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Odtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 232  :     gz_statep state;
; 233  : 
; 234  :     /* get internal structure and check integrity */
; 235  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN4@gzbuffer

; 236  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 45		 jmp	 SHORT $LN5@gzbuffer
$LN4@gzbuffer:

; 237  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 238  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001e	74 10		 je	 SHORT $LN3@gzbuffer
  00020	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00023	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  00029	74 05		 je	 SHORT $LN3@gzbuffer

; 239  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	eb 24		 jmp	 SHORT $LN5@gzbuffer
$LN3@gzbuffer:

; 240  : 
; 241  :     /* make sure we haven't already allocated memory */
; 242  :     if (state->size != 0)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00033	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00037	74 05		 je	 SHORT $LN2@gzbuffer

; 243  :         return -1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	eb 16		 jmp	 SHORT $LN5@gzbuffer
$LN2@gzbuffer:

; 244  : 
; 245  :     /* check and set requested size */
; 246  :     if (size == 0)

  0003e	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  00042	75 05		 jne	 SHORT $LN1@gzbuffer

; 247  :         return -1;

  00044	83 c8 ff	 or	 eax, -1
  00047	eb 0b		 jmp	 SHORT $LN5@gzbuffer
$LN1@gzbuffer:

; 248  :     state->want = size;

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  0004f	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 249  :     return 0;

  00052	33 c0		 xor	 eax, eax
$LN5@gzbuffer:

; 250  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [eax], 7247	; 00001c4fH
  0000c	75 28		 jne	 SHORT $LN1@gz_reset

; 75   :         state->have = 0;            /* no output data available */

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00011	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 76   :         state->eof = 0;             /* not at end of file */

  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 77   :         state->how = LOOK;          /* look for gzip header */

  00022	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00025	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 78   :         state->direct = 1;          /* default for empty file */

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	c7 41 38 01 00
	00 00		 mov	 DWORD PTR [ecx+56], 1
$LN1@gz_reset:

; 79   :     }
; 80   :     state->seek = 0;                /* no seek request pending */

  00036	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00039	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 81   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _gz_error
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :     state->pos = 0;                 /* no uncompressed data yet */

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 83   :     state->strm.avail_in = 0;       /* no input data yet */

  0005a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005d	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 84   : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
tv67 = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 416  :     z_off64_t ret;
; 417  : 
; 418  :     ret = gzoffset64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gzoffset64@4
  0000f	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 419  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  00015	3b 4d fc	 cmp	 ecx, DWORD PTR _ret$[ebp]
  00018	75 08		 jne	 SHORT $LN3@gzoffset
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp]
  0001d	89 55 f8	 mov	 DWORD PTR tv67[ebp], edx
  00020	eb 07		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  00022	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv67[ebp], -1
$LN4@gzoffset:
  00029	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]

; 420  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Odtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
tv67 = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 383  :     z_off64_t ret;
; 384  : 
; 385  :     ret = gztell64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gztell64@4
  0000f	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 386  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  00015	3b 4d fc	 cmp	 ecx, DWORD PTR _ret$[ebp]
  00018	75 08		 jne	 SHORT $LN3@gztell
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp]
  0001d	89 55 f8	 mov	 DWORD PTR tv67[ebp], edx
  00020	eb 07		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  00022	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv67[ebp], -1
$LN4@gztell:
  00029	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]

; 387  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Odtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 256  :     gz_statep state;
; 257  : 
; 258  :     /* get internal structure */
; 259  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN4@gzrewind

; 260  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 50		 jmp	 SHORT $LN5@gzrewind
$LN4@gzrewind:

; 261  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 262  : 
; 263  :     /* check that we're reading and that there's no error */
; 264  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001e	75 09		 jne	 SHORT $LN2@gzrewind
  00020	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00023	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00027	74 05		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:

; 265  :         return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	eb 31		 jmp	 SHORT $LN5@gzrewind
$LN3@gzrewind:

; 266  : 
; 267  :     /* back up and start over */
; 268  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0002e	6a 00		 push	 0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00036	51		 push	 ecx
  00037	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lseek
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	83 f8 ff	 cmp	 eax, -1
  0004a	75 05		 jne	 SHORT $LN1@gzrewind

; 269  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1
  0004f	eb 0e		 jmp	 SHORT $LN5@gzrewind
$LN1@gzrewind:

; 270  :     gz_reset(state);

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _gz_reset
  0005a	83 c4 04	 add	 esp, 4

; 271  :     return 0;

  0005d	33 c0		 xor	 eax, eax
$LN5@gzrewind:

; 272  : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv145 = -16						; size = 4
tv149 = -12						; size = 4
tv82 = -8						; size = 4
_state$ = -4						; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 92   :     gz_statep state;
; 93   : 
; 94   :     /* allocate gzFile structure to return */
; 95   :     state = malloc(sizeof(gz_state));

  00006	68 8c 00 00 00	 push	 140			; 0000008cH
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00011	83 c4 04	 add	 esp, 4
  00014	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 96   :     if (state == NULL)

  00017	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  0001b	75 07		 jne	 SHORT $LN23@gz_open

; 97   :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 69 02 00 00	 jmp	 $LN24@gz_open
$LN23@gz_open:

; 98   :     state->size = 0;            /* no buffers allocated yet */

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 99   :     state->want = GZBUFSIZE;    /* requested buffer size */

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00031	c7 41 14 00 20
	00 00		 mov	 DWORD PTR [ecx+20], 8192 ; 00002000H

; 100  :     state->msg = NULL;          /* no error message yet */

  00038	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003b	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 101  : 
; 102  :     /* interpret mode */
; 103  :     state->mode = GZ_NONE;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00045	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 104  :     state->level = Z_DEFAULT_COMPRESSION;

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004e	c7 41 3c ff ff
	ff ff		 mov	 DWORD PTR [ecx+60], -1

; 105  :     state->strategy = Z_DEFAULT_STRATEGY;

  00055	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00058	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0
$LN22@gz_open:

; 106  :     while (*mode) {

  0005f	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  00062	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00065	85 c9		 test	 ecx, ecx
  00067	0f 84 c6 00 00
	00		 je	 $LN21@gz_open

; 107  :         if (*mode >= '0' && *mode <= '9')

  0006d	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  00070	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00073	83 f8 30	 cmp	 eax, 48			; 00000030H
  00076	7c 1f		 jl	 SHORT $LN20@gz_open
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  0007b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0007e	83 fa 39	 cmp	 edx, 57			; 00000039H
  00081	7f 14		 jg	 SHORT $LN20@gz_open

; 108  :             state->level = *mode - '0';

  00083	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  00086	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00089	83 e9 30	 sub	 ecx, 48			; 00000030H
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 109  :         else

  00092	e9 8e 00 00 00	 jmp	 $LN19@gz_open
$LN20@gz_open:

; 110  :             switch (*mode) {

  00097	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	89 4d f8	 mov	 DWORD PTR tv82[ebp], ecx
  000a0	8b 55 f8	 mov	 edx, DWORD PTR tv82[ebp]
  000a3	83 ea 2b	 sub	 edx, 43			; 0000002bH
  000a6	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  000a9	83 7d f8 4c	 cmp	 DWORD PTR tv82[ebp], 76	; 0000004cH
  000ad	77 76		 ja	 SHORT $LN19@gz_open
  000af	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  000b2	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN30@gz_open[eax]
  000b9	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN31@gz_open[ecx*4]
$LN16@gz_open:

; 111  :             case 'r':
; 112  :                 state->mode = GZ_READ;

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c3	c7 02 4f 1c 00
	00		 mov	 DWORD PTR [edx], 7247	; 00001c4fH

; 113  :                 break;

  000c9	eb 5a		 jmp	 SHORT $LN19@gz_open
$LN15@gz_open:

; 114  : #ifndef NO_GZCOMPRESS
; 115  :             case 'w':
; 116  :                 state->mode = GZ_WRITE;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ce	c7 00 b1 79 00
	00		 mov	 DWORD PTR [eax], 31153	; 000079b1H

; 117  :                 break;

  000d4	eb 4f		 jmp	 SHORT $LN19@gz_open
$LN14@gz_open:

; 118  :             case 'a':
; 119  :                 state->mode = GZ_APPEND;

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 120  :                 break;

  000df	eb 44		 jmp	 SHORT $LN19@gz_open
$LN13@gz_open:

; 121  : #endif
; 122  :             case '+':       /* can't read and write at the same time */
; 123  :                 free(state);

  000e1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	52		 push	 edx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000eb	83 c4 04	 add	 esp, 4

; 124  :                 return NULL;

  000ee	33 c0		 xor	 eax, eax
  000f0	e9 98 01 00 00	 jmp	 $LN24@gz_open

; 125  :             case 'b':       /* ignore -- will request binary anyway */
; 126  :                 break;

  000f5	eb 2e		 jmp	 SHORT $LN19@gz_open
$LN11@gz_open:

; 127  :             case 'f':
; 128  :                 state->strategy = Z_FILTERED;

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000fa	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [eax+64], 1

; 129  :                 break;

  00101	eb 22		 jmp	 SHORT $LN19@gz_open
$LN10@gz_open:

; 130  :             case 'h':
; 131  :                 state->strategy = Z_HUFFMAN_ONLY;

  00103	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00106	c7 41 40 02 00
	00 00		 mov	 DWORD PTR [ecx+64], 2

; 132  :                 break;

  0010d	eb 16		 jmp	 SHORT $LN19@gz_open
$LN9@gz_open:

; 133  :             case 'R':
; 134  :                 state->strategy = Z_RLE;

  0010f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00112	c7 42 40 03 00
	00 00		 mov	 DWORD PTR [edx+64], 3

; 135  :                 break;

  00119	eb 0a		 jmp	 SHORT $LN19@gz_open
$LN8@gz_open:

; 136  :             case 'F':
; 137  :                 state->strategy = Z_FIXED;

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0011e	c7 40 40 04 00
	00 00		 mov	 DWORD PTR [eax+64], 4
$LN19@gz_open:

; 138  :             default:        /* could consider as an error, but just ignore */
; 139  :                 ;
; 140  :             }
; 141  :         mode++;

  00125	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00128	83 c1 01	 add	 ecx, 1
  0012b	89 4d 10	 mov	 DWORD PTR _mode$[ebp], ecx

; 142  :     }

  0012e	e9 2c ff ff ff	 jmp	 $LN22@gz_open
$LN21@gz_open:

; 143  : 
; 144  :     /* must provide an "r", "w", or "a" */
; 145  :     if (state->mode == GZ_NONE) {

  00133	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00136	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00139	75 14		 jne	 SHORT $LN6@gz_open

; 146  :         free(state);

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0013e	50		 push	 eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00145	83 c4 04	 add	 esp, 4

; 147  :         return NULL;

  00148	33 c0		 xor	 eax, eax
  0014a	e9 3e 01 00 00	 jmp	 $LN24@gz_open
$LN6@gz_open:

; 148  :     }
; 149  : 
; 150  :     /* save the path name for error messages */
; 151  :     state->path = malloc(strlen(path) + 1);

  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _strlen
  00158	83 c4 04	 add	 esp, 4
  0015b	83 c0 01	 add	 eax, 1
  0015e	50		 push	 eax
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00165	83 c4 04	 add	 esp, 4
  00168	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0016b	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 152  :     if (state->path == NULL) {

  0016e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00171	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00175	75 14		 jne	 SHORT $LN5@gz_open

; 153  :         free(state);

  00177	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0017a	51		 push	 ecx
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00181	83 c4 04	 add	 esp, 4

; 154  :         return NULL;

  00184	33 c0		 xor	 eax, eax
  00186	e9 02 01 00 00	 jmp	 $LN24@gz_open
$LN5@gz_open:

; 155  :     }
; 156  :     strcpy(state->path, path);

  0018b	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0018e	52		 push	 edx
  0018f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00192	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 _strcpy
  0019b	83 c4 08	 add	 esp, 8

; 157  : 
; 158  :     /* open the file with the appropriate mode (or just use fd) */
; 159  :     state->fd = fd != -1 ? fd :
; 160  :         open(path,
; 161  : #ifdef O_LARGEFILE
; 162  :             O_LARGEFILE |
; 163  : #endif
; 164  : #ifdef O_BINARY
; 165  :             O_BINARY |
; 166  : #endif
; 167  :             (state->mode == GZ_READ ?
; 168  :                 O_RDONLY :
; 169  :                 (O_WRONLY | O_CREAT | (
; 170  :                     state->mode == GZ_WRITE ?
; 171  :                         O_TRUNC :
; 172  :                         O_APPEND))),
; 173  :             0666);

  0019e	83 7d 0c ff	 cmp	 DWORD PTR _fd$[ebp], -1
  001a2	74 08		 je	 SHORT $LN28@gz_open
  001a4	8b 55 0c	 mov	 edx, DWORD PTR _fd$[ebp]
  001a7	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  001aa	eb 56		 jmp	 SHORT $LN29@gz_open
$LN28@gz_open:
  001ac	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001af	81 38 4f 1c 00
	00		 cmp	 DWORD PTR [eax], 7247	; 00001c4fH
  001b5	75 09		 jne	 SHORT $LN26@gz_open
  001b7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  001be	eb 24		 jmp	 SHORT $LN27@gz_open
$LN26@gz_open:
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c5	81 ea b1 79 00
	00		 sub	 edx, 31153		; 000079b1H
  001cb	f7 da		 neg	 edx
  001cd	1b d2		 sbb	 edx, edx
  001cf	81 e2 08 fe ff
	ff		 and	 edx, -504		; fffffe08H
  001d5	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  001db	81 ca 01 01 00
	00		 or	 edx, 257		; 00000101H
  001e1	89 55 f0	 mov	 DWORD PTR tv145[ebp], edx
$LN27@gz_open:
  001e4	68 b6 01 00 00	 push	 438			; 000001b6H
  001e9	8b 45 f0	 mov	 eax, DWORD PTR tv145[ebp]
  001ec	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  001f1	50		 push	 eax
  001f2	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001f5	51		 push	 ecx
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__open
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ff	89 45 f4	 mov	 DWORD PTR tv149[ebp], eax
$LN29@gz_open:
  00202	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00205	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00208	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 174  :     if (state->fd == -1) {

  0020b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0020e	83 79 04 ff	 cmp	 DWORD PTR [ecx+4], -1
  00212	75 21		 jne	 SHORT $LN4@gz_open

; 175  :         free(state->path);

  00214	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00217	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0021a	50		 push	 eax
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00221	83 c4 04	 add	 esp, 4

; 176  :         free(state);

  00224	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00227	51		 push	 ecx
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0022e	83 c4 04	 add	 esp, 4

; 177  :         return NULL;

  00231	33 c0		 xor	 eax, eax
  00233	eb 58		 jmp	 SHORT $LN24@gz_open
$LN4@gz_open:

; 178  :     }
; 179  :     if (state->mode == GZ_APPEND)

  00235	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00238	83 3a 01	 cmp	 DWORD PTR [edx], 1
  0023b	75 09		 jne	 SHORT $LN3@gz_open

; 180  :         state->mode = GZ_WRITE;         /* simplify later checks */

  0023d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00240	c7 00 b1 79 00
	00		 mov	 DWORD PTR [eax], 31153	; 000079b1H
$LN3@gz_open:

; 181  : 
; 182  :     /* save the current position for rewinding (only if reading) */
; 183  :     if (state->mode == GZ_READ) {

  00246	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00249	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0024f	75 2d		 jne	 SHORT $LN2@gz_open

; 184  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00251	6a 01		 push	 1
  00253	6a 00		 push	 0
  00255	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00258	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0025b	50		 push	 eax
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lseek
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
  00265	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00268	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 185  :         if (state->start == -1) state->start = 0;

  0026b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0026e	83 7a 2c ff	 cmp	 DWORD PTR [edx+44], -1
  00272	75 0a		 jne	 SHORT $LN2@gz_open
  00274	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00277	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN2@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  0027e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00281	51		 push	 ecx
  00282	e8 00 00 00 00	 call	 _gz_reset
  00287	83 c4 04	 add	 esp, 4

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  0028a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
$LN24@gz_open:

; 193  : }

  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c3		 ret	 0
  00291	8d 49 00	 npad	 3
$LN31@gz_open:
  00294	00 00 00 00	 DD	 $LN13@gz_open
  00298	00 00 00 00	 DD	 $LN8@gz_open
  0029c	00 00 00 00	 DD	 $LN9@gz_open
  002a0	00 00 00 00	 DD	 $LN14@gz_open
  002a4	00 00 00 00	 DD	 $LN11@gz_open
  002a8	00 00 00 00	 DD	 $LN10@gz_open
  002ac	00 00 00 00	 DD	 $LN16@gz_open
  002b0	00 00 00 00	 DD	 $LN15@gz_open
  002b4	00 00 00 00	 DD	 $LN19@gz_open
$LN30@gz_open:
  002b8	00		 DB	 0
  002b9	08		 DB	 8
  002ba	08		 DB	 8
  002bb	08		 DB	 8
  002bc	08		 DB	 8
  002bd	08		 DB	 8
  002be	08		 DB	 8
  002bf	08		 DB	 8
  002c0	08		 DB	 8
  002c1	08		 DB	 8
  002c2	08		 DB	 8
  002c3	08		 DB	 8
  002c4	08		 DB	 8
  002c5	08		 DB	 8
  002c6	08		 DB	 8
  002c7	08		 DB	 8
  002c8	08		 DB	 8
  002c9	08		 DB	 8
  002ca	08		 DB	 8
  002cb	08		 DB	 8
  002cc	08		 DB	 8
  002cd	08		 DB	 8
  002ce	08		 DB	 8
  002cf	08		 DB	 8
  002d0	08		 DB	 8
  002d1	08		 DB	 8
  002d2	08		 DB	 8
  002d3	01		 DB	 1
  002d4	08		 DB	 8
  002d5	08		 DB	 8
  002d6	08		 DB	 8
  002d7	08		 DB	 8
  002d8	08		 DB	 8
  002d9	08		 DB	 8
  002da	08		 DB	 8
  002db	08		 DB	 8
  002dc	08		 DB	 8
  002dd	08		 DB	 8
  002de	08		 DB	 8
  002df	02		 DB	 2
  002e0	08		 DB	 8
  002e1	08		 DB	 8
  002e2	08		 DB	 8
  002e3	08		 DB	 8
  002e4	08		 DB	 8
  002e5	08		 DB	 8
  002e6	08		 DB	 8
  002e7	08		 DB	 8
  002e8	08		 DB	 8
  002e9	08		 DB	 8
  002ea	08		 DB	 8
  002eb	08		 DB	 8
  002ec	08		 DB	 8
  002ed	08		 DB	 8
  002ee	03		 DB	 3
  002ef	08		 DB	 8
  002f0	08		 DB	 8
  002f1	08		 DB	 8
  002f2	08		 DB	 8
  002f3	04		 DB	 4
  002f4	08		 DB	 8
  002f5	05		 DB	 5
  002f6	08		 DB	 8
  002f7	08		 DB	 8
  002f8	08		 DB	 8
  002f9	08		 DB	 8
  002fa	08		 DB	 8
  002fb	08		 DB	 8
  002fc	08		 DB	 8
  002fd	08		 DB	 8
  002fe	08		 DB	 8
  002ff	06		 DB	 6
  00300	08		 DB	 8
  00301	08		 DB	 8
  00302	08		 DB	 8
  00303	08		 DB	 8
  00304	07		 DB	 7
_gz_open ENDP
PUBLIC	_gzseek64@12
; Function compile flags: /Odtp
;	COMDAT _gzseek64@12
_TEXT	SEGMENT
tv152 = -16						; size = 4
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek64@12 PROC					; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 280  :     unsigned n;
; 281  :     z_off64_t ret;
; 282  :     gz_statep state;
; 283  : 
; 284  :     /* get internal structure and check integrity */
; 285  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN15@gzseek64

; 286  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 07 02 00 00	 jmp	 $LN16@gzseek64
$LN15@gzseek64:

; 287  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 288  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00023	74 13		 je	 SHORT $LN14@gzseek64
  00025	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002e	74 08		 je	 SHORT $LN14@gzseek64

; 289  :         return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	e9 e3 01 00 00	 jmp	 $LN16@gzseek64
$LN14@gzseek64:

; 290  : 
; 291  :     /* check that there's no error */
; 292  :     if (state->err != Z_OK)

  00038	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0003f	74 08		 je	 SHORT $LN13@gzseek64

; 293  :         return -1;

  00041	83 c8 ff	 or	 eax, -1
  00044	e9 d2 01 00 00	 jmp	 $LN16@gzseek64
$LN13@gzseek64:

; 294  : 
; 295  :     /* can only seek from start or relative to current position */
; 296  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00049	83 7d 10 00	 cmp	 DWORD PTR _whence$[ebp], 0
  0004d	74 0e		 je	 SHORT $LN12@gzseek64
  0004f	83 7d 10 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00053	74 08		 je	 SHORT $LN12@gzseek64

; 297  :         return -1;

  00055	83 c8 ff	 or	 eax, -1
  00058	e9 be 01 00 00	 jmp	 $LN16@gzseek64
$LN12@gzseek64:

; 298  : 
; 299  :     /* normalize offset to a SEEK_CUR specification */
; 300  :     if (whence == SEEK_SET)

  0005d	83 7d 10 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00061	75 0e		 jne	 SHORT $LN11@gzseek64

; 301  :         offset -= state->pos;

  00063	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00069	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  0006c	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
  0006f	eb 15		 jmp	 SHORT $LN10@gzseek64
$LN11@gzseek64:

; 302  :     else if (state->seek)

  00071	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00074	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00078	74 0c		 je	 SHORT $LN10@gzseek64

; 303  :         offset += state->skip;

  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00080	03 51 44	 add	 edx, DWORD PTR [ecx+68]
  00083	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
$LN10@gzseek64:

; 304  :     state->seek = 0;

  00086	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00089	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 305  : 
; 306  :     /* if within raw area while reading, just go there */
; 307  :     if (state->mode == GZ_READ && state->how == COPY &&
; 308  :         state->pos + offset >= state->raw) {

  00090	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00093	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00099	0f 85 9d 00 00
	00		 jne	 $LN8@gzseek64
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	83 7a 34 01	 cmp	 DWORD PTR [edx+52], 1
  000a6	0f 85 90 00 00
	00		 jne	 $LN8@gzseek64
  000ac	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000af	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b2	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  000b5	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000b8	3b 4a 30	 cmp	 ecx, DWORD PTR [edx+48]
  000bb	7c 7f		 jl	 SHORT $LN8@gzseek64

; 309  :         ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);

  000bd	6a 01		 push	 1
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  000c5	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000c8	51		 push	 ecx
  000c9	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lseek
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 310  :         if (ret == -1)

  000dc	83 7d f8 ff	 cmp	 DWORD PTR _ret$[ebp], -1
  000e0	75 08		 jne	 SHORT $LN7@gzseek64

; 311  :             return -1;

  000e2	83 c8 ff	 or	 eax, -1
  000e5	e9 31 01 00 00	 jmp	 $LN16@gzseek64
$LN7@gzseek64:

; 312  :         state->have = 0;

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000ed	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 313  :         state->eof = 0;

  000f4	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000f7	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 314  :         state->seek = 0;

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00101	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 315  :         gz_error(state, Z_OK, NULL);

  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _gz_error
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  :         state->strm.avail_in = 0;

  00118	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0011b	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 317  :         state->pos += offset;

  00122	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00125	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00128	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  0012b	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0012e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 318  :         return state->pos;

  00131	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00134	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00137	e9 df 00 00 00	 jmp	 $LN16@gzseek64
$LN8@gzseek64:

; 319  :     }
; 320  : 
; 321  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 322  :     if (offset < 0) {

  0013c	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  00140	7d 3f		 jge	 SHORT $LN6@gzseek64

; 323  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  00142	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00145	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0014b	74 08		 je	 SHORT $LN5@gzseek64

; 324  :             return -1;

  0014d	83 c8 ff	 or	 eax, -1
  00150	e9 c6 00 00 00	 jmp	 $LN16@gzseek64
$LN5@gzseek64:

; 325  :         offset += state->pos;

  00155	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00158	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0015b	03 42 0c	 add	 eax, DWORD PTR [edx+12]
  0015e	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax

; 326  :         if (offset < 0)                     /* before start of file! */

  00161	79 08		 jns	 SHORT $LN4@gzseek64

; 327  :             return -1;

  00163	83 c8 ff	 or	 eax, -1
  00166	e9 b0 00 00 00	 jmp	 $LN16@gzseek64
$LN4@gzseek64:

; 328  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0016e	51		 push	 ecx
  0016f	e8 00 00 00 00	 call	 _gzrewind@4
  00174	83 f8 ff	 cmp	 eax, -1
  00177	75 08		 jne	 SHORT $LN6@gzseek64

; 329  :             return -1;

  00179	83 c8 ff	 or	 eax, -1
  0017c	e9 9a 00 00 00	 jmp	 $LN16@gzseek64
$LN6@gzseek64:

; 330  :     }
; 331  : 
; 332  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 333  :     if (state->mode == GZ_READ) {

  00181	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00184	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [edx], 7247	; 00001c4fH
  0018a	75 6d		 jne	 SHORT $LN2@gzseek64

; 334  :         n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?
; 335  :             (unsigned)offset : state->have;

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	85 c0		 test	 eax, eax
  00193	74 0c		 je	 SHORT $LN18@gzseek64
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00198	81 79 24 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+36], 2147483647 ; 7fffffffH
  0019f	77 16		 ja	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  001a1	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001a4	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001a7	3b 45 0c	 cmp	 eax, DWORD PTR _offset$[ebp]
  001aa	7f 0b		 jg	 SHORT $LN19@gzseek64
  001ac	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  001af	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001b2	89 55 f0	 mov	 DWORD PTR tv152[ebp], edx
  001b5	eb 06		 jmp	 SHORT $LN20@gzseek64
$LN19@gzseek64:
  001b7	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  001ba	89 45 f0	 mov	 DWORD PTR tv152[ebp], eax
$LN20@gzseek64:
  001bd	8b 4d f0	 mov	 ecx, DWORD PTR tv152[ebp]
  001c0	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 336  :         state->have -= n;

  001c3	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001c6	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001c9	2b 45 fc	 sub	 eax, DWORD PTR _n$[ebp]
  001cc	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  001cf	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 337  :         state->next += n;

  001d2	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001d5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001d8	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001db	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  001de	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 338  :         state->pos += n;

  001e1	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001e4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001e7	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001ea	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  001ed	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 339  :         offset -= n;

  001f0	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  001f3	2b 55 fc	 sub	 edx, DWORD PTR _n$[ebp]
  001f6	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
$LN2@gzseek64:

; 340  :     }
; 341  : 
; 342  :     /* request skip (if not zero) */
; 343  :     if (offset) {

  001f9	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001fd	74 13		 je	 SHORT $LN1@gzseek64

; 344  :         state->seek = 1;

  001ff	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00202	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [eax+72], 1

; 345  :         state->skip = offset;

  00209	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0020c	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  0020f	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN1@gzseek64:

; 346  :     }
; 347  :     return state->pos + offset;

  00212	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00215	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00218	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
$LN16@gzseek64:

; 348  : }

  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 0c 00	 ret	 12			; 0000000cH
_gzseek64@12 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Odtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_path$ = -8						; size = 4
_gz$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 216  :     char *path;         /* identifier for error messages */
; 217  :     gzFile gz;
; 218  : 
; 219  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00006	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  0000a	74 14		 je	 SHORT $LN1@gzdopen
  0000c	6a 13		 push	 19			; 00000013H
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 f8	 mov	 DWORD PTR _path$[ebp], eax
  0001a	83 7d f8 00	 cmp	 DWORD PTR _path$[ebp], 0
  0001e	75 04		 jne	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 220  :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 3d		 jmp	 SHORT $LN3@gzdopen
$LN2@gzdopen:

; 221  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  00024	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00030	51		 push	 ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 222  :     gz = gz_open(path, fd, mode);

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00041	50		 push	 eax
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _gz_open
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	89 45 fc	 mov	 DWORD PTR _gz$[ebp], eax

; 223  :     free(path);

  00051	8b 55 f8	 mov	 edx, DWORD PTR _path$[ebp]
  00054	52		 push	 edx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005b	83 c4 04	 add	 esp, 4

; 224  :     return gz;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _gz$[ebp]
$LN3@gzdopen:

; 225  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Odtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  :     return gz_open(path, -1, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a ff		 push	 -1
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Odtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
tv69 = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 356  :     z_off64_t ret;
; 357  : 
; 358  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00006	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 _gzseek64@12
  00017	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 359  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  0001d	3b 45 fc	 cmp	 eax, DWORD PTR _ret$[ebp]
  00020	75 08		 jne	 SHORT $LN3@gzseek
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  00025	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  00028	eb 07		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  0002a	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv69[ebp], -1
$LN4@gzseek:
  00031	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 360  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
