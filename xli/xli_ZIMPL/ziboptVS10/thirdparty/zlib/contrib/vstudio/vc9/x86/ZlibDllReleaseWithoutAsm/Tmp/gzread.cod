; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\lp_solve_5.5\xli\xli_ZIMPL\ziboptVS10\thirdparty\zlib\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp__memchr:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__close:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
PUBLIC	_gzclose_r@4
; Function compile flags: /Odtp
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzread.c
;	COMDAT _gzclose_r@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_r@4 PROC					; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 630  :     int ret;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN3@gzclose_r

; 635  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 94 00 00 00	 jmp	 $LN4@gzclose_r
$LN3@gzclose_r:

; 636  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00025	74 07		 je	 SHORT $LN2@gzclose_r

; 640  :         return Z_STREAM_ERROR;

  00027	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002c	eb 7c		 jmp	 SHORT $LN4@gzclose_r
$LN2@gzclose_r:

; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  0002e	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00031	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00035	74 2c		 je	 SHORT $LN1@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00037	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0003a	83 c0 54	 add	 eax, 84			; 00000054H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _inflateEnd@4

; 645  :         free(state->out);

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00049	52		 push	 edx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00050	83 c4 04	 add	 esp, 4

; 646  :         free(state->in);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00056	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00060	83 c4 04	 add	 esp, 4
$LN1@gzclose_r:

; 647  :     }
; 648  :     gz_error(state, Z_OK, NULL);

  00063	6a 00		 push	 0
  00065	6a 00		 push	 0
  00067	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _gz_error
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 649  :     free(state->path);

  00073	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00076	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00079	51		 push	 ecx
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00080	83 c4 04	 add	 esp, 4

; 650  :     ret = close(state->fd);

  00083	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00086	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 651  :     free(state);

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00099	51		 push	 ecx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000a0	83 c4 04	 add	 esp, 4

; 652  :     return ret ? Z_ERRNO : Z_OK;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  000a6	f7 d8		 neg	 eax
  000a8	1b c0		 sbb	 eax, eax
$LN4@gzclose_r:

; 653  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
_gzclose_r@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_load
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_gz_load PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 27   :     int ret;
; 28   : 
; 29   :     *have = 0;

  00004	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00007	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN6@gz_load:

; 30   :     do {
; 31   :         ret = read(state->fd, buf + *have, len - *have);

  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  00010	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00013	2b 11		 sub	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0001c	03 08		 add	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__read
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 32   :         if (ret <= 0)

  00032	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00036	7f 02		 jg	 SHORT $LN3@gz_load

; 33   :             break;

  00038	eb 17		 jmp	 SHORT $LN4@gz_load
$LN3@gz_load:

; 34   :         *have += ret;

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	03 55 fc	 add	 edx, DWORD PTR _ret$[ebp]
  00042	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx

; 35   :     } while (*have < len);

  00047	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0004f	72 bc		 jb	 SHORT $LN6@gz_load
$LN4@gz_load:

; 36   :     if (ret < 0) {

  00051	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00055	7d 26		 jge	 SHORT $LN2@gz_load

; 37   :         gz_error(state, Z_ERRNO, zstrerror());

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	50		 push	 eax
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00066	83 c4 04	 add	 esp, 4
  00069	50		 push	 eax
  0006a	6a ff		 push	 -1
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _gz_error
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 38   :         return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	eb 12		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 39   :     }
; 40   :     if (ret == 0)

  0007d	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00081	75 0a		 jne	 SHORT $LN1@gz_load

; 41   :         state->eof = 1;

  00083	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00086	c7 42 28 01 00
	00 00		 mov	 DWORD PTR [edx+40], 1
$LN1@gz_load:

; 42   :     return 0;

  0008d	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 43   : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_gz_load ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_avail
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_avail PROC						; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 53   :     z_streamp strm = &(state->strm);

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 c0 54	 add	 eax, 84			; 00000054H
  0000a	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 54   : 
; 55   :     if (state->err != Z_OK)

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  00014	74 05		 je	 SHORT $LN3@gz_avail

; 56   :         return -1;

  00016	83 c8 ff	 or	 eax, -1
  00019	eb 41		 jmp	 SHORT $LN4@gz_avail
$LN3@gz_avail:

; 57   :     if (state->eof == 0) {

  0001b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001e	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00022	75 36		 jne	 SHORT $LN2@gz_avail

; 58   :         if (gz_load(state, state->in, state->size,
; 59   :                 (unsigned *)&(strm->avail_in)) == -1)

  00024	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00035	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _gz_load
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	83 f8 ff	 cmp	 eax, -1
  00048	75 05		 jne	 SHORT $LN1@gz_avail

; 60   :             return -1;

  0004a	83 c8 ff	 or	 eax, -1
  0004d	eb 0d		 jmp	 SHORT $LN4@gz_avail
$LN1@gz_avail:

; 61   :         strm->next_in = state->in;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00055	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00058	89 10		 mov	 DWORD PTR [eax], edx
$LN2@gz_avail:

; 62   :     }
; 63   :     return 0;

  0005a	33 c0		 xor	 eax, eax
$LN4@gz_avail:

; 64   : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_gz_avail ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_head
_TEXT	SEGMENT
tv437 = -132						; size = 4
tv438 = -128						; size = 4
tv421 = -124						; size = 4
tv422 = -120						; size = 4
tv402 = -116						; size = 4
tv403 = -112						; size = 4
tv383 = -108						; size = 4
tv384 = -104						; size = 4
tv364 = -100						; size = 4
tv365 = -96						; size = 4
tv344 = -92						; size = 4
tv345 = -88						; size = 4
tv328 = -84						; size = 4
tv329 = -80						; size = 4
tv310 = -76						; size = 4
tv311 = -72						; size = 4
tv294 = -68						; size = 4
tv295 = -64						; size = 4
tv278 = -60						; size = 4
tv279 = -56						; size = 4
tv262 = -52						; size = 4
tv263 = -48						; size = 4
tv246 = -44						; size = 4
tv247 = -40						; size = 4
tv230 = -36						; size = 4
tv231 = -32						; size = 4
tv209 = -28						; size = 4
tv210 = -24						; size = 4
tv189 = -20						; size = 4
tv190 = -16						; size = 4
_strm$ = -12						; size = 4
_len$ = -8						; size = 4
_flags$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_head PROC						; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H

; 107  :     z_streamp strm = &(state->strm);

  00009	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0000c	83 c0 54	 add	 eax, 84			; 00000054H
  0000f	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 108  :     int flags;
; 109  :     unsigned len;
; 110  : 
; 111  :     /* allocate read buffers and inflate memory */
; 112  :     if (state->size == 0) {

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00019	0f 85 29 01 00
	00		 jne	 $LN27@gz_head

; 113  :         /* allocate buffers */
; 114  :         state->in = malloc(state->want);

  0001f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00022	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00032	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 115  :         state->out = malloc(state->want << 1);

  00035	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0003b	d1 e0		 shl	 eax, 1
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00044	83 c4 04	 add	 esp, 4
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 116  :         if (state->in == NULL || state->out == NULL) {

  0004d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00050	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00054	74 09		 je	 SHORT $LN25@gz_head
  00056	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00059	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0005d	75 4d		 jne	 SHORT $LN26@gz_head
$LN25@gz_head:

; 117  :             if (state->out != NULL)

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00066	74 10		 je	 SHORT $LN24@gz_head

; 118  :                 free(state->out);

  00068	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00075	83 c4 04	 add	 esp, 4
$LN24@gz_head:

; 119  :             if (state->in != NULL)

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0007b	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0007f	74 10		 je	 SHORT $LN23@gz_head

; 120  :                 free(state->in);

  00081	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00084	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00087	50		 push	 eax
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0008e	83 c4 04	 add	 esp, 4
$LN23@gz_head:

; 121  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00096	6a fc		 push	 -4			; fffffffcH
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _gz_error
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  :             return -1;

  000a4	83 c8 ff	 or	 eax, -1
  000a7	e9 90 08 00 00	 jmp	 $LN28@gz_head
$LN26@gz_head:

; 123  :         }
; 124  :         state->size = state->want;

  000ac	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000af	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b5	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 125  : 
; 126  :         /* allocate inflate memory */
; 127  :         state->strm.zalloc = Z_NULL;

  000b8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000bb	c7 42 74 00 00
	00 00		 mov	 DWORD PTR [edx+116], 0

; 128  :         state->strm.zfree = Z_NULL;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 129  :         state->strm.opaque = Z_NULL;

  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0

; 130  :         state->strm.avail_in = 0;

  000d6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d9	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 131  :         state->strm.next_in = Z_NULL;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e3	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 132  :         if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */

  000ea	6a 38		 push	 56			; 00000038H
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45?$AA@
  000f1	6a f1		 push	 -15			; fffffff1H
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000f6	83 c1 54	 add	 ecx, 84			; 00000054H
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 _inflateInit2_@16
  000ff	85 c0		 test	 eax, eax
  00101	74 45		 je	 SHORT $LN27@gz_head

; 133  :             free(state->out);

  00103	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00106	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00110	83 c4 04	 add	 esp, 4

; 134  :             free(state->in);

  00113	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00116	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00119	52		 push	 edx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00120	83 c4 04	 add	 esp, 4

; 135  :             state->size = 0;

  00123	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00126	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 136  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00132	6a fc		 push	 -4			; fffffffcH
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _gz_error
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  :             return -1;

  00140	83 c8 ff	 or	 eax, -1
  00143	e9 f4 07 00 00	 jmp	 $LN28@gz_head
$LN27@gz_head:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     /* get some data in the input buffer */
; 142  :     if (strm->avail_in == 0) {

  00148	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0014b	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0014f	75 29		 jne	 SHORT $LN21@gz_head

; 143  :         if (gz_avail(state) == -1)

  00151	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _gz_avail
  0015a	83 c4 04	 add	 esp, 4
  0015d	83 f8 ff	 cmp	 eax, -1
  00160	75 08		 jne	 SHORT $LN20@gz_head

; 144  :             return -1;

  00162	83 c8 ff	 or	 eax, -1
  00165	e9 d2 07 00 00	 jmp	 $LN28@gz_head
$LN20@gz_head:

; 145  :         if (strm->avail_in == 0)

  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0016d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00171	75 07		 jne	 SHORT $LN21@gz_head

; 146  :             return 0;

  00173	33 c0		 xor	 eax, eax
  00175	e9 c2 07 00 00	 jmp	 $LN28@gz_head
$LN21@gz_head:

; 147  :     }
; 148  : 
; 149  :     /* look for the gzip magic header bytes 31 and 139 */
; 150  :     if (strm->next_in[0] == 31) {

  0017a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0017d	8b 02		 mov	 eax, DWORD PTR [edx]
  0017f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00182	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00185	0f 85 3c 07 00
	00		 jne	 $LN18@gz_head

; 151  :         strm->avail_in--;

  0018b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0018e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00191	83 e8 01	 sub	 eax, 1
  00194	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00197	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 152  :         strm->next_in++;

  0019a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0019d	8b 02		 mov	 eax, DWORD PTR [edx]
  0019f	83 c0 01	 add	 eax, 1
  001a2	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  001a5	89 01		 mov	 DWORD PTR [ecx], eax

; 153  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  001a7	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001aa	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  001ae	75 19		 jne	 SHORT $LN17@gz_head
  001b0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _gz_avail
  001b9	83 c4 04	 add	 esp, 4
  001bc	83 f8 ff	 cmp	 eax, -1
  001bf	75 08		 jne	 SHORT $LN17@gz_head

; 154  :             return -1;

  001c1	83 c8 ff	 or	 eax, -1
  001c4	e9 73 07 00 00	 jmp	 $LN28@gz_head
$LN17@gz_head:

; 155  :         if (strm->avail_in && strm->next_in[0] == 139) {

  001c9	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  001cc	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  001d0	0f 84 de 06 00
	00		 je	 $LN16@gz_head
  001d6	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001d9	8b 02		 mov	 eax, DWORD PTR [edx]
  001db	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001de	81 f9 8b 00 00
	00		 cmp	 ecx, 139		; 0000008bH
  001e4	0f 85 ca 06 00
	00		 jne	 $LN16@gz_head

; 156  :             /* we have a gzip header, woo hoo! */
; 157  :             strm->avail_in--;

  001ea	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001ed	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001f0	83 e8 01	 sub	 eax, 1
  001f3	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  001f6	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 158  :             strm->next_in++;

  001f9	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001fc	8b 02		 mov	 eax, DWORD PTR [edx]
  001fe	83 c0 01	 add	 eax, 1
  00201	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00204	89 01		 mov	 DWORD PTR [ecx], eax

; 159  : 
; 160  :             /* skip rest of header */
; 161  :             if (NEXT() != 8) {      /* compression method */

  00206	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00209	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0020d	75 1a		 jne	 SHORT $LN30@gz_head
  0020f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _gz_avail
  00218	83 c4 04	 add	 esp, 4
  0021b	83 f8 ff	 cmp	 eax, -1
  0021e	75 09		 jne	 SHORT $LN30@gz_head
  00220	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv190[ebp], -1
  00227	eb 3f		 jmp	 SHORT $LN33@gz_head
$LN30@gz_head:
  00229	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0022c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00230	75 09		 jne	 SHORT $LN31@gz_head
  00232	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv189[ebp], -1
  00239	eb 27		 jmp	 SHORT $LN32@gz_head
$LN31@gz_head:
  0023b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0023e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00241	83 e8 01	 sub	 eax, 1
  00244	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00247	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0024a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0024d	8b 02		 mov	 eax, DWORD PTR [edx]
  0024f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00252	89 4d ec	 mov	 DWORD PTR tv189[ebp], ecx
  00255	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00258	8b 02		 mov	 eax, DWORD PTR [edx]
  0025a	83 c0 01	 add	 eax, 1
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00260	89 01		 mov	 DWORD PTR [ecx], eax
$LN32@gz_head:
  00262	8b 55 ec	 mov	 edx, DWORD PTR tv189[ebp]
  00265	89 55 f0	 mov	 DWORD PTR tv190[ebp], edx
$LN33@gz_head:
  00268	83 7d f0 08	 cmp	 DWORD PTR tv190[ebp], 8
  0026c	74 1b		 je	 SHORT $LN15@gz_head

; 162  :                 gz_error(state, Z_DATA_ERROR, "unknown compression method");

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  00273	6a fd		 push	 -3			; fffffffdH
  00275	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00278	50		 push	 eax
  00279	e8 00 00 00 00	 call	 _gz_error
  0027e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  :                 return -1;

  00281	83 c8 ff	 or	 eax, -1
  00284	e9 b3 06 00 00	 jmp	 $LN28@gz_head
$LN15@gz_head:

; 164  :             }
; 165  :             flags = NEXT();

  00289	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0028c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00290	75 1a		 jne	 SHORT $LN34@gz_head
  00292	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00295	52		 push	 edx
  00296	e8 00 00 00 00	 call	 _gz_avail
  0029b	83 c4 04	 add	 esp, 4
  0029e	83 f8 ff	 cmp	 eax, -1
  002a1	75 09		 jne	 SHORT $LN34@gz_head
  002a3	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR tv210[ebp], -1
  002aa	eb 3f		 jmp	 SHORT $LN37@gz_head
$LN34@gz_head:
  002ac	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  002af	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  002b3	75 09		 jne	 SHORT $LN35@gz_head
  002b5	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR tv209[ebp], -1
  002bc	eb 27		 jmp	 SHORT $LN36@gz_head
$LN35@gz_head:
  002be	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  002c1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002c4	83 ea 01	 sub	 edx, 1
  002c7	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  002ca	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002cd	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  002d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002d5	89 45 e4	 mov	 DWORD PTR tv209[ebp], eax
  002d8	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  002db	8b 11		 mov	 edx, DWORD PTR [ecx]
  002dd	83 c2 01	 add	 edx, 1
  002e0	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  002e3	89 10		 mov	 DWORD PTR [eax], edx
$LN36@gz_head:
  002e5	8b 4d e4	 mov	 ecx, DWORD PTR tv209[ebp]
  002e8	89 4d e8	 mov	 DWORD PTR tv210[ebp], ecx
$LN37@gz_head:
  002eb	8b 55 e8	 mov	 edx, DWORD PTR tv210[ebp]
  002ee	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx

; 166  :             if (flags & 0xe0) {     /* reserved flag bits */

  002f1	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  002f4	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  002f9	74 1b		 je	 SHORT $LN14@gz_head

; 167  :                 gz_error(state, Z_DATA_ERROR, "unknown header flags set");

  002fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  00300	6a fd		 push	 -3			; fffffffdH
  00302	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00305	51		 push	 ecx
  00306	e8 00 00 00 00	 call	 _gz_error
  0030b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  :                 return -1;

  0030e	83 c8 ff	 or	 eax, -1
  00311	e9 26 06 00 00	 jmp	 $LN28@gz_head
$LN14@gz_head:

; 169  :             }
; 170  :             NEXT();                 /* modification time */

  00316	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00319	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0031d	75 1a		 jne	 SHORT $LN38@gz_head
  0031f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 _gz_avail
  00328	83 c4 04	 add	 esp, 4
  0032b	83 f8 ff	 cmp	 eax, -1
  0032e	75 09		 jne	 SHORT $LN38@gz_head
  00330	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR tv231[ebp], -1
  00337	eb 3f		 jmp	 SHORT $LN41@gz_head
$LN38@gz_head:
  00339	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0033c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00340	75 09		 jne	 SHORT $LN39@gz_head
  00342	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR tv230[ebp], -1
  00349	eb 27		 jmp	 SHORT $LN40@gz_head
$LN39@gz_head:
  0034b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0034e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00351	83 e8 01	 sub	 eax, 1
  00354	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00357	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0035a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0035d	8b 02		 mov	 eax, DWORD PTR [edx]
  0035f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00362	89 4d dc	 mov	 DWORD PTR tv230[ebp], ecx
  00365	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00368	8b 02		 mov	 eax, DWORD PTR [edx]
  0036a	83 c0 01	 add	 eax, 1
  0036d	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00370	89 01		 mov	 DWORD PTR [ecx], eax
$LN40@gz_head:
  00372	8b 55 dc	 mov	 edx, DWORD PTR tv230[ebp]
  00375	89 55 e0	 mov	 DWORD PTR tv231[ebp], edx
$LN41@gz_head:

; 171  :             NEXT();

  00378	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0037b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0037f	75 1a		 jne	 SHORT $LN42@gz_head
  00381	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00384	51		 push	 ecx
  00385	e8 00 00 00 00	 call	 _gz_avail
  0038a	83 c4 04	 add	 esp, 4
  0038d	83 f8 ff	 cmp	 eax, -1
  00390	75 09		 jne	 SHORT $LN42@gz_head
  00392	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR tv247[ebp], -1
  00399	eb 3f		 jmp	 SHORT $LN45@gz_head
$LN42@gz_head:
  0039b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0039e	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  003a2	75 09		 jne	 SHORT $LN43@gz_head
  003a4	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR tv246[ebp], -1
  003ab	eb 27		 jmp	 SHORT $LN44@gz_head
$LN43@gz_head:
  003ad	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  003b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003b3	83 e9 01	 sub	 ecx, 1
  003b6	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  003b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003bc	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  003bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  003c4	89 55 d4	 mov	 DWORD PTR tv246[ebp], edx
  003c7	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  003ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  003cc	83 c1 01	 add	 ecx, 1
  003cf	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  003d2	89 0a		 mov	 DWORD PTR [edx], ecx
$LN44@gz_head:
  003d4	8b 45 d4	 mov	 eax, DWORD PTR tv246[ebp]
  003d7	89 45 d8	 mov	 DWORD PTR tv247[ebp], eax
$LN45@gz_head:

; 172  :             NEXT();

  003da	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  003dd	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  003e1	75 1a		 jne	 SHORT $LN46@gz_head
  003e3	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  003e6	52		 push	 edx
  003e7	e8 00 00 00 00	 call	 _gz_avail
  003ec	83 c4 04	 add	 esp, 4
  003ef	83 f8 ff	 cmp	 eax, -1
  003f2	75 09		 jne	 SHORT $LN46@gz_head
  003f4	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR tv263[ebp], -1
  003fb	eb 3f		 jmp	 SHORT $LN49@gz_head
$LN46@gz_head:
  003fd	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00400	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00404	75 09		 jne	 SHORT $LN47@gz_head
  00406	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR tv262[ebp], -1
  0040d	eb 27		 jmp	 SHORT $LN48@gz_head
$LN47@gz_head:
  0040f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00412	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00415	83 ea 01	 sub	 edx, 1
  00418	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0041b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0041e	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00421	8b 11		 mov	 edx, DWORD PTR [ecx]
  00423	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00426	89 45 cc	 mov	 DWORD PTR tv262[ebp], eax
  00429	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0042c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042e	83 c2 01	 add	 edx, 1
  00431	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00434	89 10		 mov	 DWORD PTR [eax], edx
$LN48@gz_head:
  00436	8b 4d cc	 mov	 ecx, DWORD PTR tv262[ebp]
  00439	89 4d d0	 mov	 DWORD PTR tv263[ebp], ecx
$LN49@gz_head:

; 173  :             NEXT();

  0043c	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0043f	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00443	75 1a		 jne	 SHORT $LN50@gz_head
  00445	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00448	50		 push	 eax
  00449	e8 00 00 00 00	 call	 _gz_avail
  0044e	83 c4 04	 add	 esp, 4
  00451	83 f8 ff	 cmp	 eax, -1
  00454	75 09		 jne	 SHORT $LN50@gz_head
  00456	c7 45 c8 ff ff
	ff ff		 mov	 DWORD PTR tv279[ebp], -1
  0045d	eb 3f		 jmp	 SHORT $LN53@gz_head
$LN50@gz_head:
  0045f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00462	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00466	75 09		 jne	 SHORT $LN51@gz_head
  00468	c7 45 c4 ff ff
	ff ff		 mov	 DWORD PTR tv278[ebp], -1
  0046f	eb 27		 jmp	 SHORT $LN52@gz_head
$LN51@gz_head:
  00471	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00474	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00477	83 e8 01	 sub	 eax, 1
  0047a	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0047d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00480	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00483	8b 02		 mov	 eax, DWORD PTR [edx]
  00485	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00488	89 4d c4	 mov	 DWORD PTR tv278[ebp], ecx
  0048b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0048e	8b 02		 mov	 eax, DWORD PTR [edx]
  00490	83 c0 01	 add	 eax, 1
  00493	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00496	89 01		 mov	 DWORD PTR [ecx], eax
$LN52@gz_head:
  00498	8b 55 c4	 mov	 edx, DWORD PTR tv278[ebp]
  0049b	89 55 c8	 mov	 DWORD PTR tv279[ebp], edx
$LN53@gz_head:

; 174  :             NEXT();                 /* extra flags */

  0049e	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  004a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  004a5	75 1a		 jne	 SHORT $LN54@gz_head
  004a7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  004aa	51		 push	 ecx
  004ab	e8 00 00 00 00	 call	 _gz_avail
  004b0	83 c4 04	 add	 esp, 4
  004b3	83 f8 ff	 cmp	 eax, -1
  004b6	75 09		 jne	 SHORT $LN54@gz_head
  004b8	c7 45 c0 ff ff
	ff ff		 mov	 DWORD PTR tv295[ebp], -1
  004bf	eb 3f		 jmp	 SHORT $LN57@gz_head
$LN54@gz_head:
  004c1	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  004c4	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  004c8	75 09		 jne	 SHORT $LN55@gz_head
  004ca	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR tv294[ebp], -1
  004d1	eb 27		 jmp	 SHORT $LN56@gz_head
$LN55@gz_head:
  004d3	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  004d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d9	83 e9 01	 sub	 ecx, 1
  004dc	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  004df	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  004e2	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  004e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e7	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  004ea	89 55 bc	 mov	 DWORD PTR tv294[ebp], edx
  004ed	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  004f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f2	83 c1 01	 add	 ecx, 1
  004f5	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  004f8	89 0a		 mov	 DWORD PTR [edx], ecx
$LN56@gz_head:
  004fa	8b 45 bc	 mov	 eax, DWORD PTR tv294[ebp]
  004fd	89 45 c0	 mov	 DWORD PTR tv295[ebp], eax
$LN57@gz_head:

; 175  :             NEXT();                 /* operating system */

  00500	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00503	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00507	75 1a		 jne	 SHORT $LN58@gz_head
  00509	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0050c	52		 push	 edx
  0050d	e8 00 00 00 00	 call	 _gz_avail
  00512	83 c4 04	 add	 esp, 4
  00515	83 f8 ff	 cmp	 eax, -1
  00518	75 09		 jne	 SHORT $LN58@gz_head
  0051a	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv311[ebp], -1
  00521	eb 3f		 jmp	 SHORT $LN61@gz_head
$LN58@gz_head:
  00523	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00526	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0052a	75 09		 jne	 SHORT $LN59@gz_head
  0052c	c7 45 b4 ff ff
	ff ff		 mov	 DWORD PTR tv310[ebp], -1
  00533	eb 27		 jmp	 SHORT $LN60@gz_head
$LN59@gz_head:
  00535	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00538	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0053b	83 ea 01	 sub	 edx, 1
  0053e	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00541	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00544	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00547	8b 11		 mov	 edx, DWORD PTR [ecx]
  00549	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0054c	89 45 b4	 mov	 DWORD PTR tv310[ebp], eax
  0054f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00552	8b 11		 mov	 edx, DWORD PTR [ecx]
  00554	83 c2 01	 add	 edx, 1
  00557	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0055a	89 10		 mov	 DWORD PTR [eax], edx
$LN60@gz_head:
  0055c	8b 4d b4	 mov	 ecx, DWORD PTR tv310[ebp]
  0055f	89 4d b8	 mov	 DWORD PTR tv311[ebp], ecx
$LN61@gz_head:

; 176  :             if (flags & 4) {        /* extra field */

  00562	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  00565	83 e2 04	 and	 edx, 4
  00568	0f 84 52 01 00
	00		 je	 $LN13@gz_head

; 177  :                 len = (unsigned)NEXT();

  0056e	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00571	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00575	75 1a		 jne	 SHORT $LN62@gz_head
  00577	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0057a	51		 push	 ecx
  0057b	e8 00 00 00 00	 call	 _gz_avail
  00580	83 c4 04	 add	 esp, 4
  00583	83 f8 ff	 cmp	 eax, -1
  00586	75 09		 jne	 SHORT $LN62@gz_head
  00588	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv329[ebp], -1
  0058f	eb 3f		 jmp	 SHORT $LN65@gz_head
$LN62@gz_head:
  00591	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00594	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00598	75 09		 jne	 SHORT $LN63@gz_head
  0059a	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR tv328[ebp], -1
  005a1	eb 27		 jmp	 SHORT $LN64@gz_head
$LN63@gz_head:
  005a3	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  005a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005a9	83 e9 01	 sub	 ecx, 1
  005ac	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  005af	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005b2	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  005b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  005b7	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  005ba	89 55 ac	 mov	 DWORD PTR tv328[ebp], edx
  005bd	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  005c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c2	83 c1 01	 add	 ecx, 1
  005c5	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  005c8	89 0a		 mov	 DWORD PTR [edx], ecx
$LN64@gz_head:
  005ca	8b 45 ac	 mov	 eax, DWORD PTR tv328[ebp]
  005cd	89 45 b0	 mov	 DWORD PTR tv329[ebp], eax
$LN65@gz_head:
  005d0	8b 4d b0	 mov	 ecx, DWORD PTR tv329[ebp]
  005d3	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx

; 178  :                 len += (unsigned)NEXT() << 8;

  005d6	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  005d9	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  005dd	75 1a		 jne	 SHORT $LN66@gz_head
  005df	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  005e2	50		 push	 eax
  005e3	e8 00 00 00 00	 call	 _gz_avail
  005e8	83 c4 04	 add	 esp, 4
  005eb	83 f8 ff	 cmp	 eax, -1
  005ee	75 09		 jne	 SHORT $LN66@gz_head
  005f0	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR tv345[ebp], -1
  005f7	eb 3f		 jmp	 SHORT $LN69@gz_head
$LN66@gz_head:
  005f9	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  005fc	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00600	75 09		 jne	 SHORT $LN67@gz_head
  00602	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR tv344[ebp], -1
  00609	eb 27		 jmp	 SHORT $LN68@gz_head
$LN67@gz_head:
  0060b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0060e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00611	83 e8 01	 sub	 eax, 1
  00614	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00617	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0061a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0061d	8b 02		 mov	 eax, DWORD PTR [edx]
  0061f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00622	89 4d a4	 mov	 DWORD PTR tv344[ebp], ecx
  00625	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00628	8b 02		 mov	 eax, DWORD PTR [edx]
  0062a	83 c0 01	 add	 eax, 1
  0062d	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00630	89 01		 mov	 DWORD PTR [ecx], eax
$LN68@gz_head:
  00632	8b 55 a4	 mov	 edx, DWORD PTR tv344[ebp]
  00635	89 55 a8	 mov	 DWORD PTR tv345[ebp], edx
$LN69@gz_head:
  00638	8b 45 a8	 mov	 eax, DWORD PTR tv345[ebp]
  0063b	c1 e0 08	 shl	 eax, 8
  0063e	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  00641	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN12@gz_head:

; 179  :                 while (len--)

  00644	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  00647	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0064a	83 ea 01	 sub	 edx, 1
  0064d	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx
  00650	85 c9		 test	 ecx, ecx
  00652	74 6c		 je	 SHORT $LN13@gz_head

; 180  :                     if (NEXT() < 0)

  00654	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00657	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0065b	75 1a		 jne	 SHORT $LN70@gz_head
  0065d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00660	51		 push	 ecx
  00661	e8 00 00 00 00	 call	 _gz_avail
  00666	83 c4 04	 add	 esp, 4
  00669	83 f8 ff	 cmp	 eax, -1
  0066c	75 09		 jne	 SHORT $LN70@gz_head
  0066e	c7 45 a0 ff ff
	ff ff		 mov	 DWORD PTR tv365[ebp], -1
  00675	eb 3f		 jmp	 SHORT $LN73@gz_head
$LN70@gz_head:
  00677	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0067a	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0067e	75 09		 jne	 SHORT $LN71@gz_head
  00680	c7 45 9c ff ff
	ff ff		 mov	 DWORD PTR tv364[ebp], -1
  00687	eb 27		 jmp	 SHORT $LN72@gz_head
$LN71@gz_head:
  00689	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0068c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0068f	83 e9 01	 sub	 ecx, 1
  00692	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00695	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00698	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0069b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0069d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  006a0	89 55 9c	 mov	 DWORD PTR tv364[ebp], edx
  006a3	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  006a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  006a8	83 c1 01	 add	 ecx, 1
  006ab	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  006ae	89 0a		 mov	 DWORD PTR [edx], ecx
$LN72@gz_head:
  006b0	8b 45 9c	 mov	 eax, DWORD PTR tv364[ebp]
  006b3	89 45 a0	 mov	 DWORD PTR tv365[ebp], eax
$LN73@gz_head:
  006b6	83 7d a0 00	 cmp	 DWORD PTR tv365[ebp], 0
  006ba	7d 02		 jge	 SHORT $LN10@gz_head

; 181  :                         break;

  006bc	eb 02		 jmp	 SHORT $LN13@gz_head
$LN10@gz_head:

; 182  :             }

  006be	eb 84		 jmp	 SHORT $LN12@gz_head
$LN13@gz_head:

; 183  :             if (flags & 8)          /* file name */

  006c0	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  006c3	83 e1 08	 and	 ecx, 8
  006c6	74 6a		 je	 SHORT $LN9@gz_head
$LN8@gz_head:

; 184  :                 while (NEXT() > 0)

  006c8	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  006cb	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  006cf	75 1a		 jne	 SHORT $LN74@gz_head
  006d1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  006d4	50		 push	 eax
  006d5	e8 00 00 00 00	 call	 _gz_avail
  006da	83 c4 04	 add	 esp, 4
  006dd	83 f8 ff	 cmp	 eax, -1
  006e0	75 09		 jne	 SHORT $LN74@gz_head
  006e2	c7 45 98 ff ff
	ff ff		 mov	 DWORD PTR tv384[ebp], -1
  006e9	eb 3f		 jmp	 SHORT $LN77@gz_head
$LN74@gz_head:
  006eb	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  006ee	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  006f2	75 09		 jne	 SHORT $LN75@gz_head
  006f4	c7 45 94 ff ff
	ff ff		 mov	 DWORD PTR tv383[ebp], -1
  006fb	eb 27		 jmp	 SHORT $LN76@gz_head
$LN75@gz_head:
  006fd	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00700	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00703	83 e8 01	 sub	 eax, 1
  00706	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00709	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0070c	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0070f	8b 02		 mov	 eax, DWORD PTR [edx]
  00711	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00714	89 4d 94	 mov	 DWORD PTR tv383[ebp], ecx
  00717	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0071a	8b 02		 mov	 eax, DWORD PTR [edx]
  0071c	83 c0 01	 add	 eax, 1
  0071f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00722	89 01		 mov	 DWORD PTR [ecx], eax
$LN76@gz_head:
  00724	8b 55 94	 mov	 edx, DWORD PTR tv383[ebp]
  00727	89 55 98	 mov	 DWORD PTR tv384[ebp], edx
$LN77@gz_head:
  0072a	83 7d 98 00	 cmp	 DWORD PTR tv384[ebp], 0
  0072e	7e 02		 jle	 SHORT $LN9@gz_head

; 185  :                     ;

  00730	eb 96		 jmp	 SHORT $LN8@gz_head
$LN9@gz_head:

; 186  :             if (flags & 16)         /* comment */

  00732	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  00735	83 e0 10	 and	 eax, 16			; 00000010H
  00738	74 6a		 je	 SHORT $LN6@gz_head
$LN5@gz_head:

; 187  :                 while (NEXT() > 0)

  0073a	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0073d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00741	75 1a		 jne	 SHORT $LN78@gz_head
  00743	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00746	52		 push	 edx
  00747	e8 00 00 00 00	 call	 _gz_avail
  0074c	83 c4 04	 add	 esp, 4
  0074f	83 f8 ff	 cmp	 eax, -1
  00752	75 09		 jne	 SHORT $LN78@gz_head
  00754	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR tv403[ebp], -1
  0075b	eb 3f		 jmp	 SHORT $LN81@gz_head
$LN78@gz_head:
  0075d	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00760	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00764	75 09		 jne	 SHORT $LN79@gz_head
  00766	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR tv402[ebp], -1
  0076d	eb 27		 jmp	 SHORT $LN80@gz_head
$LN79@gz_head:
  0076f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00772	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00775	83 ea 01	 sub	 edx, 1
  00778	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0077b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0077e	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00781	8b 11		 mov	 edx, DWORD PTR [ecx]
  00783	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00786	89 45 8c	 mov	 DWORD PTR tv402[ebp], eax
  00789	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0078c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0078e	83 c2 01	 add	 edx, 1
  00791	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00794	89 10		 mov	 DWORD PTR [eax], edx
$LN80@gz_head:
  00796	8b 4d 8c	 mov	 ecx, DWORD PTR tv402[ebp]
  00799	89 4d 90	 mov	 DWORD PTR tv403[ebp], ecx
$LN81@gz_head:
  0079c	83 7d 90 00	 cmp	 DWORD PTR tv403[ebp], 0
  007a0	7e 02		 jle	 SHORT $LN6@gz_head

; 188  :                     ;

  007a2	eb 96		 jmp	 SHORT $LN5@gz_head
$LN6@gz_head:

; 189  :             if (flags & 2) {        /* header crc */

  007a4	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  007a7	83 e2 02	 and	 edx, 2
  007aa	0f 84 cd 00 00
	00		 je	 $LN3@gz_head

; 190  :                 NEXT();

  007b0	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  007b3	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  007b7	75 1a		 jne	 SHORT $LN82@gz_head
  007b9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  007bc	51		 push	 ecx
  007bd	e8 00 00 00 00	 call	 _gz_avail
  007c2	83 c4 04	 add	 esp, 4
  007c5	83 f8 ff	 cmp	 eax, -1
  007c8	75 09		 jne	 SHORT $LN82@gz_head
  007ca	c7 45 88 ff ff
	ff ff		 mov	 DWORD PTR tv422[ebp], -1
  007d1	eb 3f		 jmp	 SHORT $LN85@gz_head
$LN82@gz_head:
  007d3	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  007d6	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  007da	75 09		 jne	 SHORT $LN83@gz_head
  007dc	c7 45 84 ff ff
	ff ff		 mov	 DWORD PTR tv421[ebp], -1
  007e3	eb 27		 jmp	 SHORT $LN84@gz_head
$LN83@gz_head:
  007e5	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  007e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007eb	83 e9 01	 sub	 ecx, 1
  007ee	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  007f1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  007f4	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  007f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f9	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007fc	89 55 84	 mov	 DWORD PTR tv421[ebp], edx
  007ff	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00802	8b 08		 mov	 ecx, DWORD PTR [eax]
  00804	83 c1 01	 add	 ecx, 1
  00807	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0080a	89 0a		 mov	 DWORD PTR [edx], ecx
$LN84@gz_head:
  0080c	8b 45 84	 mov	 eax, DWORD PTR tv421[ebp]
  0080f	89 45 88	 mov	 DWORD PTR tv422[ebp], eax
$LN85@gz_head:

; 191  :                 NEXT();

  00812	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00815	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00819	75 1a		 jne	 SHORT $LN86@gz_head
  0081b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0081e	52		 push	 edx
  0081f	e8 00 00 00 00	 call	 _gz_avail
  00824	83 c4 04	 add	 esp, 4
  00827	83 f8 ff	 cmp	 eax, -1
  0082a	75 09		 jne	 SHORT $LN86@gz_head
  0082c	c7 45 80 ff ff
	ff ff		 mov	 DWORD PTR tv438[ebp], -1
  00833	eb 48		 jmp	 SHORT $LN3@gz_head
$LN86@gz_head:
  00835	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00838	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0083c	75 0c		 jne	 SHORT $LN87@gz_head
  0083e	c7 85 7c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv437[ebp], -1
  00848	eb 2a		 jmp	 SHORT $LN88@gz_head
$LN87@gz_head:
  0084a	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0084d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00850	83 ea 01	 sub	 edx, 1
  00853	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00856	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00859	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0085c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0085e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00861	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv437[ebp], eax
  00867	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0086a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0086c	83 c2 01	 add	 edx, 1
  0086f	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  00872	89 10		 mov	 DWORD PTR [eax], edx
$LN88@gz_head:
  00874	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv437[ebp]
  0087a	89 4d 80	 mov	 DWORD PTR tv438[ebp], ecx
$LN3@gz_head:

; 192  :             }
; 193  :             /* an unexpected end of file is not checked for here -- it will be
; 194  :                noticed on the first request for uncompressed data */
; 195  : 
; 196  :             /* set up for decompression */
; 197  :             inflateReset(strm);

  0087d	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00880	52		 push	 edx
  00881	e8 00 00 00 00	 call	 _inflateReset@4

; 198  :             strm->adler = crc32(0L, Z_NULL, 0);

  00886	6a 00		 push	 0
  00888	6a 00		 push	 0
  0088a	6a 00		 push	 0
  0088c	e8 00 00 00 00	 call	 _crc32@12
  00891	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00894	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 199  :             state->how = GZIP;

  00897	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0089a	c7 42 34 02 00
	00 00		 mov	 DWORD PTR [edx+52], 2

; 200  :             state->direct = 0;

  008a1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  008a4	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 201  :             return 0;

  008ab	33 c0		 xor	 eax, eax
  008ad	e9 8a 00 00 00	 jmp	 $LN28@gz_head

; 202  :         }
; 203  :         else {

  008b2	eb 13		 jmp	 SHORT $LN18@gz_head
$LN16@gz_head:

; 204  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 205  :             state->out[0] = 31;

  008b4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  008b7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  008ba	c6 02 1f	 mov	 BYTE PTR [edx], 31	; 0000001fH

; 206  :             state->have = 1;

  008bd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  008c0	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [eax+36], 1
$LN18@gz_head:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 211  :        input to output -- this assumes that the output buffer is larger than
; 212  :        the input buffer, which also assures space for gzungetc() */
; 213  :     state->raw = state->pos;

  008c7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  008ca	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  008cd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  008d0	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 214  :     state->next = state->out;

  008d3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  008d6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  008d9	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  008dc	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 215  :     if (strm->avail_in) {

  008df	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  008e2	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  008e6	74 3e		 je	 SHORT $LN1@gz_head

; 216  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

  008e8	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  008eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008ee	50		 push	 eax
  008ef	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  008f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  008f4	52		 push	 edx
  008f5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  008f8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  008fb	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  008fe	03 4a 24	 add	 ecx, DWORD PTR [edx+36]
  00901	51		 push	 ecx
  00902	e8 00 00 00 00	 call	 _memcpy
  00907	83 c4 0c	 add	 esp, 12			; 0000000cH

; 217  :         state->have += strm->avail_in;

  0090a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0090d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00910	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00913	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00916	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00919	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 218  :         strm->avail_in = 0;

  0091c	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0091f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN1@gz_head:

; 219  :     }
; 220  :     state->how = COPY;

  00926	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00929	c7 42 34 01 00
	00 00		 mov	 DWORD PTR [edx+52], 1

; 221  :     state->direct = 1;

  00930	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00933	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1

; 222  :     return 0;

  0093a	33 c0		 xor	 eax, eax
$LN28@gz_head:

; 223  : }

  0093c	8b e5		 mov	 esp, ebp
  0093e	5d		 pop	 ebp
  0093f	c3		 ret	 0
_gz_head ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_next4
_TEXT	SEGMENT
tv163 = -44						; size = 4
tv164 = -40						; size = 4
tv145 = -36						; size = 4
tv146 = -32						; size = 4
tv95 = -28						; size = 4
tv128 = -24						; size = 4
tv79 = -20						; size = 4
tv80 = -16						; size = 4
_ch$ = -12						; size = 4
_val$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_ret$ = 12						; size = 4
_gz_next4 PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 77   :     int ch;
; 78   :     unsigned long val;
; 79   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 54	 add	 eax, 84			; 00000054H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 80   : 
; 81   :     val = NEXT();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	75 1a		 jne	 SHORT $LN4@gz_next4
  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _gz_avail
  00021	83 c4 04	 add	 esp, 4
  00024	83 f8 ff	 cmp	 eax, -1
  00027	75 09		 jne	 SHORT $LN4@gz_next4
  00029	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv80[ebp], -1
  00030	eb 3f		 jmp	 SHORT $LN7@gz_next4
$LN4@gz_next4:
  00032	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00035	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00039	75 09		 jne	 SHORT $LN5@gz_next4
  0003b	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv79[ebp], -1
  00042	eb 27		 jmp	 SHORT $LN6@gz_next4
$LN5@gz_next4:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00047	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004a	83 ea 01	 sub	 edx, 1
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00056	8b 11		 mov	 edx, DWORD PTR [ecx]
  00058	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0005b	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	83 c2 01	 add	 edx, 1
  00066	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00069	89 10		 mov	 DWORD PTR [eax], edx
$LN6@gz_next4:
  0006b	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  0006e	89 4d f0	 mov	 DWORD PTR tv80[ebp], ecx
$LN7@gz_next4:
  00071	8b 55 f0	 mov	 edx, DWORD PTR tv80[ebp]
  00074	89 55 f8	 mov	 DWORD PTR _val$[ebp], edx

; 82   :     val += (unsigned)NEXT() << 8;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0007a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007e	75 1a		 jne	 SHORT $LN8@gz_next4
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _gz_avail
  00089	83 c4 04	 add	 esp, 4
  0008c	83 f8 ff	 cmp	 eax, -1
  0008f	75 09		 jne	 SHORT $LN8@gz_next4
  00091	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR tv128[ebp], -1
  00098	eb 3f		 jmp	 SHORT $LN11@gz_next4
$LN8@gz_next4:
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0009d	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000a1	75 09		 jne	 SHORT $LN9@gz_next4
  000a3	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR tv95[ebp], -1
  000aa	eb 27		 jmp	 SHORT $LN10@gz_next4
$LN9@gz_next4:
  000ac	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b2	83 e9 01	 sub	 ecx, 1
  000b5	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000b8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000c3	89 55 e4	 mov	 DWORD PTR tv95[ebp], edx
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cb	83 c1 01	 add	 ecx, 1
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000d1	89 0a		 mov	 DWORD PTR [edx], ecx
$LN10@gz_next4:
  000d3	8b 45 e4	 mov	 eax, DWORD PTR tv95[ebp]
  000d6	89 45 e8	 mov	 DWORD PTR tv128[ebp], eax
$LN11@gz_next4:
  000d9	8b 4d e8	 mov	 ecx, DWORD PTR tv128[ebp]
  000dc	c1 e1 08	 shl	 ecx, 8
  000df	03 4d f8	 add	 ecx, DWORD PTR _val$[ebp]
  000e2	89 4d f8	 mov	 DWORD PTR _val$[ebp], ecx

; 83   :     val += (unsigned long)NEXT() << 16;

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000e8	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000ec	75 1a		 jne	 SHORT $LN12@gz_next4
  000ee	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _gz_avail
  000f7	83 c4 04	 add	 esp, 4
  000fa	83 f8 ff	 cmp	 eax, -1
  000fd	75 09		 jne	 SHORT $LN12@gz_next4
  000ff	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR tv146[ebp], -1
  00106	eb 3f		 jmp	 SHORT $LN15@gz_next4
$LN12@gz_next4:
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0010b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0010f	75 09		 jne	 SHORT $LN13@gz_next4
  00111	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR tv145[ebp], -1
  00118	eb 27		 jmp	 SHORT $LN14@gz_next4
$LN13@gz_next4:
  0011a	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0011d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00120	83 e8 01	 sub	 eax, 1
  00123	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00126	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00129	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0012c	8b 02		 mov	 eax, DWORD PTR [edx]
  0012e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00131	89 4d dc	 mov	 DWORD PTR tv145[ebp], ecx
  00134	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00137	8b 02		 mov	 eax, DWORD PTR [edx]
  00139	83 c0 01	 add	 eax, 1
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013f	89 01		 mov	 DWORD PTR [ecx], eax
$LN14@gz_next4:
  00141	8b 55 dc	 mov	 edx, DWORD PTR tv145[ebp]
  00144	89 55 e0	 mov	 DWORD PTR tv146[ebp], edx
$LN15@gz_next4:
  00147	8b 45 e0	 mov	 eax, DWORD PTR tv146[ebp]
  0014a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0014d	03 45 f8	 add	 eax, DWORD PTR _val$[ebp]
  00150	89 45 f8	 mov	 DWORD PTR _val$[ebp], eax

; 84   :     ch = NEXT();

  00153	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00156	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0015a	75 1a		 jne	 SHORT $LN16@gz_next4
  0015c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 _gz_avail
  00165	83 c4 04	 add	 esp, 4
  00168	83 f8 ff	 cmp	 eax, -1
  0016b	75 09		 jne	 SHORT $LN16@gz_next4
  0016d	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR tv164[ebp], -1
  00174	eb 3f		 jmp	 SHORT $LN19@gz_next4
$LN16@gz_next4:
  00176	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00179	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0017d	75 09		 jne	 SHORT $LN17@gz_next4
  0017f	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR tv163[ebp], -1
  00186	eb 27		 jmp	 SHORT $LN18@gz_next4
$LN17@gz_next4:
  00188	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0018b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0018e	83 ea 01	 sub	 edx, 1
  00191	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00194	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0019a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0019f	89 45 d4	 mov	 DWORD PTR tv163[ebp], eax
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  001a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a7	83 c2 01	 add	 edx, 1
  001aa	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  001ad	89 10		 mov	 DWORD PTR [eax], edx
$LN18@gz_next4:
  001af	8b 4d d4	 mov	 ecx, DWORD PTR tv163[ebp]
  001b2	89 4d d8	 mov	 DWORD PTR tv164[ebp], ecx
$LN19@gz_next4:
  001b5	8b 55 d8	 mov	 edx, DWORD PTR tv164[ebp]
  001b8	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx

; 85   :     if (ch == -1)

  001bb	83 7d f4 ff	 cmp	 DWORD PTR _ch$[ebp], -1
  001bf	75 05		 jne	 SHORT $LN1@gz_next4

; 86   :         return -1;

  001c1	83 c8 ff	 or	 eax, -1
  001c4	eb 16		 jmp	 SHORT $LN2@gz_next4
$LN1@gz_next4:

; 87   :     val += (unsigned long)ch << 24;

  001c6	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
  001c9	c1 e0 18	 shl	 eax, 24			; 00000018H
  001cc	03 45 f8	 add	 eax, DWORD PTR _val$[ebp]
  001cf	89 45 f8	 mov	 DWORD PTR _val$[ebp], eax

; 88   :     *ret = val;

  001d2	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  001d5	8b 55 f8	 mov	 edx, DWORD PTR _val$[ebp]
  001d8	89 11		 mov	 DWORD PTR [ecx], edx

; 89   :     return 0;

  001da	33 c0		 xor	 eax, eax
$LN2@gz_next4:

; 90   : }

  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
_gz_next4 ENDP
PUBLIC	_gzdirect@4
; Function compile flags: /Odtp
;	COMDAT _gzdirect@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzdirect@4 PROC					; COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 606  :     gz_statep state;
; 607  : 
; 608  :     /* get internal structure */
; 609  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 04		 jne	 SHORT $LN3@gzdirect

; 610  :         return 0;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 39		 jmp	 SHORT $LN4@gzdirect
$LN3@gzdirect:

; 611  :     state = (gz_statep)file;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00011	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 612  : 
; 613  :     /* check that we're reading */
; 614  :     if (state->mode != GZ_READ)

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00017	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0001d	74 04		 je	 SHORT $LN2@gzdirect

; 615  :         return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 24		 jmp	 SHORT $LN4@gzdirect
$LN2@gzdirect:

; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->how == LOOK && state->have == 0)

  00023	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00026	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  0002a	75 15		 jne	 SHORT $LN1@gzdirect
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00033	75 0c		 jne	 SHORT $LN1@gzdirect

; 620  :         (void)gz_head(state);

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _gz_head
  0003e	83 c4 04	 add	 esp, 4
$LN1@gzdirect:

; 621  : 
; 622  :     /* return 1 if reading direct, 0 if decompressing a gzip stream */
; 623  :     return state->direct;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00044	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
$LN4@gzdirect:

; 624  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
_gzdirect@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_decomp
_TEXT	SEGMENT
tv92 = -24						; size = 4
_ret$ = -20						; size = 4
_had$ = -16						; size = 4
_len$ = -12						; size = 4
_strm$ = -8						; size = 4
_crc$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_decomp PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 236  :     int ret;
; 237  :     unsigned had;
; 238  :     unsigned long crc, len;
; 239  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 54	 add	 eax, 84			; 00000054H
  0000c	89 45 f8	 mov	 DWORD PTR _strm$[ebp], eax

; 240  : 
; 241  :     /* fill output buffer up to end of deflate stream */
; 242  :     had = strm->avail_out;

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f0	 mov	 DWORD PTR _had$[ebp], edx
$LN15@gz_decomp:

; 243  :     do {
; 244  :         /* get more input for inflate() */
; 245  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00018	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  0001b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001f	75 19		 jne	 SHORT $LN12@gz_decomp
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _gz_avail
  0002a	83 c4 04	 add	 esp, 4
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	75 08		 jne	 SHORT $LN12@gz_decomp

; 246  :             return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	e9 a7 01 00 00	 jmp	 $LN16@gz_decomp
$LN12@gz_decomp:

; 247  :         if (strm->avail_in == 0) {

  0003a	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0003d	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00041	75 1b		 jne	 SHORT $LN11@gz_decomp

; 248  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  00048	6a fd		 push	 -3			; fffffffdH
  0004a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _gz_error
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 249  :             return -1;

  00056	83 c8 ff	 or	 eax, -1
  00059	e9 83 01 00 00	 jmp	 $LN16@gz_decomp
$LN11@gz_decomp:

; 250  :         }
; 251  : 
; 252  :         /* decompress and handle errors */
; 253  :         ret = inflate(strm, Z_NO_FLUSH);

  0005e	6a 00		 push	 0
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _inflate@8
  00069	89 45 ec	 mov	 DWORD PTR _ret$[ebp], eax

; 254  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  0006c	83 7d ec fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  00070	74 06		 je	 SHORT $LN9@gz_decomp
  00072	83 7d ec 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00076	75 1b		 jne	 SHORT $LN10@gz_decomp
$LN9@gz_decomp:

; 255  :             gz_error(state, Z_STREAM_ERROR,
; 256  :                       "internal error: inflate stream corrupt");

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  0007d	6a fe		 push	 -2			; fffffffeH
  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _gz_error
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  :             return -1;

  0008b	83 c8 ff	 or	 eax, -1
  0008e	e9 4e 01 00 00	 jmp	 $LN16@gz_decomp
$LN10@gz_decomp:

; 258  :         }
; 259  :         if (ret == Z_MEM_ERROR) {

  00093	83 7d ec fc	 cmp	 DWORD PTR _ret$[ebp], -4 ; fffffffcH
  00097	75 1b		 jne	 SHORT $LN8@gz_decomp

; 260  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0009e	6a fc		 push	 -4			; fffffffcH
  000a0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _gz_error
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  :             return -1;

  000ac	83 c8 ff	 or	 eax, -1
  000af	e9 2d 01 00 00	 jmp	 $LN16@gz_decomp
$LN8@gz_decomp:

; 262  :         }
; 263  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  000b4	83 7d ec fd	 cmp	 DWORD PTR _ret$[ebp], -3 ; fffffffdH
  000b8	75 35		 jne	 SHORT $LN14@gz_decomp

; 264  :             gz_error(state, Z_DATA_ERROR,
; 265  :                       strm->msg == NULL ? "compressed data error" : strm->msg);

  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000bd	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000c1	75 09		 jne	 SHORT $LN18@gz_decomp
  000c3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000ca	eb 09		 jmp	 SHORT $LN19@gz_decomp
$LN18@gz_decomp:
  000cc	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  000cf	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000d2	89 45 e8	 mov	 DWORD PTR tv92[ebp], eax
$LN19@gz_decomp:
  000d5	8b 4d e8	 mov	 ecx, DWORD PTR tv92[ebp]
  000d8	51		 push	 ecx
  000d9	6a fd		 push	 -3			; fffffffdH
  000db	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _gz_error
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  :             return -1;

  000e7	83 c8 ff	 or	 eax, -1
  000ea	e9 f2 00 00 00	 jmp	 $LN16@gz_decomp
$LN14@gz_decomp:

; 267  :         }
; 268  :     } while (strm->avail_out && ret != Z_STREAM_END);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000f2	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000f6	74 0a		 je	 SHORT $LN13@gz_decomp
  000f8	83 7d ec 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000fc	0f 85 16 ff ff
	ff		 jne	 $LN15@gz_decomp
$LN13@gz_decomp:

; 269  : 
; 270  :     /* update available output and crc check value */
; 271  :     state->have = had - strm->avail_out;

  00102	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00105	8b 55 f0	 mov	 edx, DWORD PTR _had$[ebp]
  00108	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0010b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0010e	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 272  :     state->next = strm->next_out - state->have;

  00111	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00114	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00117	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0011a	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00120	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 273  :     strm->adler = crc32(strm->adler, state->next, state->have);

  00123	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00126	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00129	50		 push	 eax
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0012d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00130	52		 push	 edx
  00131	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00134	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _crc32@12
  0013d	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00140	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 274  : 
; 275  :     /* check gzip trailer if at end of deflate stream */
; 276  :     if (ret == Z_STREAM_END) {

  00143	83 7d ec 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00147	0f 85 92 00 00
	00		 jne	 $LN5@gz_decomp

; 277  :         if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

  0014d	8d 45 fc	 lea	 eax, DWORD PTR _crc$[ebp]
  00150	50		 push	 eax
  00151	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 _gz_next4
  0015a	83 c4 08	 add	 esp, 8
  0015d	83 f8 ff	 cmp	 eax, -1
  00160	74 15		 je	 SHORT $LN3@gz_decomp
  00162	8d 55 f4	 lea	 edx, DWORD PTR _len$[ebp]
  00165	52		 push	 edx
  00166	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _gz_next4
  0016f	83 c4 08	 add	 esp, 8
  00172	83 f8 ff	 cmp	 eax, -1
  00175	75 18		 jne	 SHORT $LN4@gz_decomp
$LN3@gz_decomp:

; 278  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  0017c	6a fd		 push	 -3			; fffffffdH
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00181	51		 push	 ecx
  00182	e8 00 00 00 00	 call	 _gz_error
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH

; 279  :             return -1;

  0018a	83 c8 ff	 or	 eax, -1
  0018d	eb 52		 jmp	 SHORT $LN16@gz_decomp
$LN4@gz_decomp:

; 280  :         }
; 281  :         if (crc != strm->adler) {

  0018f	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00192	8b 45 fc	 mov	 eax, DWORD PTR _crc$[ebp]
  00195	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  00198	74 18		 je	 SHORT $LN2@gz_decomp

; 282  :             gz_error(state, Z_DATA_ERROR, "incorrect data check");

  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  0019f	6a fd		 push	 -3			; fffffffdH
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 _gz_error
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  :             return -1;

  001ad	83 c8 ff	 or	 eax, -1
  001b0	eb 2f		 jmp	 SHORT $LN16@gz_decomp
$LN2@gz_decomp:

; 284  :         }
; 285  :         if (len != (strm->total_out & 0xffffffffL)) {

  001b2	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  001b5	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  001b8	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  001bb	74 18		 je	 SHORT $LN1@gz_decomp

; 286  :             gz_error(state, Z_DATA_ERROR, "incorrect length check");

  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  001c2	6a fd		 push	 -3			; fffffffdH
  001c4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001c7	51		 push	 ecx
  001c8	e8 00 00 00 00	 call	 _gz_error
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 287  :             return -1;

  001d0	83 c8 ff	 or	 eax, -1
  001d3	eb 0c		 jmp	 SHORT $LN16@gz_decomp
$LN1@gz_decomp:

; 288  :         }
; 289  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

  001d5	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001d8	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$LN5@gz_decomp:

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;

  001df	33 c0		 xor	 eax, eax
$LN16@gz_decomp:

; 295  : }

  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c3		 ret	 0
_gz_decomp ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_make
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_make PROC						; COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 307  :     z_streamp strm = &(state->strm);

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 c0 54	 add	 eax, 84			; 00000054H
  0000a	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 308  : 
; 309  :     if (state->how == LOOK) {           /* look for gzip header */

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00014	75 26		 jne	 SHORT $LN8@gz_make

; 310  :         if (gz_head(state) == -1)

  00016	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 _gz_head
  0001f	83 c4 04	 add	 esp, 4
  00022	83 f8 ff	 cmp	 eax, -1
  00025	75 08		 jne	 SHORT $LN7@gz_make

; 311  :             return -1;

  00027	83 c8 ff	 or	 eax, -1
  0002a	e9 8c 00 00 00	 jmp	 $LN9@gz_make
$LN7@gz_make:

; 312  :         if (state->have)                /* got some data from gz_head() */

  0002f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00036	74 04		 je	 SHORT $LN8@gz_make

; 313  :             return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 7f		 jmp	 SHORT $LN9@gz_make
$LN8@gz_make:

; 314  :     }
; 315  :     if (state->how == COPY) {           /* straight copy */

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003f	83 79 34 01	 cmp	 DWORD PTR [ecx+52], 1
  00043	75 3b		 jne	 SHORT $LN5@gz_make

; 316  :         if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)

  00045	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00048	83 c2 24	 add	 edx, 36			; 00000024H
  0004b	52		 push	 edx
  0004c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00052	d1 e1		 shl	 ecx, 1
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00058	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0005b	50		 push	 eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _gz_load
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	75 05		 jne	 SHORT $LN4@gz_make

; 317  :             return -1;

  0006d	83 c8 ff	 or	 eax, -1
  00070	eb 49		 jmp	 SHORT $LN9@gz_make
$LN4@gz_make:

; 318  :         state->next = state->out;

  00072	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00075	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00078	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0007b	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
  0007e	eb 39		 jmp	 SHORT $LN3@gz_make
$LN5@gz_make:

; 319  :     }
; 320  :     else if (state->how == GZIP) {      /* decompress */

  00080	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00083	83 7a 34 02	 cmp	 DWORD PTR [edx+52], 2
  00087	75 30		 jne	 SHORT $LN3@gz_make

; 321  :         strm->avail_out = state->size << 1;

  00089	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0008f	d1 e1		 shl	 ecx, 1
  00091	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00094	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 322  :         strm->next_out = state->out;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0009d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a0	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 323  :         if (gz_decomp(state) == -1)

  000a3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _gz_decomp
  000ac	83 c4 04	 add	 esp, 4
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	75 05		 jne	 SHORT $LN3@gz_make

; 324  :             return -1;

  000b4	83 c8 ff	 or	 eax, -1
  000b7	eb 02		 jmp	 SHORT $LN9@gz_make
$LN3@gz_make:

; 325  :     }
; 326  :     return 0;

  000b9	33 c0		 xor	 eax, eax
$LN9@gz_make:

; 327  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_gz_make ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_skip
_TEXT	SEGMENT
tv73 = -8						; size = 4
_n$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 4
_gz_skip PROC						; COMDAT

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN7@gz_skip:

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  00006	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  0000a	0f 84 a9 00 00
	00		 je	 $LN6@gz_skip

; 338  :         /* skip over whatever is in output buffer */
; 339  :         if (state->have) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00013	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00017	74 6f		 je	 SHORT $LN5@gz_skip

; 340  :             n = GT_OFF(state->have) || (z_off64_t)state->have > len ?
; 341  :                 (unsigned)len : state->have;

  00019	b9 01 00 00 00	 mov	 ecx, 1
  0001e	85 c9		 test	 ecx, ecx
  00020	74 0c		 je	 SHORT $LN10@gz_skip
  00022	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 24 ff ff
	ff 7f		 cmp	 DWORD PTR [edx+36], 2147483647 ; 7fffffffH
  0002c	77 16		 ja	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  0002e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00031	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00034	3b 4d 0c	 cmp	 ecx, DWORD PTR _len$[ebp]
  00037	7f 0b		 jg	 SHORT $LN11@gz_skip
  00039	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0003f	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  00042	eb 06		 jmp	 SHORT $LN12@gz_skip
$LN11@gz_skip:
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00047	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN12@gz_skip:
  0004a	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  0004d	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 342  :             state->have -= n;

  00050	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00053	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00056	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  00059	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005c	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 343  :             state->next += n;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00062	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00065	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00068	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 344  :             state->pos += n;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00071	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00074	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00077	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0007a	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 345  :             len -= n;

  0007d	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00080	2b 45 fc	 sub	 eax, DWORD PTR _n$[ebp]
  00083	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  00086	eb 2c		 jmp	 SHORT $LN4@gz_skip
$LN5@gz_skip:

; 346  :         }
; 347  : 
; 348  :         /* output buffer empty -- return if we're at the end of the input */
; 349  :         else if (state->eof && state->strm.avail_in == 0)

  00088	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008b	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0008f	74 0d		 je	 SHORT $LN3@gz_skip
  00091	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00094	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00098	75 04		 jne	 SHORT $LN3@gz_skip

; 350  :             break;

  0009a	eb 1d		 jmp	 SHORT $LN6@gz_skip

; 351  : 
; 352  :         /* need more data to skip -- load up output buffer */
; 353  :         else {

  0009c	eb 16		 jmp	 SHORT $LN4@gz_skip
$LN3@gz_skip:

; 354  :             /* get more output, looking for header if required */
; 355  :             if (gz_make(state) == -1)

  0009e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _gz_make
  000a7	83 c4 04	 add	 esp, 4
  000aa	83 f8 ff	 cmp	 eax, -1
  000ad	75 05		 jne	 SHORT $LN4@gz_skip

; 356  :                 return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 07		 jmp	 SHORT $LN8@gz_skip
$LN4@gz_skip:

; 357  :         }

  000b4	e9 4d ff ff ff	 jmp	 $LN7@gz_skip
$LN6@gz_skip:

; 358  :     return 0;

  000b9	33 c0		 xor	 eax, eax
$LN8@gz_skip:

; 359  : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_gz_skip ENDP
PUBLIC	_gzgets@12
; Function compile flags: /Odtp
;	COMDAT _gzgets@12
_TEXT	SEGMENT
tv91 = -24						; size = 4
_str$ = -20						; size = 4
_state$ = -16						; size = 4
_left$ = -12						; size = 4
_n$ = -8						; size = 4
_eol$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 544  :     unsigned left, n;
; 545  :     char *str;
; 546  :     unsigned char *eol;
; 547  :     gz_statep state;
; 548  : 
; 549  :     /* check parameters and get internal structure */
; 550  :     if (file == NULL || buf == NULL || len < 1)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	74 0c		 je	 SHORT $LN15@gzgets
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00010	74 06		 je	 SHORT $LN15@gzgets
  00012	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  00016	7d 07		 jge	 SHORT $LN16@gzgets
$LN15@gzgets:

; 551  :         return NULL;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 65 01 00 00	 jmp	 $LN17@gzgets
$LN16@gzgets:

; 552  :     state = (gz_statep)file;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00022	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 553  : 
; 554  :     /* check that we're reading and that there's no error */
; 555  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00025	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  0002e	75 09		 jne	 SHORT $LN13@gzgets
  00030	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00033	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00037	74 07		 je	 SHORT $LN14@gzgets
$LN13@gzgets:

; 556  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 44 01 00 00	 jmp	 $LN17@gzgets
$LN14@gzgets:

; 557  : 
; 558  :     /* process a skip request */
; 559  :     if (state->seek) {

  00040	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00043	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00047	74 29		 je	 SHORT $LN12@gzgets

; 560  :         state->seek = 0;

  00049	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 561  :         if (gz_skip(state, state->skip) == -1)

  00053	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00056	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _gz_skip
  00063	83 c4 08	 add	 esp, 8
  00066	83 f8 ff	 cmp	 eax, -1
  00069	75 07		 jne	 SHORT $LN12@gzgets

; 562  :             return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 12 01 00 00	 jmp	 $LN17@gzgets
$LN12@gzgets:

; 563  :     }
; 564  : 
; 565  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 566  :        append a terminating zero to the string (we don't check for a zero in
; 567  :        the contents, let the user worry about that) */
; 568  :     str = buf;

  00072	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00075	89 55 ec	 mov	 DWORD PTR _str$[ebp], edx

; 569  :     left = (unsigned)len - 1;

  00078	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0007b	83 e8 01	 sub	 eax, 1
  0007e	89 45 f4	 mov	 DWORD PTR _left$[ebp], eax

; 570  :     if (left) do {

  00081	0f 84 f4 00 00
	00		 je	 $LN10@gzgets
$LN9@gzgets:

; 571  :         /* assure that something is in the output buffer */
; 572  :         if (state->have == 0) {

  00087	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0008e	75 35		 jne	 SHORT $LN6@gzgets

; 573  :             if (gz_make(state) == -1)

  00090	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _gz_make
  00099	83 c4 04	 add	 esp, 4
  0009c	83 f8 ff	 cmp	 eax, -1
  0009f	75 07		 jne	 SHORT $LN5@gzgets

; 574  :                 return NULL;            /* error */

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 dc 00 00 00	 jmp	 $LN17@gzgets
$LN5@gzgets:

; 575  :             if (state->have == 0) {     /* end of file */

  000a8	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ab	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  000af	75 14		 jne	 SHORT $LN6@gzgets

; 576  :                 if (buf == str)         /* got bupkus */

  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000b4	3b 4d ec	 cmp	 ecx, DWORD PTR _str$[ebp]
  000b7	75 07		 jne	 SHORT $LN3@gzgets

; 577  :                     return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	e9 c4 00 00 00	 jmp	 $LN17@gzgets
$LN3@gzgets:

; 578  :                 break;                  /* got something -- return it */

  000c0	e9 b6 00 00 00	 jmp	 $LN10@gzgets
$LN6@gzgets:

; 579  :             }
; 580  :         }
; 581  : 
; 582  :         /* look for end-of-line in current output buffer */
; 583  :         n = state->have > left ? left : state->have;

  000c5	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000cb	3b 45 f4	 cmp	 eax, DWORD PTR _left$[ebp]
  000ce	76 08		 jbe	 SHORT $LN19@gzgets
  000d0	8b 4d f4	 mov	 ecx, DWORD PTR _left$[ebp]
  000d3	89 4d e8	 mov	 DWORD PTR tv91[ebp], ecx
  000d6	eb 09		 jmp	 SHORT $LN20@gzgets
$LN19@gzgets:
  000d8	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000db	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000de	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
$LN20@gzgets:
  000e1	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000e4	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 584  :         eol = memchr(state->next, '\n', n);

  000e7	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  000ea	52		 push	 edx
  000eb	6a 0a		 push	 10			; 0000000aH
  000ed	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000f0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000f3	51		 push	 ecx
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	89 45 fc	 mov	 DWORD PTR _eol$[ebp], eax

; 585  :         if (eol != NULL)

  00100	83 7d fc 00	 cmp	 DWORD PTR _eol$[ebp], 0
  00104	74 0f		 je	 SHORT $LN2@gzgets

; 586  :             n = (unsigned)(eol - state->next) + 1;

  00106	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00109	8b 45 fc	 mov	 eax, DWORD PTR _eol$[ebp]
  0010c	2b 42 20	 sub	 eax, DWORD PTR [edx+32]
  0010f	83 c0 01	 add	 eax, 1
  00112	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN2@gzgets:

; 587  : 
; 588  :         /* copy through end-of-line, or remainder if not found */
; 589  :         memcpy(buf, state->next, n);

  00115	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0011c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0011f	50		 push	 eax
  00120	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 _memcpy
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  :         state->have -= n;

  0012c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0012f	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00132	2b 45 f8	 sub	 eax, DWORD PTR _n$[ebp]
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00138	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 591  :         state->next += n;

  0013b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0013e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00141	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00144	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00147	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 592  :         state->pos += n;

  0014a	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0014d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00150	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00153	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00156	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 593  :         left -= n;

  00159	8b 55 f4	 mov	 edx, DWORD PTR _left$[ebp]
  0015c	2b 55 f8	 sub	 edx, DWORD PTR _n$[ebp]
  0015f	89 55 f4	 mov	 DWORD PTR _left$[ebp], edx

; 594  :         buf += n;

  00162	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00165	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00168	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 595  :     } while (left && eol == NULL);

  0016b	83 7d f4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0016f	74 0a		 je	 SHORT $LN10@gzgets
  00171	83 7d fc 00	 cmp	 DWORD PTR _eol$[ebp], 0
  00175	0f 84 0c ff ff
	ff		 je	 $LN9@gzgets
$LN10@gzgets:

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  0017b	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0017e	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 599  :     return str;

  00181	8b 45 ec	 mov	 eax, DWORD PTR _str$[ebp]
$LN17@gzgets:

; 600  : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
PUBLIC	_gzungetc@8
; Function compile flags: /Odtp
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_src$79709 = -12					; size = 4
_dest$79710 = -8					; size = 4
_state$ = -4						; size = 4
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure */
; 489  :     if (file == NULL)

  00006	83 7d 0c 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN11@gzungetc

; 490  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 75 01 00 00	 jmp	 $LN12@gzungetc
$LN11@gzungetc:

; 491  :     state = (gz_statep)file;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 492  : 
; 493  :     /* check that we're reading and that there's no error */
; 494  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00023	75 09		 jne	 SHORT $LN9@gzungetc
  00025	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00028	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  0002c	74 08		 je	 SHORT $LN10@gzungetc
$LN9@gzungetc:

; 495  :         return -1;

  0002e	83 c8 ff	 or	 eax, -1
  00031	e9 53 01 00 00	 jmp	 $LN12@gzungetc
$LN10@gzungetc:

; 496  : 
; 497  :     /* process a skip request */
; 498  :     if (state->seek) {

  00036	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00039	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0003d	74 2a		 je	 SHORT $LN8@gzungetc

; 499  :         state->seek = 0;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 500  :         if (gz_skip(state, state->skip) == -1)

  00049	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _gz_skip
  00059	83 c4 08	 add	 esp, 8
  0005c	83 f8 ff	 cmp	 eax, -1
  0005f	75 08		 jne	 SHORT $LN8@gzungetc

; 501  :             return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	e9 20 01 00 00	 jmp	 $LN12@gzungetc
$LN8@gzungetc:

; 502  :     }
; 503  : 
; 504  :     /* can't push EOF */
; 505  :     if (c < 0)

  00069	83 7d 08 00	 cmp	 DWORD PTR _c$[ebp], 0
  0006d	7d 08		 jge	 SHORT $LN6@gzungetc

; 506  :         return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 12 01 00 00	 jmp	 $LN12@gzungetc
$LN6@gzungetc:

; 507  : 
; 508  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 509  :     if (state->have == 0) {

  00077	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0007a	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0007e	75 42		 jne	 SHORT $LN5@gzungetc

; 510  :         state->have = 1;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00083	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [eax+36], 1

; 511  :         state->next = state->out + (state->size << 1) - 1;

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00090	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00093	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00096	8d 54 51 ff	 lea	 edx, DWORD PTR [ecx+edx*2-1]
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 512  :         state->next[0] = c;

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000a3	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000a6	8a 45 08	 mov	 al, BYTE PTR _c$[ebp]
  000a9	88 02		 mov	 BYTE PTR [edx], al

; 513  :         state->pos--;

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000ae	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b1	83 ea 01	 sub	 edx, 1
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000b7	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 514  :         return c;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000bd	e9 c7 00 00 00	 jmp	 $LN12@gzungetc
$LN5@gzungetc:

; 515  :     }
; 516  : 
; 517  :     /* if no room, give up (must have already done a gzungetc()) */
; 518  :     if (state->have == (state->size << 1)) {

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c8	d1 e2		 shl	 edx, 1
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000cd	39 50 24	 cmp	 DWORD PTR [eax+36], edx
  000d0	75 1b		 jne	 SHORT $LN4@gzungetc

; 519  :         gz_error(state, Z_BUF_ERROR, "out of room to push characters");

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  000d7	6a fb		 push	 -5			; fffffffbH
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _gz_error
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 520  :         return -1;

  000e5	83 c8 ff	 or	 eax, -1
  000e8	e9 9c 00 00 00	 jmp	 $LN12@gzungetc
$LN4@gzungetc:

; 521  :     }
; 522  : 
; 523  :     /* slide output data if needed and insert byte before existing data */
; 524  :     if (state->next == state->out) {

  000ed	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f3	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  000f6	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  000f9	75 53		 jne	 SHORT $LN3@gzungetc

; 525  :         unsigned char *src = state->out + state->have;

  000fb	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000fe	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00104	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00107	89 45 f4	 mov	 DWORD PTR _src$79709[ebp], eax

; 526  :         unsigned char *dest = state->out + (state->size << 1);

  0010a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0010d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00110	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00113	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00116	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00119	89 45 f8	 mov	 DWORD PTR _dest$79710[ebp], eax
$LN2@gzungetc:

; 527  :         while (src > state->out)

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0011f	8b 55 f4	 mov	 edx, DWORD PTR _src$79709[ebp]
  00122	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00125	76 1e		 jbe	 SHORT $LN1@gzungetc

; 528  :             *--dest = *--src;

  00127	8b 45 f4	 mov	 eax, DWORD PTR _src$79709[ebp]
  0012a	83 e8 01	 sub	 eax, 1
  0012d	89 45 f4	 mov	 DWORD PTR _src$79709[ebp], eax
  00130	8b 4d f8	 mov	 ecx, DWORD PTR _dest$79710[ebp]
  00133	83 e9 01	 sub	 ecx, 1
  00136	89 4d f8	 mov	 DWORD PTR _dest$79710[ebp], ecx
  00139	8b 55 f8	 mov	 edx, DWORD PTR _dest$79710[ebp]
  0013c	8b 45 f4	 mov	 eax, DWORD PTR _src$79709[ebp]
  0013f	8a 08		 mov	 cl, BYTE PTR [eax]
  00141	88 0a		 mov	 BYTE PTR [edx], cl
  00143	eb d7		 jmp	 SHORT $LN2@gzungetc
$LN1@gzungetc:

; 529  :         state->next = dest;

  00145	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00148	8b 45 f8	 mov	 eax, DWORD PTR _dest$79710[ebp]
  0014b	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN3@gzungetc:

; 530  :     }
; 531  :     state->have++;

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00151	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00154	83 c2 01	 add	 edx, 1
  00157	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0015a	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 532  :     state->next--;

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00160	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00163	83 ea 01	 sub	 edx, 1
  00166	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00169	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 533  :     state->next[0] = c;

  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0016f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00172	8a 45 08	 mov	 al, BYTE PTR _c$[ebp]
  00175	88 02		 mov	 BYTE PTR [edx], al

; 534  :     state->pos--;

  00177	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0017a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0017d	83 ea 01	 sub	 edx, 1
  00180	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00183	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 535  :     return c;

  00186	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
$LN12@gzungetc:

; 536  : }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c2 08 00	 ret	 8
_gzungetc@8 ENDP
_TEXT	ENDS
PUBLIC	_gzread@12
; Function compile flags: /Odtp
;	COMDAT _gzread@12
_TEXT	SEGMENT
tv87 = -20						; size = 4
_state$ = -16						; size = 4
_got$ = -12						; size = 4
_strm$ = -8						; size = 4
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 367  :     unsigned got, n;
; 368  :     gz_statep state;
; 369  :     z_streamp strm;
; 370  : 
; 371  :     /* get internal structure */
; 372  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN22@gzread

; 373  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 e9 01 00 00	 jmp	 $LN23@gzread
$LN22@gzread:

; 374  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 375  :     strm = &(state->strm);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 54	 add	 ecx, 84			; 00000054H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 376  : 
; 377  :     /* check that we're reading and that there's no error */
; 378  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00023	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [edx], 7247	; 00001c4fH
  0002c	75 09		 jne	 SHORT $LN20@gzread
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00031	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00035	74 08		 je	 SHORT $LN21@gzread
$LN20@gzread:

; 379  :         return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	e9 be 01 00 00	 jmp	 $LN23@gzread
$LN21@gzread:

; 380  : 
; 381  :     /* since an int is returned, make sure len fits in one, otherwise return
; 382  :        with an error (this avoids the flaw in the interface) */
; 383  :     if ((int)len < 0) {

  0003f	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00043	7d 1b		 jge	 SHORT $LN19@gzread

; 384  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0004a	6a fb		 push	 -5			; fffffffbH
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _gz_error
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 385  :         return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	e9 9d 01 00 00	 jmp	 $LN23@gzread
$LN19@gzread:

; 386  :     }
; 387  : 
; 388  :     /* if len is zero, avoid unnecessary operations */
; 389  :     if (len == 0)

  00060	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00064	75 07		 jne	 SHORT $LN18@gzread

; 390  :         return 0;

  00066	33 c0		 xor	 eax, eax
  00068	e9 90 01 00 00	 jmp	 $LN23@gzread
$LN18@gzread:

; 391  : 
; 392  :     /* process a skip request */
; 393  :     if (state->seek) {

  0006d	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00070	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  00074	74 2a		 je	 SHORT $LN17@gzread

; 394  :         state->seek = 0;

  00076	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00079	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 395  :         if (gz_skip(state, state->skip) == -1)

  00080	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00086	52		 push	 edx
  00087	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _gz_skip
  00090	83 c4 08	 add	 esp, 8
  00093	83 f8 ff	 cmp	 eax, -1
  00096	75 08		 jne	 SHORT $LN17@gzread

; 396  :             return -1;

  00098	83 c8 ff	 or	 eax, -1
  0009b	e9 5d 01 00 00	 jmp	 $LN23@gzread
$LN17@gzread:

; 397  :     }
; 398  : 
; 399  :     /* get len bytes to buf, or less than len if at the end */
; 400  :     got = 0;

  000a0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0
$LN15@gzread:

; 401  :     do {
; 402  :         /* first just try copying data from the output buffer */
; 403  :         if (state->have) {

  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000aa	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000ae	74 5c		 je	 SHORT $LN12@gzread

; 404  :             n = state->have > len ? len : state->have;

  000b0	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000b3	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b6	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  000b9	76 08		 jbe	 SHORT $LN25@gzread
  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  000be	89 4d ec	 mov	 DWORD PTR tv87[ebp], ecx
  000c1	eb 09		 jmp	 SHORT $LN26@gzread
$LN25@gzread:
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000c6	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000c9	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
$LN26@gzread:
  000cc	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000cf	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx

; 405  :             memcpy(buf, state->next, n);

  000d2	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000dc	51		 push	 ecx
  000dd	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _memcpy
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 406  :             state->next += n;

  000e9	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ec	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000ef	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  000f2	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000f5	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 407  :             state->have -= n;

  000f8	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000fb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000fe	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  00101	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00104	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
  00107	e9 ba 00 00 00	 jmp	 $LN11@gzread
$LN12@gzread:

; 408  :         }
; 409  : 
; 410  :         /* output buffer empty -- return if we're at the end of the input */
; 411  :         else if (state->eof && strm->avail_in == 0)

  0010c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0010f	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00113	74 13		 je	 SHORT $LN10@gzread
  00115	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00118	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0011c	75 0a		 jne	 SHORT $LN10@gzread
  0011e	e9 d7 00 00 00	 jmp	 $LN13@gzread

; 412  :             break;

  00123	e9 9e 00 00 00	 jmp	 $LN11@gzread
$LN10@gzread:

; 413  : 
; 414  :         /* need output data -- for small len or new stream load up our output
; 415  :            buffer */
; 416  :         else if (state->how == LOOK || len < (state->size << 1)) {

  00128	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0012b	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  0012f	74 0d		 je	 SHORT $LN7@gzread
  00131	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00134	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00137	d1 e1		 shl	 ecx, 1
  00139	39 4d 10	 cmp	 DWORD PTR _len$[ebp], ecx
  0013c	73 20		 jae	 SHORT $LN8@gzread
$LN7@gzread:

; 417  :             /* get more output, looking for header if required */
; 418  :             if (gz_make(state) == -1)

  0013e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 _gz_make
  00147	83 c4 04	 add	 esp, 4
  0014a	83 f8 ff	 cmp	 eax, -1
  0014d	75 08		 jne	 SHORT $LN6@gzread

; 419  :                 return -1;

  0014f	83 c8 ff	 or	 eax, -1
  00152	e9 a6 00 00 00	 jmp	 $LN23@gzread
$LN6@gzread:

; 420  :             continue;       /* no progress yet -- go back to memcpy() above */

  00157	e9 94 00 00 00	 jmp	 $LN14@gzread
  0015c	eb 68		 jmp	 SHORT $LN11@gzread
$LN8@gzread:

; 421  :             /* the copy above assures that we will leave with space in the
; 422  :                output buffer, allowing at least one gzungetc() to succeed */
; 423  :         }
; 424  : 
; 425  :         /* large len -- read directly into user buffer */
; 426  :         else if (state->how == COPY) {      /* read directly */

  0015e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00161	83 78 34 01	 cmp	 DWORD PTR [eax+52], 1
  00165	75 24		 jne	 SHORT $LN4@gzread

; 427  :             if (gz_load(state, buf, len, &n) == -1)

  00167	8d 4d fc	 lea	 ecx, DWORD PTR _n$[ebp]
  0016a	51		 push	 ecx
  0016b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00172	50		 push	 eax
  00173	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _gz_load
  0017c	83 c4 10	 add	 esp, 16			; 00000010H
  0017f	83 f8 ff	 cmp	 eax, -1
  00182	75 05		 jne	 SHORT $LN3@gzread

; 428  :                 return -1;

  00184	83 c8 ff	 or	 eax, -1
  00187	eb 74		 jmp	 SHORT $LN23@gzread
$LN3@gzread:

; 429  :         }
; 430  : 
; 431  :         /* large len -- decompress directly into user buffer */
; 432  :         else {  /* state->how == GZIP */

  00189	eb 3b		 jmp	 SHORT $LN11@gzread
$LN4@gzread:

; 433  :             strm->avail_out = len;

  0018b	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0018e	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00191	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 434  :             strm->next_out = buf;

  00194	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00197	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0019a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 435  :             if (gz_decomp(state) == -1)

  0019d	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _gz_decomp
  001a6	83 c4 04	 add	 esp, 4
  001a9	83 f8 ff	 cmp	 eax, -1
  001ac	75 05		 jne	 SHORT $LN1@gzread

; 436  :                 return -1;

  001ae	83 c8 ff	 or	 eax, -1
  001b1	eb 4a		 jmp	 SHORT $LN23@gzread
$LN1@gzread:

; 437  :             n = state->have;

  001b3	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001b6	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001b9	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 438  :             state->have = 0;

  001bc	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001bf	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN11@gzread:

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;

  001c6	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001c9	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  001cc	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 443  :         buf = (char *)buf + n;

  001cf	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  001d2	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  001d5	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 444  :         got += n;

  001d8	8b 45 f4	 mov	 eax, DWORD PTR _got$[ebp]
  001db	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001de	89 45 f4	 mov	 DWORD PTR _got$[ebp], eax

; 445  :         state->pos += n;

  001e1	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001e4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001e7	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  001ea	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001ed	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN14@gzread:

; 446  :     } while (len);

  001f0	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  001f4	0f 85 ad fe ff
	ff		 jne	 $LN15@gzread
$LN13@gzread:

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;

  001fa	8b 45 f4	 mov	 eax, DWORD PTR _got$[ebp]
$LN23@gzread:

; 450  : }

  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
_TEXT	ENDS
PUBLIC	_gzgetc@4
; Function compile flags: /Odtp
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
tv91 = -20						; size = 4
tv83 = -13						; size = 1
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_buf$ = -1						; size = 1
_file$ = 8						; size = 4
_gzgetc@4 PROC						; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 456  :     int ret;
; 457  :     unsigned char buf[1];
; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure */
; 461  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN4@gzgetc

; 462  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 91 00 00 00	 jmp	 $LN5@gzgetc
$LN4@gzgetc:

; 463  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 464  : 
; 465  :     /* check that we're reading and that there's no error */
; 466  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [ecx], 7247	; 00001c4fH
  00023	75 09		 jne	 SHORT $LN2@gzgetc
  00025	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00028	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  0002c	74 05		 je	 SHORT $LN3@gzgetc
$LN2@gzgetc:

; 467  :         return -1;

  0002e	83 c8 ff	 or	 eax, -1
  00031	eb 72		 jmp	 SHORT $LN5@gzgetc
$LN3@gzgetc:

; 468  : 
; 469  :     /* try output buffer (no need to check for skip request) */
; 470  :     if (state->have) {

  00033	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00036	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0003a	74 3e		 je	 SHORT $LN1@gzgetc

; 471  :         state->have--;

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0003f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00042	83 ea 01	 sub	 edx, 1
  00045	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00048	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 472  :         state->pos++;

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0004e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00051	83 c2 01	 add	 edx, 1
  00054	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00057	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 473  :         return *(state->next)++;

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00060	8a 02		 mov	 al, BYTE PTR [edx]
  00062	88 45 f3	 mov	 BYTE PTR tv83[ebp], al
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00068	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0006b	83 c2 01	 add	 edx, 1
  0006e	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00071	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00074	0f b6 45 f3	 movzx	 eax, BYTE PTR tv83[ebp]
  00078	eb 2b		 jmp	 SHORT $LN5@gzgetc
$LN1@gzgetc:

; 474  :     }
; 475  : 
; 476  :     /* nothing there -- try gzread() */
; 477  :     ret = gzread(file, buf, 1);

  0007a	6a 01		 push	 1
  0007c	8d 4d ff	 lea	 ecx, DWORD PTR _buf$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _gzread@12
  00089	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 478  :     return ret < 1 ? -1 : buf[0];

  0008c	83 7d f8 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00090	7d 09		 jge	 SHORT $LN7@gzgetc
  00092	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv91[ebp], -1
  00099	eb 07		 jmp	 SHORT $LN8@gzgetc
$LN7@gzgetc:
  0009b	0f b6 45 ff	 movzx	 eax, BYTE PTR _buf$[ebp]
  0009f	89 45 ec	 mov	 DWORD PTR tv91[ebp], eax
$LN8@gzgetc:
  000a2	8b 45 ec	 mov	 eax, DWORD PTR tv91[ebp]
$LN5@gzgetc:

; 479  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
_gzgetc@4 ENDP
_TEXT	ENDS
END
