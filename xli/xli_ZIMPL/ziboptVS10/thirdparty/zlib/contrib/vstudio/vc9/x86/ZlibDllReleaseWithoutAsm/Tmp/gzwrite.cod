; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\lp_solve_5.5\xli\xli_ZIMPL\ziboptVS10\thirdparty\zlib\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	__imp___vsnprintf:PROC
EXTRN	__imp__write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Odtp
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 54	 add	 eax, 84			; 00000054H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 20   : 
; 21   :     /* allocate input and output buffers */
; 22   :     state->in = malloc(state->want);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00015	52		 push	 edx
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 23   :     state->out = malloc(state->want);

  00025	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00028	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00038	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 24   :     if (state->in == NULL || state->out == NULL) {

  0003b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00042	74 09		 je	 SHORT $LN4@gz_init
  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0004b	75 4d		 jne	 SHORT $LN5@gz_init
$LN4@gz_init:

; 25   :         if (state->out != NULL)

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00054	74 10		 je	 SHORT $LN3@gz_init

; 26   :             free(state->out);

  00056	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00059	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00063	83 c4 04	 add	 esp, 4
$LN3@gz_init:

; 27   :         if (state->in != NULL)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00069	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0006d	74 10		 je	 SHORT $LN2@gz_init

; 28   :             free(state->in);

  0006f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00072	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0007c	83 c4 04	 add	 esp, 4
$LN2@gz_init:

; 29   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00084	6a fc		 push	 -4			; fffffffcH
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _gz_error
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30   :         return -1;

  00092	83 c8 ff	 or	 eax, -1
  00095	e9 a5 00 00 00	 jmp	 $LN6@gz_init
$LN5@gz_init:

; 31   :     }
; 32   : 
; 33   :     /* allocate deflate memory, set up for gzip compression */
; 34   :     strm->zalloc = Z_NULL;

  0009a	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0009d	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 35   :     strm->zfree = Z_NULL;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a7	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 36   :     strm->opaque = Z_NULL;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b1	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 37   :     ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 38   :                        15 + 16, 8, state->strategy);

  000b8	6a 38		 push	 56			; 00000038H
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45?$AA@
  000bf	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c2	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000c5	50		 push	 eax
  000c6	6a 08		 push	 8
  000c8	6a 1f		 push	 31			; 0000001fH
  000ca	6a 08		 push	 8
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  000d2	52		 push	 edx
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _deflateInit2_@32
  000dc	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 39   :     if (ret != Z_OK) {

  000df	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000e3	74 28		 je	 SHORT $LN1@gz_init

; 40   :         free(state->in);

  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000eb	52		 push	 edx
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f2	83 c4 04	 add	 esp, 4

; 41   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000fa	6a fc		 push	 -4			; fffffffcH
  000fc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _gz_error
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   :         return -1;

  00108	83 c8 ff	 or	 eax, -1
  0010b	eb 32		 jmp	 SHORT $LN6@gz_init
$LN1@gz_init:

; 43   :     }
; 44   : 
; 45   :     /* mark state as initialized */
; 46   :     state->size = state->want;

  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00110	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00113	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00116	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 47   : 
; 48   :     /* initialize write buffer */
; 49   :     strm->avail_out = state->size;

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0011c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0011f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00122	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 50   :     strm->next_out = state->out;

  00125	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00128	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0012b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0012e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 51   :     state->next = strm->next_out;

  00131	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00134	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00137	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0013a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 52   :     return 0;

  0013d	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 53   : }

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_got$ = -16						; size = 4
_ret$ = -12						; size = 4
_strm$ = -8						; size = 4
_have$ = -4						; size = 4
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 54	 add	 eax, 84			; 00000054H
  0000c	89 45 f8	 mov	 DWORD PTR _strm$[ebp], eax

; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00016	75 19		 jne	 SHORT $LN12@gz_comp
  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _gz_init
  00021	83 c4 04	 add	 esp, 4
  00024	83 f8 ff	 cmp	 eax, -1
  00027	75 08		 jne	 SHORT $LN12@gz_comp

; 69   :         return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	e9 17 01 00 00	 jmp	 $LN13@gz_comp
$LN12@gz_comp:

; 70   : 
; 71   :     /* run deflate() on provided input until it produces no more output */
; 72   :     ret = Z_OK;

  00031	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN11@gz_comp:

; 73   :     do {
; 74   :         /* write out current buffer contents if full, or if flushing, but if
; 75   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 76   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 77   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00038	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  0003b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0003f	74 1a		 je	 SHORT $LN7@gz_comp
  00041	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00045	0f 84 a3 00 00
	00		 je	 $LN8@gz_comp
  0004b	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0004f	75 0a		 jne	 SHORT $LN7@gz_comp
  00051	83 7d f4 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00055	0f 85 93 00 00
	00		 jne	 $LN8@gz_comp
$LN7@gz_comp:

; 78   :             have = (unsigned)(strm->next_out - state->next);

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00061	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00064	2b 42 20	 sub	 eax, DWORD PTR [edx+32]
  00067	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 79   :             if (have && ((got = write(state->fd, state->next, have)) < 0 ||
; 80   :                          (unsigned)got != have)) {

  0006a	74 55		 je	 SHORT $LN5@gz_comp
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  0006f	51		 push	 ecx
  00070	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00073	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00076	50		 push	 eax
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__write
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	89 45 f0	 mov	 DWORD PTR _got$[ebp], eax
  0008a	83 7d f0 00	 cmp	 DWORD PTR _got$[ebp], 0
  0008e	7c 08		 jl	 SHORT $LN4@gz_comp
  00090	8b 45 f0	 mov	 eax, DWORD PTR _got$[ebp]
  00093	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  00096	74 29		 je	 SHORT $LN5@gz_comp
$LN4@gz_comp:

; 81   :                 gz_error(state, Z_ERRNO, zstrerror());

  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	51		 push	 ecx
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  000a7	83 c4 04	 add	 esp, 4
  000aa	50		 push	 eax
  000ab	6a ff		 push	 -1
  000ad	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 _gz_error
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :                 return -1;

  000b9	83 c8 ff	 or	 eax, -1
  000bc	e9 87 00 00 00	 jmp	 $LN13@gz_comp
$LN5@gz_comp:

; 83   :             }
; 84   :             if (strm->avail_out == 0) {

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000c4	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000c8	75 18		 jne	 SHORT $LN3@gz_comp

; 85   :                 strm->avail_out = state->size;

  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000cd	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d3	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 86   :                 strm->next_out = state->out;

  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d9	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000dc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000df	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@gz_comp:

; 87   :             }
; 88   :             state->next = strm->next_out;

  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e5	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  000e8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000eb	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN8@gz_comp:

; 89   :         }
; 90   : 
; 91   :         /* compress */
; 92   :         have = strm->avail_out;

  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000f4	89 55 fc	 mov	 DWORD PTR _have$[ebp], edx

; 93   :         ret = deflate(strm, flush);

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _deflate@8
  00104	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 94   :         if (ret == Z_STREAM_ERROR) {

  00107	83 7d f4 fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  0010b	75 18		 jne	 SHORT $LN2@gz_comp

; 95   :             gz_error(state, Z_STREAM_ERROR,
; 96   :                       "internal error: deflate stream corrupt");

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00112	6a fe		 push	 -2			; fffffffeH
  00114	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _gz_error
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   :             return -1;

  00120	83 c8 ff	 or	 eax, -1
  00123	eb 23		 jmp	 SHORT $LN13@gz_comp
$LN2@gz_comp:

; 98   :         }
; 99   :         have -= strm->avail_out;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00128	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  0012b	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0012e	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 100  :     } while (have);

  00131	0f 85 01 ff ff
	ff		 jne	 $LN11@gz_comp

; 101  : 
; 102  :     /* if that completed a deflate stream, allow another to start */
; 103  :     if (flush == Z_FINISH)

  00137	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0013b	75 09		 jne	 SHORT $LN1@gz_comp

; 104  :         deflateReset(strm);

  0013d	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00140	52		 push	 edx
  00141	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 105  : 
; 106  :     /* all done, no errors */
; 107  :     return 0;

  00146	33 c0		 xor	 eax, eax
$LN13@gz_comp:

; 108  : }

  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
tv78 = -16						; size = 4
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_first$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 4
_gz_zero PROC						; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 115  :     int first;
; 116  :     unsigned n;
; 117  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 54	 add	 eax, 84			; 00000054H
  0000c	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 118  : 
; 119  :     /* consume whatever's left in the input buffer */
; 120  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	74 1b		 je	 SHORT $LN5@gz_zero
  00018	6a 00		 push	 0
  0001a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _gz_comp
  00023	83 c4 08	 add	 esp, 8
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 08		 jne	 SHORT $LN5@gz_zero

; 121  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	e9 b5 00 00 00	 jmp	 $LN6@gz_zero
$LN5@gz_zero:

; 122  : 
; 123  :     /* compress len zeros (len guaranteed > 0) */
; 124  :     first = 1;

  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
$LN4@gz_zero:

; 125  :     while (len) {

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  0003e	0f 84 a2 00 00
	00		 je	 $LN3@gz_zero

; 126  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 127  :             (unsigned)len : state->size;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	74 0c		 je	 SHORT $LN8@gz_zero
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	81 79 10 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+16], 2147483647 ; 7fffffffH
  00057	77 16		 ja	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00059	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005f	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00062	7f 0b		 jg	 SHORT $LN9@gz_zero
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006a	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  0006d	eb 06		 jmp	 SHORT $LN10@gz_zero
$LN9@gz_zero:
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00072	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
$LN10@gz_zero:
  00075	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  00078	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 128  :         if (first) {

  0007b	83 7d fc 00	 cmp	 DWORD PTR _first$[ebp], 0
  0007f	74 1c		 je	 SHORT $LN2@gz_zero

; 129  :             memset(state->in, 0, n);

  00081	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00084	52		 push	 edx
  00085	6a 00		 push	 0
  00087	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  :             first = 0;

  00096	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
$LN2@gz_zero:

; 131  :         }
; 132  :         strm->avail_in = n;

  0009d	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a3	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 133  :         strm->next_in = state->in;

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a9	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ac	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000af	89 01		 mov	 DWORD PTR [ecx], eax

; 134  :         state->pos += n;

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000b4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b7	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  000ba	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 135  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000c0	6a 00		 push	 0
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _gz_comp
  000cb	83 c4 08	 add	 esp, 8
  000ce	83 f8 ff	 cmp	 eax, -1
  000d1	75 05		 jne	 SHORT $LN1@gz_zero

; 136  :             return -1;

  000d3	83 c8 ff	 or	 eax, -1
  000d6	eb 10		 jmp	 SHORT $LN6@gz_zero
$LN1@gz_zero:

; 137  :         len -= n;

  000d8	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  000db	2b 55 f8	 sub	 edx, DWORD PTR _n$[ebp]
  000de	89 55 0c	 mov	 DWORD PTR _len$[ebp], edx

; 138  :     }

  000e1	e9 54 ff ff ff	 jmp	 $LN4@gz_zero
$LN3@gz_zero:

; 139  :     return 0;

  000e6	33 c0		 xor	 eax, eax
$LN6@gz_zero:

; 140  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Odtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 503  :     int ret = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure */
; 507  :     if (file == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00011	75 0a		 jne	 SHORT $LN3@gzclose_w

; 508  :         return Z_STREAM_ERROR;

  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 d1 00 00 00	 jmp	 $LN4@gzclose_w
$LN3@gzclose_w:

; 509  :     state = (gz_statep)file;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 510  : 
; 511  :     /* check that we're writing */
; 512  :     if (state->mode != GZ_WRITE)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	81 39 b1 79 00
	00		 cmp	 DWORD PTR [ecx], 31153	; 000079b1H
  0002c	74 0a		 je	 SHORT $LN2@gzclose_w

; 513  :         return Z_STREAM_ERROR;

  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	e9 b6 00 00 00	 jmp	 $LN4@gzclose_w
$LN2@gzclose_w:

; 514  : 
; 515  :     /* check for seek request */
; 516  :     if (state->seek) {

  00038	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0003b	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  0003f	74 23		 je	 SHORT $LN1@gzclose_w

; 517  :         state->seek = 0;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00044	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 518  :         ret += gz_zero(state, state->skip);

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0004e	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00051	52		 push	 edx
  00052	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _gz_zero
  0005b	83 c4 08	 add	 esp, 8
  0005e	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  00061	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN1@gzclose_w:

; 519  :     }
; 520  : 
; 521  :     /* flush, free memory, and close file */
; 522  :     ret += gz_comp(state, Z_FINISH);

  00064	6a 04		 push	 4
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _gz_comp
  0006f	83 c4 08	 add	 esp, 8
  00072	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  00075	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 523  :     (void)deflateEnd(&(state->strm));

  00078	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0007b	83 c2 54	 add	 edx, 84			; 00000054H
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _deflateEnd@4

; 524  :     free(state->out);

  00084	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00087	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00091	83 c4 04	 add	 esp, 4

; 525  :     free(state->in);

  00094	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00097	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000a1	83 c4 04	 add	 esp, 4

; 526  :     gz_error(state, Z_OK, NULL);

  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _gz_error
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 527  :     free(state->path);

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c1	83 c4 04	 add	 esp, 4

; 528  :     ret += close(state->fd);

  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000c7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ca	52		 push	 edx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close
  000d1	83 c4 04	 add	 esp, 4
  000d4	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  000d7	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 529  :     free(state);

  000da	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dd	50		 push	 eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000e4	83 c4 04	 add	 esp, 4

; 530  :     return ret ? Z_ERRNO : Z_OK;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  000ea	f7 d8		 neg	 eax
  000ec	1b c0		 sbb	 eax, eax
$LN4@gzclose_w:

; 531  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Odtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 463  :     gz_statep state;
; 464  :     z_streamp strm;
; 465  : 
; 466  :     /* get internal structure */
; 467  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN8@gzsetparam

; 468  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 cc 00 00 00	 jmp	 $LN9@gzsetparam
$LN8@gzsetparam:

; 469  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 470  :     strm = &(state->strm);

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	83 c1 54	 add	 ecx, 84			; 00000054H
  00022	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 471  : 
; 472  :     /* check that we're writing and that there's no error */
; 473  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002e	75 09		 jne	 SHORT $LN6@gzsetparam
  00030	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00033	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00037	74 0a		 je	 SHORT $LN7@gzsetparam
$LN6@gzsetparam:

; 474  :         return Z_STREAM_ERROR;

  00039	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003e	e9 9f 00 00 00	 jmp	 $LN9@gzsetparam
$LN7@gzsetparam:

; 475  : 
; 476  :     /* if no change is requested, then do nothing */
; 477  :     if (level == state->level && strategy == state->strategy)

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00049	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  0004c	75 12		 jne	 SHORT $LN5@gzsetparam
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  00054	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  00057	75 07		 jne	 SHORT $LN5@gzsetparam

; 478  :         return Z_OK;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 82 00 00 00	 jmp	 $LN9@gzsetparam
$LN5@gzsetparam:

; 479  : 
; 480  :     /* check for seek request */
; 481  :     if (state->seek) {

  00060	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00063	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  00067	74 27		 je	 SHORT $LN4@gzsetparam

; 482  :         state->seek = 0;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 483  :         if (gz_zero(state, state->skip) == -1)

  00073	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00076	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00079	52		 push	 edx
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _gz_zero
  00083	83 c4 08	 add	 esp, 8
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 05		 jne	 SHORT $LN4@gzsetparam

; 484  :             return -1;

  0008b	83 c8 ff	 or	 eax, -1
  0008e	eb 52		 jmp	 SHORT $LN9@gzsetparam
$LN4@gzsetparam:

; 485  :     }
; 486  : 
; 487  :     /* change compression parameters for subsequent input */
; 488  :     if (state->size) {

  00090	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00093	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00097	74 35		 je	 SHORT $LN2@gzsetparam

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00099	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0009c	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000a0	74 1b		 je	 SHORT $LN1@gzsetparam
  000a2	6a 01		 push	 1
  000a4	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _gz_comp
  000ad	83 c4 08	 add	 esp, 8
  000b0	83 f8 ff	 cmp	 eax, -1
  000b3	75 08		 jne	 SHORT $LN1@gzsetparam

; 491  :             return state->err;

  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000b8	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  000bb	eb 25		 jmp	 SHORT $LN9@gzsetparam
$LN1@gzsetparam:

; 492  :         deflateParams(strm, level, strategy);

  000bd	8b 55 10	 mov	 edx, DWORD PTR _strategy$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 493  :     }
; 494  :     state->level = level;

  000ce	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000d1	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  000d4	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 495  :     state->strategy = strategy;

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000da	8b 55 10	 mov	 edx, DWORD PTR _strategy$[ebp]
  000dd	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 496  :     return Z_OK;

  000e0	33 c0		 xor	 eax, eax
$LN9@gzsetparam:

; 497  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Odtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 430  :     gz_statep state;
; 431  : 
; 432  :     /* get internal structure */
; 433  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN7@gzflush

; 434  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 7a		 jmp	 SHORT $LN8@gzflush
$LN7@gzflush:

; 435  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 436  : 
; 437  :     /* check that we're writing and that there's no error */
; 438  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 39 b1 79 00
	00		 cmp	 DWORD PTR [ecx], 31153	; 000079b1H
  0001e	75 09		 jne	 SHORT $LN5@gzflush
  00020	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00023	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00027	74 07		 je	 SHORT $LN6@gzflush
$LN5@gzflush:

; 439  :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002e	eb 59		 jmp	 SHORT $LN8@gzflush
$LN6@gzflush:

; 440  : 
; 441  :     /* check flush parameter */
; 442  :     if (flush < 0 || flush > Z_FINISH)

  00030	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00034	7c 06		 jl	 SHORT $LN3@gzflush
  00036	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0003a	7e 07		 jle	 SHORT $LN4@gzflush
$LN3@gzflush:

; 443  :         return Z_STREAM_ERROR;

  0003c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00041	eb 46		 jmp	 SHORT $LN8@gzflush
$LN4@gzflush:

; 444  : 
; 445  :     /* check for seek request */
; 446  :     if (state->seek) {

  00043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00046	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0004a	74 27		 je	 SHORT $LN2@gzflush

; 447  :         state->seek = 0;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004f	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 448  :         if (gz_zero(state, state->skip) == -1)

  00056	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00059	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0005c	50		 push	 eax
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _gz_zero
  00066	83 c4 08	 add	 esp, 8
  00069	83 f8 ff	 cmp	 eax, -1
  0006c	75 05		 jne	 SHORT $LN2@gzflush

; 449  :             return -1;

  0006e	83 c8 ff	 or	 eax, -1
  00071	eb 16		 jmp	 SHORT $LN8@gzflush
$LN2@gzflush:

; 450  :     }
; 451  : 
; 452  :     /* compress remaining data with requested flush */
; 453  :     gz_comp(state, flush);

  00073	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00076	52		 push	 edx
  00077	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _gz_comp
  00080	83 c4 08	 add	 esp, 8

; 454  :     return state->err;

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00086	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
$LN8@gzflush:

; 455  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzprintf
; Function compile flags: /Odtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_state$ = -20						; size = 4
_size$ = -16						; size = 4
_len$ = -12						; size = 4
_strm$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 283  :     int size, len;
; 284  :     gz_statep state;
; 285  :     z_streamp strm;
; 286  :     va_list va;
; 287  : 
; 288  :     /* get internal structure */
; 289  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN9@gzprintf

; 290  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 2d 01 00 00	 jmp	 $LN10@gzprintf
$LN9@gzprintf:

; 291  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 292  :     strm = &(state->strm);

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 54	 add	 ecx, 84			; 00000054H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 293  : 
; 294  :     /* check that we're writing and that there's no error */
; 295  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002c	75 09		 jne	 SHORT $LN7@gzprintf
  0002e	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00031	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00035	74 07		 je	 SHORT $LN8@gzprintf
$LN7@gzprintf:

; 296  :         return 0;

  00037	33 c0		 xor	 eax, eax
  00039	e9 03 01 00 00	 jmp	 $LN10@gzprintf
$LN8@gzprintf:

; 297  : 
; 298  :     /* make sure we have some buffer space */
; 299  :     if (state->size == 0 && gz_init(state) == -1)

  0003e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00041	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00045	75 18		 jne	 SHORT $LN6@gzprintf
  00047	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 _gz_init
  00050	83 c4 04	 add	 esp, 4
  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 07		 jne	 SHORT $LN6@gzprintf

; 300  :         return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 e2 00 00 00	 jmp	 $LN10@gzprintf
$LN6@gzprintf:

; 301  : 
; 302  :     /* check for seek request */
; 303  :     if (state->seek) {

  0005f	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00062	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00066	74 29		 je	 SHORT $LN5@gzprintf

; 304  :         state->seek = 0;

  00068	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006b	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 305  :         if (gz_zero(state, state->skip) == -1)

  00072	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00075	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00078	50		 push	 eax
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _gz_zero
  00082	83 c4 08	 add	 esp, 8
  00085	83 f8 ff	 cmp	 eax, -1
  00088	75 07		 jne	 SHORT $LN5@gzprintf

; 306  :             return 0;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 b0 00 00 00	 jmp	 $LN10@gzprintf
$LN5@gzprintf:

; 307  :     }
; 308  : 
; 309  :     /* consume whatever's left in the input buffer */
; 310  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00091	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00094	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00098	74 1a		 je	 SHORT $LN3@gzprintf
  0009a	6a 00		 push	 0
  0009c	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _gz_comp
  000a5	83 c4 08	 add	 esp, 8
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	75 07		 jne	 SHORT $LN3@gzprintf

; 311  :         return 0;

  000ad	33 c0		 xor	 eax, eax
  000af	e9 8d 00 00 00	 jmp	 $LN10@gzprintf
$LN3@gzprintf:

; 312  : 
; 313  :     /* do the printf() into the input buffer, put length in len */
; 314  :     size = (int)(state->size);

  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000b7	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000ba	89 55 f0	 mov	 DWORD PTR _size$[ebp], edx

; 315  :     state->in[size - 1] = 0;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _size$[ebp]
  000c6	c6 44 0a ff 00	 mov	 BYTE PTR [edx+ecx-1], 0

; 316  :     va_start(va, format);

  000cb	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  000ce	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 317  : #ifdef NO_vsnprintf
; 318  : #  ifdef HAS_vsprintf_void
; 319  :     (void)vsprintf(state->in, format, va);
; 320  :     va_end(va);
; 321  :     for (len = 0; len < size; len++)
; 322  :         if (state->in[len] == 0) break;
; 323  : #  else
; 324  :     len = vsprintf(state->in, format, va);
; 325  :     va_end(va);
; 326  : #  endif
; 327  : #else
; 328  : #  ifdef HAS_vsnprintf_void
; 329  :     (void)vsnprintf(state->in, size, format, va);
; 330  :     va_end(va);
; 331  :     len = strlen(state->in);
; 332  : #  else
; 333  :     len = vsnprintf((char *)(state->in), size, format, va);

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  000d4	51		 push	 ecx
  000d5	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  000d8	52		 push	 edx
  000d9	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000e0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000e3	52		 push	 edx
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  000ea	83 c4 10	 add	 esp, 16			; 00000010H
  000ed	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax

; 334  :     va_end(va);

  000f0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 335  : #  endif
; 336  : #endif
; 337  : 
; 338  :     /* check that printf() results fit in buffer */
; 339  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000f7	83 7d f4 00	 cmp	 DWORD PTR _len$[ebp], 0
  000fb	7e 1a		 jle	 SHORT $LN1@gzprintf
  000fd	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  00100	3b 45 f0	 cmp	 eax, DWORD PTR _size$[ebp]
  00103	7d 12		 jge	 SHORT $LN1@gzprintf
  00105	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00108	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0010b	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  0010e	0f b6 4c 02 ff	 movzx	 ecx, BYTE PTR [edx+eax-1]
  00113	85 c9		 test	 ecx, ecx
  00115	74 04		 je	 SHORT $LN2@gzprintf
$LN1@gzprintf:

; 340  :         return 0;

  00117	33 c0		 xor	 eax, eax
  00119	eb 26		 jmp	 SHORT $LN10@gzprintf
$LN2@gzprintf:

; 341  : 
; 342  :     /* update buffer and position, defer compression until needed */
; 343  :     strm->avail_in = (unsigned)len;

  0011b	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0011e	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  00121	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 344  :     strm->next_in = state->in;

  00124	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00127	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0012a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0012d	89 01		 mov	 DWORD PTR [ecx], eax

; 345  :     state->pos += len;

  0012f	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00132	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00135	03 55 f4	 add	 edx, DWORD PTR _len$[ebp]
  00138	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0013b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 346  :     return len;

  0013e	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
$LN10@gzprintf:

; 347  : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Odtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_state$ = -16						; size = 4
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_put$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 148  :     unsigned put = len;

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 149  :     unsigned n;
; 150  :     gz_statep state;
; 151  :     z_streamp strm;
; 152  : 
; 153  :     /* get internal structure */
; 154  :     if (file == NULL)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00010	75 07		 jne	 SHORT $LN18@gzwrite

; 155  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 b5 01 00 00	 jmp	 $LN19@gzwrite
$LN18@gzwrite:

; 156  :     state = (gz_statep)file;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0001c	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx

; 157  :     strm = &(state->strm);

  0001f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00022	83 c2 54	 add	 edx, 84			; 00000054H
  00025	89 55 f4	 mov	 DWORD PTR _strm$[ebp], edx

; 158  : 
; 159  :     /* check that we're writing and that there's no error */
; 160  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00028	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	81 38 b1 79 00
	00		 cmp	 DWORD PTR [eax], 31153	; 000079b1H
  00031	75 09		 jne	 SHORT $LN16@gzwrite
  00033	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00036	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  0003a	74 07		 je	 SHORT $LN17@gzwrite
$LN16@gzwrite:

; 161  :         return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 8b 01 00 00	 jmp	 $LN19@gzwrite
$LN17@gzwrite:

; 162  : 
; 163  :     /* since an int is returned, make sure len fits in one, otherwise return
; 164  :        with an error (this avoids the flaw in the interface) */
; 165  :     if ((int)len < 0) {

  00043	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00047	7d 1a		 jge	 SHORT $LN15@gzwrite

; 166  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0004e	6a fb		 push	 -5			; fffffffbH
  00050	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _gz_error
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 6b 01 00 00	 jmp	 $LN19@gzwrite
$LN15@gzwrite:

; 168  :     }
; 169  : 
; 170  :     /* if len is zero, avoid unnecessary operations */
; 171  :     if (len == 0)

  00063	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00067	75 07		 jne	 SHORT $LN14@gzwrite

; 172  :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 5e 01 00 00	 jmp	 $LN19@gzwrite
$LN14@gzwrite:

; 173  : 
; 174  :     /* allocate memory if this is the first time through */
; 175  :     if (state->size == 0 && gz_init(state) == -1)

  00070	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00073	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00077	75 18		 jne	 SHORT $LN13@gzwrite
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _gz_init
  00082	83 c4 04	 add	 esp, 4
  00085	83 f8 ff	 cmp	 eax, -1
  00088	75 07		 jne	 SHORT $LN13@gzwrite

; 176  :         return 0;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 3d 01 00 00	 jmp	 $LN19@gzwrite
$LN13@gzwrite:

; 177  : 
; 178  :     /* check for seek request */
; 179  :     if (state->seek) {

  00091	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00094	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  00098	74 29		 je	 SHORT $LN12@gzwrite

; 180  :         state->seek = 0;

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 181  :         if (gz_zero(state, state->skip) == -1)

  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000a7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000aa	52		 push	 edx
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _gz_zero
  000b4	83 c4 08	 add	 esp, 8
  000b7	83 f8 ff	 cmp	 eax, -1
  000ba	75 07		 jne	 SHORT $LN12@gzwrite

; 182  :             return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	e9 0b 01 00 00	 jmp	 $LN19@gzwrite
$LN12@gzwrite:

; 183  :     }
; 184  : 
; 185  :     /* for small len, copy to input buffer, otherwise compress directly */
; 186  :     if (len < state->size) {

  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  000c9	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000cc	0f 83 a2 00 00
	00		 jae	 $LN10@gzwrite
$LN9@gzwrite:

; 187  :         /* copy to input buffer, compress when full */
; 188  :         do {
; 189  :             if (strm->avail_in == 0)

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  000d5	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000d9	75 0b		 jne	 SHORT $LN6@gzwrite

; 190  :                 strm->next_in = state->in;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000de	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000e1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000e4	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@gzwrite:

; 191  :             n = state->size - strm->avail_in;

  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e9	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000ec	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000ef	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  000f2	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 192  :             if (n > len)

  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000f8	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  000fb	76 06		 jbe	 SHORT $LN5@gzwrite

; 193  :                 n = len;

  000fd	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00100	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
$LN5@gzwrite:

; 194  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  00103	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00106	50		 push	 eax
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0010a	51		 push	 ecx
  0010b	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0010e	8b 02		 mov	 eax, DWORD PTR [edx]
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00113	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _memcpy
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  :             strm->avail_in += n;

  0011f	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00122	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00125	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00128	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0012b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 196  :             state->pos += n;

  0012e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00131	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00134	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00137	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0013a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 197  :             buf = (char *)buf + n;

  0013d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00140	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  00143	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 198  :             len -= n;

  00146	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00149	2b 45 f8	 sub	 eax, DWORD PTR _n$[ebp]
  0014c	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 199  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  0014f	74 17		 je	 SHORT $LN8@gzwrite
  00151	6a 00		 push	 0
  00153	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 _gz_comp
  0015c	83 c4 08	 add	 esp, 8
  0015f	83 f8 ff	 cmp	 eax, -1
  00162	75 04		 jne	 SHORT $LN8@gzwrite

; 200  :                 return 0;

  00164	33 c0		 xor	 eax, eax
  00166	eb 66		 jmp	 SHORT $LN19@gzwrite
$LN8@gzwrite:

; 201  :         } while (len);

  00168	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0016c	0f 85 60 ff ff
	ff		 jne	 $LN9@gzwrite

; 202  :     }
; 203  :     else {

  00172	eb 57		 jmp	 SHORT $LN3@gzwrite
$LN10@gzwrite:

; 204  :         /* consume whatever's left in the input buffer */
; 205  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00174	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00177	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0017b	74 17		 je	 SHORT $LN2@gzwrite
  0017d	6a 00		 push	 0
  0017f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _gz_comp
  00188	83 c4 08	 add	 esp, 8
  0018b	83 f8 ff	 cmp	 eax, -1
  0018e	75 04		 jne	 SHORT $LN2@gzwrite

; 206  :             return 0;

  00190	33 c0		 xor	 eax, eax
  00192	eb 3a		 jmp	 SHORT $LN19@gzwrite
$LN2@gzwrite:

; 207  : 
; 208  :         /* directly compress user buffer to file */
; 209  :         strm->avail_in = len;

  00194	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00197	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0019a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 210  :         strm->next_in = (voidp)buf;

  0019d	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  001a0	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  001a3	89 08		 mov	 DWORD PTR [eax], ecx

; 211  :         state->pos += len;

  001a5	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001a8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001ab	03 45 10	 add	 eax, DWORD PTR _len$[ebp]
  001ae	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001b1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 212  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  001b4	6a 00		 push	 0
  001b6	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001b9	52		 push	 edx
  001ba	e8 00 00 00 00	 call	 _gz_comp
  001bf	83 c4 08	 add	 esp, 8
  001c2	83 f8 ff	 cmp	 eax, -1
  001c5	75 04		 jne	 SHORT $LN3@gzwrite

; 213  :             return 0;

  001c7	33 c0		 xor	 eax, eax
  001c9	eb 03		 jmp	 SHORT $LN19@gzwrite
$LN3@gzwrite:

; 214  :     }
; 215  : 
; 216  :     /* input was all buffered or compressed (put will fit in int) */
; 217  :     return (int)put;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
$LN19@gzwrite:

; 218  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
PUBLIC	_gzputs@8
; Function compile flags: /Odtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
tv72 = -12						; size = 4
_ret$ = -8						; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 268  :     int ret;
; 269  :     unsigned len;
; 270  : 
; 271  :     /* write string */
; 272  :     len = (unsigned)strlen(str);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strlen
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 273  :     ret = gzwrite(file, str, len);

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gzwrite@12
  00026	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 274  :     return ret == 0 && len != 0 ? -1 : ret;

  00029	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0002d	75 0f		 jne	 SHORT $LN3@gzputs
  0002f	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00033	74 09		 je	 SHORT $LN3@gzputs
  00035	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv72[ebp], -1
  0003c	eb 06		 jmp	 SHORT $LN4@gzputs
$LN3@gzputs:
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00041	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
$LN4@gzputs:
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv72[ebp]

; 275  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Odtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_state$ = -12						; size = 4
_buf$ = -5						; size = 1
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 225  :     unsigned char buf[1];
; 226  :     gz_statep state;
; 227  :     z_streamp strm;
; 228  : 
; 229  :     /* get internal structure */
; 230  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN8@gzputc

; 231  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 d3 00 00 00	 jmp	 $LN9@gzputc
$LN8@gzputc:

; 232  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 233  :     strm = &(state->strm);

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 54	 add	 ecx, 84			; 00000054H
  00020	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 234  : 
; 235  :     /* check that we're writing and that there's no error */
; 236  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 3a b1 79 00
	00		 cmp	 DWORD PTR [edx], 31153	; 000079b1H
  0002c	75 09		 jne	 SHORT $LN6@gzputc
  0002e	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00031	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00035	74 08		 je	 SHORT $LN7@gzputc
$LN6@gzputc:

; 237  :         return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	e9 a8 00 00 00	 jmp	 $LN9@gzputc
$LN7@gzputc:

; 238  : 
; 239  :     /* check for seek request */
; 240  :     if (state->seek) {

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  00046	74 27		 je	 SHORT $LN5@gzputc

; 241  :         state->seek = 0;

  00048	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0004b	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 242  :         if (gz_zero(state, state->skip) == -1)

  00052	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00055	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00058	51		 push	 ecx
  00059	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _gz_zero
  00062	83 c4 08	 add	 esp, 8
  00065	83 f8 ff	 cmp	 eax, -1
  00068	75 05		 jne	 SHORT $LN5@gzputc

; 243  :             return -1;

  0006a	83 c8 ff	 or	 eax, -1
  0006d	eb 78		 jmp	 SHORT $LN9@gzputc
$LN5@gzputc:

; 244  :     }
; 245  : 
; 246  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 247  :        initialized) */
; 248  :     if (strm->avail_in < state->size) {

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00075	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00078	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0007b	73 48		 jae	 SHORT $LN3@gzputc

; 249  :         if (strm->avail_in == 0)

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00080	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00084	75 0b		 jne	 SHORT $LN2@gzputc

; 250  :             strm->next_in = state->in;

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00089	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0008c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0008f	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@gzputc:

; 251  :         strm->next_in[strm->avail_in++] = c;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  0009f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a8	83 c2 01	 add	 edx, 1
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000ae	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 252  :         state->pos++;

  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000b4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b7	83 c2 01	 add	 edx, 1
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 253  :         return c;

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000c3	eb 22		 jmp	 SHORT $LN9@gzputc
$LN3@gzputc:

; 254  :     }
; 255  : 
; 256  :     /* no room in buffer or not initialized, use gz_write() */
; 257  :     buf[0] = c;

  000c5	8a 4d 0c	 mov	 cl, BYTE PTR _c$[ebp]
  000c8	88 4d fb	 mov	 BYTE PTR _buf$[ebp], cl

; 258  :     if (gzwrite(file, buf, 1) != 1)

  000cb	6a 01		 push	 1
  000cd	8d 55 fb	 lea	 edx, DWORD PTR _buf$[ebp]
  000d0	52		 push	 edx
  000d1	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _gzwrite@12
  000da	83 f8 01	 cmp	 eax, 1
  000dd	74 05		 je	 SHORT $LN1@gzputc

; 259  :         return -1;

  000df	83 c8 ff	 or	 eax, -1
  000e2	eb 03		 jmp	 SHORT $LN9@gzputc
$LN1@gzputc:

; 260  :     return c;

  000e4	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
$LN9@gzputc:

; 261  : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 08 00	 ret	 8
_gzputc@8 ENDP
END
