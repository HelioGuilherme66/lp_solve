; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\lp_solve_5.5\xli\xli_ZIMPL\ziboptVS10\thirdparty\zlib\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
; Function compile flags: /Odtp
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00007	74 12		 je	 SHORT $LN1@inflateBac
  00009	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	74 09		 je	 SHORT $LN1@inflateBac
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00015	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00019	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 627  :         return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00020	eb 25		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 628  :     ZFREE(strm, strm->state);

  00022	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00025	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00033	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8

; 629  :     strm->state = Z_NULL;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  00045	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 632  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 112  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 113  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 114  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Odtp
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00004	83 7d 14 00	 cmp	 DWORD PTR _version$[ebp], 0
  00008	74 17		 je	 SHORT $LN6@inflateBac@2
  0000a	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  0000d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00010	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  00017	3b ca		 cmp	 ecx, edx
  00019	75 06		 jne	 SHORT $LN6@inflateBac@2
  0001b	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00021	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00026	e9 d0 00 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0002b	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0002f	74 12		 je	 SHORT $LN4@inflateBac@2
  00031	83 7d 10 00	 cmp	 DWORD PTR _window$[ebp], 0
  00035	74 0c		 je	 SHORT $LN4@inflateBac@2
  00037	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0003b	7c 06		 jl	 SHORT $LN4@inflateBac@2
  0003d	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00041	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00043	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00048	e9 ae 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0005e	75 14		 jne	 SHORT $LN3@inflateBac@2

; 45   :         strm->zalloc = zcalloc;

  00060	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00063	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 46   :         strm->opaque = (voidpf)0;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN3@inflateBac@2:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00077	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0007b	75 0a		 jne	 SHORT $LN2@inflateBac@2
  0007d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00080	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  00087	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0008c	6a 01		 push	 1
  0008e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00091	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00094	51		 push	 ecx
  00095	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00098	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0009b	ff d0		 call	 eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  000a7	75 07		 jne	 SHORT $LN1@inflateBac@2
  000a9	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000ae	eb 4b		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 54   :     state->dmax = 32768U;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000bc	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [eax+20], 32768 ; 00008000H

; 55   :     state->wbits = windowBits;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  000c9	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 56   :     state->wsize = 1U << windowBits;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000d4	d3 e0		 shl	 eax, cl
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 57   :     state->window = window;

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _window$[ebp]
  000e2	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 58   :     state->wnext = 0;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 59   :     state->whave = 0;

  000ef	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f2	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 60   :     return Z_OK;

  000f9	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 61   : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
PUBLIC	_inflateBack@20
; Function compile flags: /Odtp
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv137 = -64						; size = 4
tv76 = -60						; size = 4
tv73 = -56						; size = 4
_state$ = -52						; size = 4
_from$ = -48						; size = 4
_copy$ = -44						; size = 4
_hold$ = -40						; size = 4
_ret$ = -36						; size = 4
_next$ = -32						; size = 4
_left$ = -28						; size = 4
_bits$ = -24						; size = 4
_len$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN346@inflateBac@3
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN347@inflateBac@3
$LN346@inflateBac@3:

; 265  :         return Z_STREAM_ERROR;

  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 a7 13 00 00	 jmp	 $LN348@inflateBac@3
$LN347@inflateBac@3:

; 266  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 cc	 mov	 DWORD PTR _state$[ebp], edx

; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 270  :     state->mode = TYPE;

  00032	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 271  :     state->last = 0;

  0003b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 272  :     state->whave = 0;

  00045	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00048	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 273  :     next = strm->next_in;

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00057	83 7d e0 00	 cmp	 DWORD PTR _next$[ebp], 0
  0005b	74 0b		 je	 SHORT $LN350@inflateBac@3
  0005d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	89 4d c8	 mov	 DWORD PTR tv73[ebp], ecx
  00066	eb 07		 jmp	 SHORT $LN351@inflateBac@3
$LN350@inflateBac@3:
  00068	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN351@inflateBac@3:
  0006f	8b 55 c8	 mov	 edx, DWORD PTR tv73[ebp]
  00072	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 275  :     hold = 0;

  00075	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0

; 276  :     bits = 0;

  0007c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 277  :     put = state->window;

  00083	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00086	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00089	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 278  :     left = state->wsize;

  0008c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00092	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
$LN345@inflateBac@3:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00095	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 55 c4	 mov	 DWORD PTR tv76[ebp], edx
  0009d	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  000a0	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000a3	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000a6	83 7d c4 12	 cmp	 DWORD PTR tv76[ebp], 18	; 00000012H
  000aa	0f 87 f4 12 00
	00		 ja	 $LN1@inflateBac@3
  000b0	8b 4d c4	 mov	 ecx, DWORD PTR tv76[ebp]
  000b3	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN352@inflateBac@3[ecx]
  000ba	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN353@inflateBac@3[edx*4]
$LN341@inflateBac@3:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  000c1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000c4	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000c8	74 2e		 je	 SHORT $LN333@inflateBac@3
$LN339@inflateBac@3:

; 286  :                 BYTEBITS();

  000ca	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000cd	83 e1 07	 and	 ecx, 7
  000d0	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  000d3	d3 ea		 shr	 edx, cl
  000d5	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  000d8	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  000db	83 e0 07	 and	 eax, 7
  000de	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000e1	2b c8		 sub	 ecx, eax
  000e3	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  000e6	33 d2		 xor	 edx, edx
  000e8	75 e0		 jne	 SHORT $LN339@inflateBac@3

; 287  :                 state->mode = DONE;

  000ea	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000ed	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH

; 288  :                 break;

  000f3	e9 b5 12 00 00	 jmp	 $LN342@inflateBac@3
$LN333@inflateBac@3:

; 289  :             }
; 290  :             NEEDBITS(3);

  000f8	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  000fc	73 66		 jae	 SHORT $LN335@inflateBac@3
$LN328@inflateBac@3:
  000fe	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00102	75 2a		 jne	 SHORT $LN327@inflateBac@3
  00104	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0010b	52		 push	 edx
  0010c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0010f	83 c4 08	 add	 esp, 8
  00112	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00115	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00119	75 13		 jne	 SHORT $LN327@inflateBac@3
  0011b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00122	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00129	e9 84 12 00 00	 jmp	 $inf_leave$77633
$LN327@inflateBac@3:
  0012e	33 c0		 xor	 eax, eax
  00130	75 cc		 jne	 SHORT $LN328@inflateBac@3
  00132	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00135	83 e9 01	 sub	 ecx, 1
  00138	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0013b	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0013e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00141	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00144	d3 e0		 shl	 eax, cl
  00146	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00149	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0014c	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0014f	83 c1 01	 add	 ecx, 1
  00152	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00155	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00158	83 c2 08	 add	 edx, 8
  0015b	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0015e	33 c0		 xor	 eax, eax
  00160	75 9c		 jne	 SHORT $LN328@inflateBac@3
  00162	eb 94		 jmp	 SHORT $LN333@inflateBac@3
$LN335@inflateBac@3:
  00164	33 c9		 xor	 ecx, ecx
  00166	75 90		 jne	 SHORT $LN333@inflateBac@3

; 291  :             state->last = BITS(1);

  00168	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0016b	83 e2 01	 and	 edx, 1
  0016e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00171	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN323@inflateBac@3:

; 292  :             DROPBITS(1);

  00174	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00177	d1 e9		 shr	 ecx, 1
  00179	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0017c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0017f	83 ea 01	 sub	 edx, 1
  00182	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00185	33 c0		 xor	 eax, eax
  00187	75 eb		 jne	 SHORT $LN323@inflateBac@3

; 293  :             switch (BITS(2)) {

  00189	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0018c	83 e1 03	 and	 ecx, 3
  0018f	89 4d c0	 mov	 DWORD PTR tv137[ebp], ecx
  00192	83 7d c0 03	 cmp	 DWORD PTR tv137[ebp], 3
  00196	77 4a		 ja	 SHORT $LN314@inflateBac@3
  00198	8b 55 c0	 mov	 edx, DWORD PTR tv137[ebp]
  0019b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN354@inflateBac@3[edx*4]
$LN318@inflateBac@3:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  001a2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001a5	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 298  :                 break;

  001ab	eb 35		 jmp	 SHORT $LN314@inflateBac@3
$LN317@inflateBac@3:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  001ad	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 _fixedtables
  001b6	83 c4 04	 add	 esp, 4

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  001b9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001bc	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H

; 304  :                 break;

  001c2	eb 1e		 jmp	 SHORT $LN314@inflateBac@3
$LN316@inflateBac@3:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  001c4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001c7	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 309  :                 break;

  001cd	eb 13		 jmp	 SHORT $LN314@inflateBac@3
$LN315@inflateBac@3:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  001cf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001d2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 312  :                 state->mode = BAD;

  001d9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001dc	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
$LN314@inflateBac@3:

; 313  :             }
; 314  :             DROPBITS(2);

  001e2	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  001e5	c1 e8 02	 shr	 eax, 2
  001e8	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  001eb	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  001ee	83 e9 02	 sub	 ecx, 2
  001f1	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  001f4	33 d2		 xor	 edx, edx
  001f6	75 ea		 jne	 SHORT $LN314@inflateBac@3

; 315  :             break;

  001f8	e9 b0 11 00 00	 jmp	 $LN342@inflateBac@3
$LN310@inflateBac@3:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  001fd	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00200	83 e1 07	 and	 ecx, 7
  00203	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00206	d3 e8		 shr	 eax, cl
  00208	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0020b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0020e	83 e1 07	 and	 ecx, 7
  00211	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00214	2b d1		 sub	 edx, ecx
  00216	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00219	33 c0		 xor	 eax, eax
  0021b	75 e0		 jne	 SHORT $LN310@inflateBac@3
$LN304@inflateBac@3:

; 320  :             NEEDBITS(32);

  0021d	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00221	73 66		 jae	 SHORT $LN306@inflateBac@3
$LN299@inflateBac@3:
  00223	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00227	75 2a		 jne	 SHORT $LN298@inflateBac@3
  00229	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0022c	51		 push	 ecx
  0022d	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00230	52		 push	 edx
  00231	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00234	83 c4 08	 add	 esp, 8
  00237	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0023a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0023e	75 13		 jne	 SHORT $LN298@inflateBac@3
  00240	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00247	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0024e	e9 5f 11 00 00	 jmp	 $inf_leave$77633
$LN298@inflateBac@3:
  00253	33 c0		 xor	 eax, eax
  00255	75 cc		 jne	 SHORT $LN299@inflateBac@3
  00257	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0025a	83 e9 01	 sub	 ecx, 1
  0025d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00260	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00263	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00266	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00269	d3 e0		 shl	 eax, cl
  0026b	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0026e	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00271	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00274	83 c1 01	 add	 ecx, 1
  00277	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0027a	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0027d	83 c2 08	 add	 edx, 8
  00280	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00283	33 c0		 xor	 eax, eax
  00285	75 9c		 jne	 SHORT $LN299@inflateBac@3
  00287	eb 94		 jmp	 SHORT $LN304@inflateBac@3
$LN306@inflateBac@3:
  00289	33 c9		 xor	 ecx, ecx
  0028b	75 90		 jne	 SHORT $LN304@inflateBac@3

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0028d	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00290	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00296	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00299	c1 e8 10	 shr	 eax, 16			; 00000010H
  0029c	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  002a1	3b d0		 cmp	 edx, eax
  002a3	74 18		 je	 SHORT $LN294@inflateBac@3

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002a8	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 323  :                 state->mode = BAD;

  002af	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  002b2	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 324  :                 break;

  002b8	e9 f0 10 00 00	 jmp	 $LN342@inflateBac@3
$LN294@inflateBac@3:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  002bd	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  002c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002c5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002c8	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN293@inflateBac@3:

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  002cb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002d2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002d9	33 d2		 xor	 edx, edx
  002db	75 ee		 jne	 SHORT $LN293@inflateBac@3
$LN290@inflateBac@3:

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  002dd	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  002e0	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  002e4	0f 84 ec 00 00
	00		 je	 $LN289@inflateBac@3

; 333  :                 copy = state->length;

  002ea	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002ed	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  002f0	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN288@inflateBac@3:

; 334  :                 PULL();

  002f3	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  002f7	75 2a		 jne	 SHORT $LN287@inflateBac@3
  002f9	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  002fc	50		 push	 eax
  002fd	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00300	51		 push	 ecx
  00301	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00304	83 c4 08	 add	 esp, 8
  00307	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0030a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0030e	75 13		 jne	 SHORT $LN287@inflateBac@3
  00310	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00317	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0031e	e9 8f 10 00 00	 jmp	 $inf_leave$77633
$LN287@inflateBac@3:
  00323	33 d2		 xor	 edx, edx
  00325	75 cc		 jne	 SHORT $LN288@inflateBac@3
$LN283@inflateBac@3:

; 335  :                 ROOM();

  00327	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0032b	75 3d		 jne	 SHORT $LN282@inflateBac@3
  0032d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00330	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00333	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00336	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00339	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0033c	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  0033f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00342	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00345	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00348	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0034b	50		 push	 eax
  0034c	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0034f	51		 push	 ecx
  00350	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00353	52		 push	 edx
  00354	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035a	85 c0		 test	 eax, eax
  0035c	74 0c		 je	 SHORT $LN282@inflateBac@3
  0035e	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00365	e9 48 10 00 00	 jmp	 $inf_leave$77633
$LN282@inflateBac@3:
  0036a	33 c0		 xor	 eax, eax
  0036c	75 b9		 jne	 SHORT $LN283@inflateBac@3

; 336  :                 if (copy > have) copy = have;

  0036e	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00371	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00374	76 06		 jbe	 SHORT $LN278@inflateBac@3
  00376	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00379	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN278@inflateBac@3:

; 337  :                 if (copy > left) copy = left;

  0037c	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  0037f	3b 45 e4	 cmp	 eax, DWORD PTR _left$[ebp]
  00382	76 06		 jbe	 SHORT $LN277@inflateBac@3
  00384	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00387	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN277@inflateBac@3:

; 338  :                 zmemcpy(put, next, copy);

  0038a	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  0038d	52		 push	 edx
  0038e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00391	50		 push	 eax
  00392	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00395	51		 push	 ecx
  00396	e8 00 00 00 00	 call	 _memcpy
  0039b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  :                 have -= copy;

  0039e	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  003a1	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  003a4	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 340  :                 next += copy;

  003a7	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  003aa	03 45 d4	 add	 eax, DWORD PTR _copy$[ebp]
  003ad	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax

; 341  :                 left -= copy;

  003b0	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  003b3	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003b6	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx

; 342  :                 put += copy;

  003b9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  003bc	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  003bf	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 343  :                 state->length -= copy;

  003c2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003c5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  003c8	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003cb	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  003ce	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 344  :             }

  003d1	e9 07 ff ff ff	 jmp	 $LN290@inflateBac@3
$LN289@inflateBac@3:

; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  003d6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003d9	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 347  :             break;

  003df	e9 c9 0f 00 00	 jmp	 $LN342@inflateBac@3
$LN272@inflateBac@3:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  003e4	83 7d e8 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  003e8	73 66		 jae	 SHORT $LN274@inflateBac@3
$LN267@inflateBac@3:
  003ea	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  003ee	75 2a		 jne	 SHORT $LN266@inflateBac@3
  003f0	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  003f3	51		 push	 ecx
  003f4	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  003f7	52		 push	 edx
  003f8	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  003fb	83 c4 08	 add	 esp, 8
  003fe	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00401	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00405	75 13		 jne	 SHORT $LN266@inflateBac@3
  00407	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0040e	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00415	e9 98 0f 00 00	 jmp	 $inf_leave$77633
$LN266@inflateBac@3:
  0041a	33 c0		 xor	 eax, eax
  0041c	75 cc		 jne	 SHORT $LN267@inflateBac@3
  0041e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00421	83 e9 01	 sub	 ecx, 1
  00424	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00427	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0042a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0042d	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00430	d3 e0		 shl	 eax, cl
  00432	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00435	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00438	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0043b	83 c1 01	 add	 ecx, 1
  0043e	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00441	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00444	83 c2 08	 add	 edx, 8
  00447	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0044a	33 c0		 xor	 eax, eax
  0044c	75 9c		 jne	 SHORT $LN267@inflateBac@3
  0044e	eb 94		 jmp	 SHORT $LN272@inflateBac@3
$LN274@inflateBac@3:
  00450	33 c9		 xor	 ecx, ecx
  00452	75 90		 jne	 SHORT $LN272@inflateBac@3

; 352  :             state->nlen = BITS(5) + 257;

  00454	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00457	83 e2 1f	 and	 edx, 31			; 0000001fH
  0045a	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00460	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00463	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN262@inflateBac@3:

; 353  :             DROPBITS(5);

  00466	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00469	c1 e9 05	 shr	 ecx, 5
  0046c	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0046f	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00472	83 ea 05	 sub	 edx, 5
  00475	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00478	33 c0		 xor	 eax, eax
  0047a	75 ea		 jne	 SHORT $LN262@inflateBac@3

; 354  :             state->ndist = BITS(5) + 1;

  0047c	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0047f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00482	83 c1 01	 add	 ecx, 1
  00485	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00488	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
$LN259@inflateBac@3:

; 355  :             DROPBITS(5);

  0048b	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0048e	c1 e8 05	 shr	 eax, 5
  00491	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00494	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00497	83 e9 05	 sub	 ecx, 5
  0049a	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0049d	33 d2		 xor	 edx, edx
  0049f	75 ea		 jne	 SHORT $LN259@inflateBac@3

; 356  :             state->ncode = BITS(4) + 4;

  004a1	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  004a4	83 e0 0f	 and	 eax, 15			; 0000000fH
  004a7	83 c0 04	 add	 eax, 4
  004aa	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  004ad	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN256@inflateBac@3:

; 357  :             DROPBITS(4);

  004b0	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  004b3	c1 ea 04	 shr	 edx, 4
  004b6	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  004b9	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  004bc	83 e8 04	 sub	 eax, 4
  004bf	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  004c2	33 c9		 xor	 ecx, ecx
  004c4	75 ea		 jne	 SHORT $LN256@inflateBac@3

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  004c6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004c9	81 7a 60 1e 01
	00 00		 cmp	 DWORD PTR [edx+96], 286	; 0000011eH
  004d0	77 09		 ja	 SHORT $LN252@inflateBac@3
  004d2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004d5	83 78 64 1e	 cmp	 DWORD PTR [eax+100], 30	; 0000001eH
  004d9	76 18		 jbe	 SHORT $LN253@inflateBac@3
$LN252@inflateBac@3:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  004db	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  004de	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 361  :                 state->mode = BAD;

  004e5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004e8	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 362  :                 break;

  004ee	e9 ba 0e 00 00	 jmp	 $LN342@inflateBac@3
$LN253@inflateBac@3:

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  004f3	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004f6	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0
$LN251@inflateBac@3:

; 369  :             while (state->have < state->ncode) {

  004fd	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00500	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00503	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00506	3b 42 5c	 cmp	 eax, DWORD PTR [edx+92]
  00509	0f 83 b6 00 00
	00		 jae	 $LN233@inflateBac@3
$LN246@inflateBac@3:

; 370  :                 NEEDBITS(3);

  0050f	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00513	73 66		 jae	 SHORT $LN248@inflateBac@3
$LN241@inflateBac@3:
  00515	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00519	75 2a		 jne	 SHORT $LN240@inflateBac@3
  0051b	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0051e	51		 push	 ecx
  0051f	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00522	52		 push	 edx
  00523	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00526	83 c4 08	 add	 esp, 8
  00529	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0052c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00530	75 13		 jne	 SHORT $LN240@inflateBac@3
  00532	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00539	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00540	e9 6d 0e 00 00	 jmp	 $inf_leave$77633
$LN240@inflateBac@3:
  00545	33 c0		 xor	 eax, eax
  00547	75 cc		 jne	 SHORT $LN241@inflateBac@3
  00549	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0054c	83 e9 01	 sub	 ecx, 1
  0054f	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00552	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00555	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00558	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0055b	d3 e0		 shl	 eax, cl
  0055d	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00560	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00563	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00566	83 c1 01	 add	 ecx, 1
  00569	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0056c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0056f	83 c2 08	 add	 edx, 8
  00572	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00575	33 c0		 xor	 eax, eax
  00577	75 9c		 jne	 SHORT $LN241@inflateBac@3
  00579	eb 94		 jmp	 SHORT $LN246@inflateBac@3
$LN248@inflateBac@3:
  0057b	33 c9		 xor	 ecx, ecx
  0057d	75 90		 jne	 SHORT $LN246@inflateBac@3

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0057f	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00582	83 e2 07	 and	 edx, 7
  00585	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00588	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0058b	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  00593	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00596	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  0059b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0059e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005a1	83 c0 01	 add	 eax, 1
  005a4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005a7	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN236@inflateBac@3:

; 372  :                 DROPBITS(3);

  005aa	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  005ad	c1 ea 03	 shr	 edx, 3
  005b0	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  005b3	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  005b6	83 e8 03	 sub	 eax, 3
  005b9	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  005bc	33 c9		 xor	 ecx, ecx
  005be	75 ea		 jne	 SHORT $LN236@inflateBac@3

; 373  :             }

  005c0	e9 38 ff ff ff	 jmp	 $LN251@inflateBac@3
$LN233@inflateBac@3:

; 374  :             while (state->have < 19)

  005c5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005c8	83 7a 68 13	 cmp	 DWORD PTR [edx+104], 19	; 00000013H
  005cc	73 29		 jae	 SHORT $LN232@inflateBac@3

; 375  :                 state->lens[order[state->have++]] = 0;

  005ce	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  005d1	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  005d4	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  005dc	33 c0		 xor	 eax, eax
  005de	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005e1	66 89 44 51 70	 mov	 WORD PTR [ecx+edx*2+112], ax
  005e6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005e9	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005ec	83 c0 01	 add	 eax, 1
  005ef	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005f2	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  005f5	eb ce		 jmp	 SHORT $LN233@inflateBac@3
$LN232@inflateBac@3:

; 376  :             state->next = state->codes;

  005f7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005fa	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00600	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00603	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 377  :             state->lencode = (code const FAR *)(state->next);

  00606	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00609	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0060c	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0060f	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 378  :             state->lenbits = 7;

  00612	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00615	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0061c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0061f	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00625	52		 push	 edx
  00626	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00629	83 c0 54	 add	 eax, 84			; 00000054H
  0062c	50		 push	 eax
  0062d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00630	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00633	51		 push	 ecx
  00634	6a 13		 push	 19			; 00000013H
  00636	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00639	83 c2 70	 add	 edx, 112		; 00000070H
  0063c	52		 push	 edx
  0063d	6a 00		 push	 0
  0063f	e8 00 00 00 00	 call	 _inflate_table
  00644	83 c4 18	 add	 esp, 24			; 00000018H
  00647	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 381  :             if (ret) {

  0064a	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0064e	74 18		 je	 SHORT $LN231@inflateBac@3

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  00650	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00653	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 383  :                 state->mode = BAD;

  0065a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0065d	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 384  :                 break;

  00663	e9 45 0d 00 00	 jmp	 $LN342@inflateBac@3
$LN231@inflateBac@3:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;

  00668	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0066b	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
$LN230@inflateBac@3:

; 390  :             while (state->have < state->nlen + state->ndist) {

  00672	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00675	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00678	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0067b	03 4a 64	 add	 ecx, DWORD PTR [edx+100]
  0067e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00681	39 48 68	 cmp	 DWORD PTR [eax+104], ecx
  00684	0f 83 3b 04 00
	00		 jae	 $LN229@inflateBac@3
$LN228@inflateBac@3:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  0068a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0068d	ba 01 00 00 00	 mov	 edx, 1
  00692	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00695	d3 e2		 shl	 edx, cl
  00697	83 ea 01	 sub	 edx, 1
  0069a	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  0069d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  006a0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  006a3	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  006a6	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  006a9	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  006ad	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  006b0	77 02		 ja	 SHORT $LN222@inflateBac@3
  006b2	eb 69		 jmp	 SHORT $LN227@inflateBac@3
$LN222@inflateBac@3:

; 394  :                     PULLBYTE();

  006b4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006b8	75 2a		 jne	 SHORT $LN221@inflateBac@3
  006ba	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  006bd	51		 push	 ecx
  006be	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  006c1	52		 push	 edx
  006c2	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  006c5	83 c4 08	 add	 esp, 8
  006c8	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  006cb	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006cf	75 13		 jne	 SHORT $LN221@inflateBac@3
  006d1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  006d8	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  006df	e9 ce 0c 00 00	 jmp	 $inf_leave$77633
$LN221@inflateBac@3:
  006e4	33 c0		 xor	 eax, eax
  006e6	75 cc		 jne	 SHORT $LN222@inflateBac@3
  006e8	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  006eb	83 e9 01	 sub	 ecx, 1
  006ee	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  006f1	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  006f4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  006f7	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  006fa	d3 e0		 shl	 eax, cl
  006fc	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  006ff	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00702	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00705	83 c1 01	 add	 ecx, 1
  00708	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0070b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0070e	83 c2 08	 add	 edx, 8
  00711	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00714	33 c0		 xor	 eax, eax
  00716	75 9c		 jne	 SHORT $LN222@inflateBac@3

; 395  :                 }

  00718	e9 6d ff ff ff	 jmp	 $LN228@inflateBac@3
$LN227@inflateBac@3:

; 396  :                 if (here.val < 16) {

  0071d	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00721	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00724	0f 8d b5 00 00
	00		 jge	 $LN217@inflateBac@3
$LN213@inflateBac@3:

; 397  :                     NEEDBITS(here.bits);

  0072a	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  0072e	39 55 e8	 cmp	 DWORD PTR _bits$[ebp], edx
  00731	73 66		 jae	 SHORT $LN215@inflateBac@3
$LN208@inflateBac@3:
  00733	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00737	75 2a		 jne	 SHORT $LN207@inflateBac@3
  00739	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  0073c	50		 push	 eax
  0073d	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00740	51		 push	 ecx
  00741	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00744	83 c4 08	 add	 esp, 8
  00747	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0074a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0074e	75 13		 jne	 SHORT $LN207@inflateBac@3
  00750	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00757	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0075e	e9 4f 0c 00 00	 jmp	 $inf_leave$77633
$LN207@inflateBac@3:
  00763	33 d2		 xor	 edx, edx
  00765	75 cc		 jne	 SHORT $LN208@inflateBac@3
  00767	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0076a	83 e8 01	 sub	 eax, 1
  0076d	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00770	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00773	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00776	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00779	d3 e2		 shl	 edx, cl
  0077b	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  0077e	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00781	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00784	83 c0 01	 add	 eax, 1
  00787	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  0078a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0078d	83 c1 08	 add	 ecx, 8
  00790	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00793	33 d2		 xor	 edx, edx
  00795	75 9c		 jne	 SHORT $LN208@inflateBac@3
  00797	eb 91		 jmp	 SHORT $LN213@inflateBac@3
$LN215@inflateBac@3:
  00799	33 c0		 xor	 eax, eax
  0079b	75 8d		 jne	 SHORT $LN213@inflateBac@3
$LN203@inflateBac@3:

; 398  :                     DROPBITS(here.bits);

  0079d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  007a1	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  007a4	d3 ea		 shr	 edx, cl
  007a6	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  007a9	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  007ad	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007b0	2b c8		 sub	 ecx, eax
  007b2	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  007b5	33 d2		 xor	 edx, edx
  007b7	75 e4		 jne	 SHORT $LN203@inflateBac@3

; 399  :                     state->lens[state->have++] = here.val;

  007b9	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  007bc	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  007bf	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  007c2	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  007c6	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  007cb	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  007ce	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  007d1	83 c2 01	 add	 edx, 1
  007d4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  007d7	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 400  :                 }
; 401  :                 else {

  007da	e9 e1 02 00 00	 jmp	 $LN200@inflateBac@3
$LN217@inflateBac@3:

; 402  :                     if (here.val == 16) {

  007df	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  007e3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  007e6	0f 85 eb 00 00
	00		 jne	 $LN199@inflateBac@3
$LN195@inflateBac@3:

; 403  :                         NEEDBITS(here.bits + 2);

  007ec	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  007f0	83 c2 02	 add	 edx, 2
  007f3	39 55 e8	 cmp	 DWORD PTR _bits$[ebp], edx
  007f6	73 66		 jae	 SHORT $LN197@inflateBac@3
$LN190@inflateBac@3:
  007f8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  007fc	75 2a		 jne	 SHORT $LN189@inflateBac@3
  007fe	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00801	50		 push	 eax
  00802	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00805	51		 push	 ecx
  00806	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00809	83 c4 08	 add	 esp, 8
  0080c	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0080f	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00813	75 13		 jne	 SHORT $LN189@inflateBac@3
  00815	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0081c	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00823	e9 8a 0b 00 00	 jmp	 $inf_leave$77633
$LN189@inflateBac@3:
  00828	33 d2		 xor	 edx, edx
  0082a	75 cc		 jne	 SHORT $LN190@inflateBac@3
  0082c	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0082f	83 e8 01	 sub	 eax, 1
  00832	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00835	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00838	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0083b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0083e	d3 e2		 shl	 edx, cl
  00840	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00843	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00846	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00849	83 c0 01	 add	 eax, 1
  0084c	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  0084f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00852	83 c1 08	 add	 ecx, 8
  00855	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00858	33 d2		 xor	 edx, edx
  0085a	75 9c		 jne	 SHORT $LN190@inflateBac@3
  0085c	eb 8e		 jmp	 SHORT $LN195@inflateBac@3
$LN197@inflateBac@3:
  0085e	33 c0		 xor	 eax, eax
  00860	75 8a		 jne	 SHORT $LN195@inflateBac@3
$LN185@inflateBac@3:

; 404  :                         DROPBITS(here.bits);

  00862	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00866	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00869	d3 ea		 shr	 edx, cl
  0086b	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0086e	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00872	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00875	2b c8		 sub	 ecx, eax
  00877	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0087a	33 d2		 xor	 edx, edx
  0087c	75 e4		 jne	 SHORT $LN185@inflateBac@3

; 405  :                         if (state->have == 0) {

  0087e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00881	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00885	75 18		 jne	 SHORT $LN182@inflateBac@3

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00887	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0088a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 407  :                             state->mode = BAD;

  00891	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00894	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 408  :                             break;

  0089a	e9 26 02 00 00	 jmp	 $LN229@inflateBac@3
$LN182@inflateBac@3:

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  0089f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  008a2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  008a5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  008a8	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  008ad	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 411  :                         copy = 3 + BITS(2);

  008b0	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  008b3	83 e1 03	 and	 ecx, 3
  008b6	83 c1 03	 add	 ecx, 3
  008b9	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN181@inflateBac@3:

; 412  :                         DROPBITS(2);

  008bc	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  008bf	c1 ea 02	 shr	 edx, 2
  008c2	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  008c5	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  008c8	83 e8 02	 sub	 eax, 2
  008cb	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  008ce	33 c9		 xor	 ecx, ecx
  008d0	75 ea		 jne	 SHORT $LN181@inflateBac@3

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  008d2	e9 88 01 00 00	 jmp	 $LN178@inflateBac@3
$LN199@inflateBac@3:
  008d7	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  008db	83 fa 11	 cmp	 edx, 17			; 00000011H
  008de	0f 85 c0 00 00
	00		 jne	 $LN153@inflateBac@3
$LN173@inflateBac@3:

; 415  :                         NEEDBITS(here.bits + 3);

  008e4	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  008e8	83 c0 03	 add	 eax, 3
  008eb	39 45 e8	 cmp	 DWORD PTR _bits$[ebp], eax
  008ee	73 66		 jae	 SHORT $LN175@inflateBac@3
$LN168@inflateBac@3:
  008f0	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  008f4	75 2a		 jne	 SHORT $LN167@inflateBac@3
  008f6	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  008f9	51		 push	 ecx
  008fa	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  008fd	52		 push	 edx
  008fe	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00901	83 c4 08	 add	 esp, 8
  00904	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00907	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0090b	75 13		 jne	 SHORT $LN167@inflateBac@3
  0090d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00914	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0091b	e9 92 0a 00 00	 jmp	 $inf_leave$77633
$LN167@inflateBac@3:
  00920	33 c0		 xor	 eax, eax
  00922	75 cc		 jne	 SHORT $LN168@inflateBac@3
  00924	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00927	83 e9 01	 sub	 ecx, 1
  0092a	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0092d	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00930	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00933	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00936	d3 e0		 shl	 eax, cl
  00938	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0093b	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0093e	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00941	83 c1 01	 add	 ecx, 1
  00944	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00947	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0094a	83 c2 08	 add	 edx, 8
  0094d	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00950	33 c0		 xor	 eax, eax
  00952	75 9c		 jne	 SHORT $LN168@inflateBac@3
  00954	eb 8e		 jmp	 SHORT $LN173@inflateBac@3
$LN175@inflateBac@3:
  00956	33 c9		 xor	 ecx, ecx
  00958	75 8a		 jne	 SHORT $LN173@inflateBac@3
$LN163@inflateBac@3:

; 416  :                         DROPBITS(here.bits);

  0095a	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0095e	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00961	d3 ea		 shr	 edx, cl
  00963	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00966	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0096a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0096d	2b c8		 sub	 ecx, eax
  0096f	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00972	33 d2		 xor	 edx, edx
  00974	75 e4		 jne	 SHORT $LN163@inflateBac@3

; 417  :                         len = 0;

  00976	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 418  :                         copy = 3 + BITS(3);

  0097d	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00980	83 e0 07	 and	 eax, 7
  00983	83 c0 03	 add	 eax, 3
  00986	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN160@inflateBac@3:

; 419  :                         DROPBITS(3);

  00989	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0098c	c1 e9 03	 shr	 ecx, 3
  0098f	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00992	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00995	83 ea 03	 sub	 edx, 3
  00998	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0099b	33 c0		 xor	 eax, eax
  0099d	75 ea		 jne	 SHORT $LN160@inflateBac@3

; 420  :                     }
; 421  :                     else {

  0099f	e9 bb 00 00 00	 jmp	 $LN178@inflateBac@3
$LN153@inflateBac@3:

; 422  :                         NEEDBITS(here.bits + 7);

  009a4	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  009a8	83 c1 07	 add	 ecx, 7
  009ab	39 4d e8	 cmp	 DWORD PTR _bits$[ebp], ecx
  009ae	73 66		 jae	 SHORT $LN155@inflateBac@3
$LN148@inflateBac@3:
  009b0	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  009b4	75 2a		 jne	 SHORT $LN147@inflateBac@3
  009b6	8d 55 e0	 lea	 edx, DWORD PTR _next$[ebp]
  009b9	52		 push	 edx
  009ba	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  009bd	50		 push	 eax
  009be	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  009c1	83 c4 08	 add	 esp, 8
  009c4	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  009c7	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  009cb	75 13		 jne	 SHORT $LN147@inflateBac@3
  009cd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  009d4	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  009db	e9 d2 09 00 00	 jmp	 $inf_leave$77633
$LN147@inflateBac@3:
  009e0	33 c9		 xor	 ecx, ecx
  009e2	75 cc		 jne	 SHORT $LN148@inflateBac@3
  009e4	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  009e7	83 ea 01	 sub	 edx, 1
  009ea	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  009ed	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  009f0	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  009f3	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  009f6	d3 e2		 shl	 edx, cl
  009f8	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  009fb	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  009fe	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00a01	83 c0 01	 add	 eax, 1
  00a04	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00a07	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a0a	83 c1 08	 add	 ecx, 8
  00a0d	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00a10	33 d2		 xor	 edx, edx
  00a12	75 9c		 jne	 SHORT $LN148@inflateBac@3
  00a14	eb 8e		 jmp	 SHORT $LN153@inflateBac@3
$LN155@inflateBac@3:
  00a16	33 c0		 xor	 eax, eax
  00a18	75 8a		 jne	 SHORT $LN153@inflateBac@3
$LN143@inflateBac@3:

; 423  :                         DROPBITS(here.bits);

  00a1a	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00a1e	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00a21	d3 ea		 shr	 edx, cl
  00a23	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00a26	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00a2a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a2d	2b c8		 sub	 ecx, eax
  00a2f	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00a32	33 d2		 xor	 edx, edx
  00a34	75 e4		 jne	 SHORT $LN143@inflateBac@3

; 424  :                         len = 0;

  00a36	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 425  :                         copy = 11 + BITS(7);

  00a3d	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00a40	83 e0 7f	 and	 eax, 127		; 0000007fH
  00a43	83 c0 0b	 add	 eax, 11			; 0000000bH
  00a46	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN140@inflateBac@3:

; 426  :                         DROPBITS(7);

  00a49	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a4c	c1 e9 07	 shr	 ecx, 7
  00a4f	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00a52	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00a55	83 ea 07	 sub	 edx, 7
  00a58	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00a5b	33 c0		 xor	 eax, eax
  00a5d	75 ea		 jne	 SHORT $LN140@inflateBac@3
$LN178@inflateBac@3:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00a5f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a62	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00a65	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  00a68	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a6b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00a6e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a71	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  00a74	3b d1		 cmp	 edx, ecx
  00a76	76 15		 jbe	 SHORT $LN136@inflateBac@3

; 429  :                         strm->msg = (char *)"invalid bit length repeat";

  00a78	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a7b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 430  :                         state->mode = BAD;

  00a82	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a85	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 431  :                         break;

  00a8b	eb 38		 jmp	 SHORT $LN229@inflateBac@3
$LN136@inflateBac@3:

; 432  :                     }
; 433  :                     while (copy--)

  00a8d	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  00a90	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00a93	83 e9 01	 sub	 ecx, 1
  00a96	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
  00a99	85 c0		 test	 eax, eax
  00a9b	74 23		 je	 SHORT $LN200@inflateBac@3

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00a9d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00aa0	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00aa3	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00aa6	66 8b 55 ec	 mov	 dx, WORD PTR _len$[ebp]
  00aaa	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00aaf	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ab2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00ab5	83 c1 01	 add	 ecx, 1
  00ab8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00abb	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  00abe	eb cd		 jmp	 SHORT $LN136@inflateBac@3
$LN200@inflateBac@3:

; 435  :                 }
; 436  :             }

  00ac0	e9 ad fb ff ff	 jmp	 $LN230@inflateBac@3
$LN229@inflateBac@3:

; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00ac5	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ac8	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  00acb	75 05		 jne	 SHORT $LN134@inflateBac@3
  00acd	e9 db 08 00 00	 jmp	 $LN342@inflateBac@3
$LN134@inflateBac@3:

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  00ad2	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ad5	0f b7 91 70 02
	00 00		 movzx	 edx, WORD PTR [ecx+624]
  00adc	85 d2		 test	 edx, edx
  00ade	75 18		 jne	 SHORT $LN133@inflateBac@3

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00ae0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ae3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 444  :                 state->mode = BAD;

  00aea	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00aed	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 445  :                 break;

  00af3	e9 b5 08 00 00	 jmp	 $LN342@inflateBac@3
$LN133@inflateBac@3:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;

  00af8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00afb	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00b01	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b04	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 452  :             state->lencode = (code const FAR *)(state->next);

  00b07	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b0a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b0d	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00b10	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 453  :             state->lenbits = 9;

  00b13	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b16	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  00b1d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b20	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00b26	52		 push	 edx
  00b27	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b2a	83 c0 54	 add	 eax, 84			; 00000054H
  00b2d	50		 push	 eax
  00b2e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b31	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00b34	51		 push	 ecx
  00b35	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b38	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00b3b	50		 push	 eax
  00b3c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b3f	83 c1 70	 add	 ecx, 112		; 00000070H
  00b42	51		 push	 ecx
  00b43	6a 01		 push	 1
  00b45	e8 00 00 00 00	 call	 _inflate_table
  00b4a	83 c4 18	 add	 esp, 24			; 00000018H
  00b4d	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 456  :             if (ret) {

  00b50	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b54	74 18		 je	 SHORT $LN132@inflateBac@3

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  00b56	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b59	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 458  :                 state->mode = BAD;

  00b60	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b63	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 459  :                 break;

  00b69	e9 3f 08 00 00	 jmp	 $LN342@inflateBac@3
$LN132@inflateBac@3:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  00b6e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b71	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b74	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00b77	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 462  :             state->distbits = 6;

  00b7a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b7d	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6

; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  00b84	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b87	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00b8d	52		 push	 edx
  00b8e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b91	83 c0 58	 add	 eax, 88			; 00000058H
  00b94	50		 push	 eax
  00b95	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b98	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00b9b	51		 push	 ecx
  00b9c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b9f	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00ba2	50		 push	 eax
  00ba3	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ba6	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00ba9	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bac	8d 4c 50 70	 lea	 ecx, DWORD PTR [eax+edx*2+112]
  00bb0	51		 push	 ecx
  00bb1	6a 02		 push	 2
  00bb3	e8 00 00 00 00	 call	 _inflate_table
  00bb8	83 c4 18	 add	 esp, 24			; 00000018H
  00bbb	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 465  :             if (ret) {

  00bbe	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00bc2	74 18		 je	 SHORT $LN131@inflateBac@3

; 466  :                 strm->msg = (char *)"invalid distances set";

  00bc4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bc7	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 467  :                 state->mode = BAD;

  00bce	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bd1	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 468  :                 break;

  00bd7	e9 d1 07 00 00	 jmp	 $LN342@inflateBac@3
$LN131@inflateBac@3:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  00bdc	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bdf	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN130@inflateBac@3:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  00be5	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  00be9	0f 82 b4 00 00
	00		 jb	 $LN121@inflateBac@3
  00bef	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00bf6	0f 82 a7 00 00
	00		 jb	 $LN121@inflateBac@3
$LN128@inflateBac@3:

; 476  :                 RESTORE();

  00bfc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bff	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  00c02	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00c05	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c08	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00c0b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00c0e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c11	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00c14	89 08		 mov	 DWORD PTR [eax], ecx
  00c16	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c19	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00c1c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00c1f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c22	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00c25	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  00c28	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c2b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c2e	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00c31	33 d2		 xor	 edx, edx
  00c33	75 c7		 jne	 SHORT $LN128@inflateBac@3

; 477  :                 if (state->whave < state->wsize)

  00c35	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c38	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c3b	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00c3e	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  00c41	73 0f		 jae	 SHORT $LN125@inflateBac@3

; 478  :                     state->whave = state->wsize - left;

  00c43	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c46	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00c49	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  00c4c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c4f	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN125@inflateBac@3:

; 479  :                 inflate_fast(strm, state->wsize);

  00c52	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c55	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00c58	51		 push	 ecx
  00c59	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c5c	52		 push	 edx
  00c5d	e8 00 00 00 00	 call	 _inflate_fast
  00c62	83 c4 08	 add	 esp, 8
$LN124@inflateBac@3:

; 480  :                 LOAD();

  00c65	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c68	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c6b	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00c6e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c71	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00c74	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00c77	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c7a	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c7c	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx
  00c7f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c82	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c85	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00c88	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c8b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00c8e	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c91	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c94	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00c97	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00c9a	33 c0		 xor	 eax, eax
  00c9c	75 c7		 jne	 SHORT $LN124@inflateBac@3

; 481  :                 break;

  00c9e	e9 0a 07 00 00	 jmp	 $LN342@inflateBac@3
$LN121@inflateBac@3:

; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  00ca3	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ca6	ba 01 00 00 00	 mov	 edx, 1
  00cab	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00cae	d3 e2		 shl	 edx, cl
  00cb0	83 ea 01	 sub	 edx, 1
  00cb3	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00cb6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00cb9	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00cbc	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00cbf	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  00cc2	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00cc6	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00cc9	77 02		 ja	 SHORT $LN115@inflateBac@3
  00ccb	eb 69		 jmp	 SHORT $LN120@inflateBac@3
$LN115@inflateBac@3:

; 488  :                 PULLBYTE();

  00ccd	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00cd1	75 2a		 jne	 SHORT $LN114@inflateBac@3
  00cd3	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00cd6	51		 push	 ecx
  00cd7	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00cda	52		 push	 edx
  00cdb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00cde	83 c4 08	 add	 esp, 8
  00ce1	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00ce4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ce8	75 13		 jne	 SHORT $LN114@inflateBac@3
  00cea	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00cf1	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00cf8	e9 b5 06 00 00	 jmp	 $inf_leave$77633
$LN114@inflateBac@3:
  00cfd	33 c0		 xor	 eax, eax
  00cff	75 cc		 jne	 SHORT $LN115@inflateBac@3
  00d01	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00d04	83 e9 01	 sub	 ecx, 1
  00d07	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00d0a	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00d0d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d10	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d13	d3 e0		 shl	 eax, cl
  00d15	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00d18	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00d1b	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00d1e	83 c1 01	 add	 ecx, 1
  00d21	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00d24	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00d27	83 c2 08	 add	 edx, 8
  00d2a	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00d2d	33 c0		 xor	 eax, eax
  00d2f	75 9c		 jne	 SHORT $LN115@inflateBac@3

; 489  :             }

  00d31	e9 6d ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  00d36	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00d3a	85 c9		 test	 ecx, ecx
  00d3c	0f 84 db 00 00
	00		 je	 $LN95@inflateBac@3
  00d42	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00d46	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00d4c	0f 85 cb 00 00
	00		 jne	 $LN95@inflateBac@3

; 491  :                 last = here;

  00d52	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  00d55	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN109@inflateBac@3:

; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  00d58	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  00d5c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d60	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  00d64	03 c8		 add	 ecx, eax
  00d66	b8 01 00 00 00	 mov	 eax, 1
  00d6b	d3 e0		 shl	 eax, cl
  00d6d	83 e8 01	 sub	 eax, 1
  00d70	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  00d73	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d77	d3 e8		 shr	 eax, cl
  00d79	03 d0		 add	 edx, eax
  00d7b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00d7e	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00d81	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00d84	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00d87	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  00d8b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00d8f	03 d0		 add	 edx, eax
  00d91	3b 55 e8	 cmp	 edx, DWORD PTR _bits$[ebp]
  00d94	77 02		 ja	 SHORT $LN103@inflateBac@3
  00d96	eb 69		 jmp	 SHORT $LN98@inflateBac@3
$LN103@inflateBac@3:

; 496  :                     PULLBYTE();

  00d98	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d9c	75 2a		 jne	 SHORT $LN102@inflateBac@3
  00d9e	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00da1	51		 push	 ecx
  00da2	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00da5	52		 push	 edx
  00da6	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00da9	83 c4 08	 add	 esp, 8
  00dac	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00daf	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00db3	75 13		 jne	 SHORT $LN102@inflateBac@3
  00db5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00dbc	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00dc3	e9 ea 05 00 00	 jmp	 $inf_leave$77633
$LN102@inflateBac@3:
  00dc8	33 c0		 xor	 eax, eax
  00dca	75 cc		 jne	 SHORT $LN103@inflateBac@3
  00dcc	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00dcf	83 e9 01	 sub	 ecx, 1
  00dd2	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00dd5	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00dd8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ddb	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00dde	d3 e0		 shl	 eax, cl
  00de0	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00de3	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00de6	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00de9	83 c1 01	 add	 ecx, 1
  00dec	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00def	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00df2	83 c2 08	 add	 edx, 8
  00df5	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00df8	33 c0		 xor	 eax, eax
  00dfa	75 9c		 jne	 SHORT $LN103@inflateBac@3

; 497  :                 }

  00dfc	e9 57 ff ff ff	 jmp	 $LN109@inflateBac@3
$LN98@inflateBac@3:

; 498  :                 DROPBITS(last.bits);

  00e01	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00e05	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00e08	d3 ea		 shr	 edx, cl
  00e0a	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00e0d	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  00e11	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e14	2b c8		 sub	 ecx, eax
  00e16	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00e19	33 d2		 xor	 edx, edx
  00e1b	75 e4		 jne	 SHORT $LN98@inflateBac@3
$LN95@inflateBac@3:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  00e1d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00e21	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00e24	d3 e8		 shr	 eax, cl
  00e26	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00e29	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00e2d	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00e30	2b d1		 sub	 edx, ecx
  00e32	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00e35	33 c0		 xor	 eax, eax
  00e37	75 e4		 jne	 SHORT $LN95@inflateBac@3

; 501  :             state->length = (unsigned)here.val;

  00e39	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00e3d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e40	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  00e43	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  00e47	85 c0		 test	 eax, eax
  00e49	75 72		 jne	 SHORT $LN92@inflateBac@3
$LN91@inflateBac@3:

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  00e4b	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00e4f	75 3d		 jne	 SHORT $LN90@inflateBac@3
  00e51	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e54	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00e57	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx
  00e5a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e5d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00e60	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx
  00e63	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e66	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00e69	89 42 2c	 mov	 DWORD PTR [edx+44], eax
  00e6c	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00e6f	51		 push	 ecx
  00e70	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e73	52		 push	 edx
  00e74	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00e77	50		 push	 eax
  00e78	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00e7b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e7e	85 c0		 test	 eax, eax
  00e80	74 0c		 je	 SHORT $LN90@inflateBac@3
  00e82	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00e89	e9 24 05 00 00	 jmp	 $inf_leave$77633
$LN90@inflateBac@3:
  00e8e	33 c9		 xor	 ecx, ecx
  00e90	75 b9		 jne	 SHORT $LN91@inflateBac@3

; 509  :                 *put++ = (unsigned char)(state->length);

  00e92	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e95	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e98	8a 48 40	 mov	 cl, BYTE PTR [eax+64]
  00e9b	88 0a		 mov	 BYTE PTR [edx], cl
  00e9d	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00ea0	83 c2 01	 add	 edx, 1
  00ea3	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 510  :                 left--;

  00ea6	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00ea9	83 e8 01	 sub	 eax, 1
  00eac	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax

; 511  :                 state->mode = LEN;

  00eaf	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00eb2	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 512  :                 break;

  00eb8	e9 f0 04 00 00	 jmp	 $LN342@inflateBac@3
$LN92@inflateBac@3:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  00ebd	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00ec1	83 e2 20	 and	 edx, 32			; 00000020H
  00ec4	74 0e		 je	 SHORT $LN86@inflateBac@3

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  00ec6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ec9	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 519  :                 break;

  00ecf	e9 d9 04 00 00	 jmp	 $LN342@inflateBac@3
$LN86@inflateBac@3:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  00ed4	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00ed8	83 e1 40	 and	 ecx, 64			; 00000040H
  00edb	74 18		 je	 SHORT $LN85@inflateBac@3

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  00edd	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ee0	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 525  :                 state->mode = BAD;

  00ee7	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00eea	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 526  :                 break;

  00ef0	e9 b8 04 00 00	 jmp	 $LN342@inflateBac@3
$LN85@inflateBac@3:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  00ef5	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00ef9	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00efc	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00eff	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 531  :             if (state->extra != 0) {

  00f02	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f05	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00f09	0f 84 b2 00 00
	00		 je	 $LN67@inflateBac@3
$LN80@inflateBac@3:

; 532  :                 NEEDBITS(state->extra);

  00f0f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f12	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00f15	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00f18	73 66		 jae	 SHORT $LN82@inflateBac@3
$LN75@inflateBac@3:
  00f1a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f1e	75 2a		 jne	 SHORT $LN74@inflateBac@3
  00f20	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00f23	50		 push	 eax
  00f24	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00f27	51		 push	 ecx
  00f28	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00f2b	83 c4 08	 add	 esp, 8
  00f2e	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00f31	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f35	75 13		 jne	 SHORT $LN74@inflateBac@3
  00f37	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00f3e	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00f45	e9 68 04 00 00	 jmp	 $inf_leave$77633
$LN74@inflateBac@3:
  00f4a	33 d2		 xor	 edx, edx
  00f4c	75 cc		 jne	 SHORT $LN75@inflateBac@3
  00f4e	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00f51	83 e8 01	 sub	 eax, 1
  00f54	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00f57	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00f5a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00f5d	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f60	d3 e2		 shl	 edx, cl
  00f62	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00f65	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00f68	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00f6b	83 c0 01	 add	 eax, 1
  00f6e	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00f71	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f74	83 c1 08	 add	 ecx, 8
  00f77	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00f7a	33 d2		 xor	 edx, edx
  00f7c	75 9c		 jne	 SHORT $LN75@inflateBac@3
  00f7e	eb 8f		 jmp	 SHORT $LN80@inflateBac@3
$LN82@inflateBac@3:
  00f80	33 c0		 xor	 eax, eax
  00f82	75 8b		 jne	 SHORT $LN80@inflateBac@3

; 533  :                 state->length += BITS(state->extra);

  00f84	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f87	ba 01 00 00 00	 mov	 edx, 1
  00f8c	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  00f8f	d3 e2		 shl	 edx, cl
  00f91	83 ea 01	 sub	 edx, 1
  00f94	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00f97	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f9a	03 50 40	 add	 edx, DWORD PTR [eax+64]
  00f9d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00fa0	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN70@inflateBac@3:

; 534  :                 DROPBITS(state->extra);

  00fa3	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00fa6	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00fa9	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00fac	d3 e8		 shr	 eax, cl
  00fae	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00fb1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00fb4	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00fb7	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  00fba	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00fbd	33 c0		 xor	 eax, eax
  00fbf	75 e2		 jne	 SHORT $LN70@inflateBac@3
$LN67@inflateBac@3:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  00fc1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00fc4	ba 01 00 00 00	 mov	 edx, 1
  00fc9	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00fcc	d3 e2		 shl	 edx, cl
  00fce	83 ea 01	 sub	 edx, 1
  00fd1	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00fd4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00fd7	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00fda	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00fdd	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  00fe0	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00fe4	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00fe7	77 02		 ja	 SHORT $LN61@inflateBac@3
  00fe9	eb 69		 jmp	 SHORT $LN66@inflateBac@3
$LN61@inflateBac@3:

; 542  :                 PULLBYTE();

  00feb	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00fef	75 2a		 jne	 SHORT $LN60@inflateBac@3
  00ff1	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00ff4	51		 push	 ecx
  00ff5	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00ff8	52		 push	 edx
  00ff9	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00ffc	83 c4 08	 add	 esp, 8
  00fff	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01002	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01006	75 13		 jne	 SHORT $LN60@inflateBac@3
  01008	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0100f	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01016	e9 97 03 00 00	 jmp	 $inf_leave$77633
$LN60@inflateBac@3:
  0101b	33 c0		 xor	 eax, eax
  0101d	75 cc		 jne	 SHORT $LN61@inflateBac@3
  0101f	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01022	83 e9 01	 sub	 ecx, 1
  01025	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01028	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0102b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0102e	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01031	d3 e0		 shl	 eax, cl
  01033	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  01036	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01039	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0103c	83 c1 01	 add	 ecx, 1
  0103f	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  01042	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01045	83 c2 08	 add	 edx, 8
  01048	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0104b	33 c0		 xor	 eax, eax
  0104d	75 9c		 jne	 SHORT $LN61@inflateBac@3

; 543  :             }

  0104f	e9 6d ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 544  :             if ((here.op & 0xf0) == 0) {

  01054	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  01058	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0105e	0f 85 cb 00 00
	00		 jne	 $LN41@inflateBac@3

; 545  :                 last = here;

  01064	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  01067	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN55@inflateBac@3:

; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  0106a	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  0106e	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01072	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  01076	03 ca		 add	 ecx, edx
  01078	ba 01 00 00 00	 mov	 edx, 1
  0107d	d3 e2		 shl	 edx, cl
  0107f	83 ea 01	 sub	 edx, 1
  01082	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  01085	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01089	d3 ea		 shr	 edx, cl
  0108b	03 c2		 add	 eax, edx
  0108d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01090	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01093	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01096	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01099	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0109d	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  010a1	03 ca		 add	 ecx, edx
  010a3	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  010a6	77 02		 ja	 SHORT $LN49@inflateBac@3
  010a8	eb 69		 jmp	 SHORT $LN44@inflateBac@3
$LN49@inflateBac@3:

; 550  :                     PULLBYTE();

  010aa	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  010ae	75 2a		 jne	 SHORT $LN48@inflateBac@3
  010b0	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  010b3	50		 push	 eax
  010b4	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  010b7	51		 push	 ecx
  010b8	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  010bb	83 c4 08	 add	 esp, 8
  010be	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  010c1	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  010c5	75 13		 jne	 SHORT $LN48@inflateBac@3
  010c7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  010ce	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  010d5	e9 d8 02 00 00	 jmp	 $inf_leave$77633
$LN48@inflateBac@3:
  010da	33 d2		 xor	 edx, edx
  010dc	75 cc		 jne	 SHORT $LN49@inflateBac@3
  010de	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  010e1	83 e8 01	 sub	 eax, 1
  010e4	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  010e7	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  010ea	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  010ed	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010f0	d3 e2		 shl	 edx, cl
  010f2	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  010f5	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  010f8	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  010fb	83 c0 01	 add	 eax, 1
  010fe	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01101	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01104	83 c1 08	 add	 ecx, 8
  01107	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0110a	33 d2		 xor	 edx, edx
  0110c	75 9c		 jne	 SHORT $LN49@inflateBac@3

; 551  :                 }

  0110e	e9 57 ff ff ff	 jmp	 $LN55@inflateBac@3
$LN44@inflateBac@3:

; 552  :                 DROPBITS(last.bits);

  01113	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01117	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0111a	d3 e8		 shr	 eax, cl
  0111c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0111f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01123	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01126	2b d1		 sub	 edx, ecx
  01128	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0112b	33 c0		 xor	 eax, eax
  0112d	75 e4		 jne	 SHORT $LN44@inflateBac@3
$LN41@inflateBac@3:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  0112f	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01133	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01136	d3 ea		 shr	 edx, cl
  01138	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0113b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0113f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01142	2b c8		 sub	 ecx, eax
  01144	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01147	33 d2		 xor	 edx, edx
  01149	75 e4		 jne	 SHORT $LN41@inflateBac@3

; 555  :             if (here.op & 64) {

  0114b	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  0114f	83 e0 40	 and	 eax, 64			; 00000040H
  01152	74 18		 je	 SHORT $LN38@inflateBac@3

; 556  :                 strm->msg = (char *)"invalid distance code";

  01154	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01157	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 557  :                 state->mode = BAD;

  0115e	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01161	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 558  :                 break;

  01167	e9 41 02 00 00	 jmp	 $LN342@inflateBac@3
$LN38@inflateBac@3:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  0116c	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  01170	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01173	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  01176	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0117a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0117d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01180	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 564  :             if (state->extra != 0) {

  01183	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01186	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  0118a	0f 84 b2 00 00
	00		 je	 $LN37@inflateBac@3
$LN33@inflateBac@3:

; 565  :                 NEEDBITS(state->extra);

  01190	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01193	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  01196	3b 42 48	 cmp	 eax, DWORD PTR [edx+72]
  01199	73 66		 jae	 SHORT $LN35@inflateBac@3
$LN28@inflateBac@3:
  0119b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0119f	75 2a		 jne	 SHORT $LN27@inflateBac@3
  011a1	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  011a4	51		 push	 ecx
  011a5	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  011a8	52		 push	 edx
  011a9	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  011ac	83 c4 08	 add	 esp, 8
  011af	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  011b2	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  011b6	75 13		 jne	 SHORT $LN27@inflateBac@3
  011b8	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  011bf	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  011c6	e9 e7 01 00 00	 jmp	 $inf_leave$77633
$LN27@inflateBac@3:
  011cb	33 c0		 xor	 eax, eax
  011cd	75 cc		 jne	 SHORT $LN28@inflateBac@3
  011cf	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  011d2	83 e9 01	 sub	 ecx, 1
  011d5	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  011d8	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  011db	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011de	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  011e1	d3 e0		 shl	 eax, cl
  011e3	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  011e6	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  011e9	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  011ec	83 c1 01	 add	 ecx, 1
  011ef	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  011f2	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  011f5	83 c2 08	 add	 edx, 8
  011f8	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  011fb	33 c0		 xor	 eax, eax
  011fd	75 9c		 jne	 SHORT $LN28@inflateBac@3
  011ff	eb 8f		 jmp	 SHORT $LN33@inflateBac@3
$LN35@inflateBac@3:
  01201	33 c9		 xor	 ecx, ecx
  01203	75 8b		 jne	 SHORT $LN33@inflateBac@3

; 566  :                 state->offset += BITS(state->extra);

  01205	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01208	b8 01 00 00 00	 mov	 eax, 1
  0120d	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  01210	d3 e0		 shl	 eax, cl
  01212	83 e8 01	 sub	 eax, 1
  01215	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  01218	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0121b	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  0121e	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01221	89 42 44	 mov	 DWORD PTR [edx+68], eax
$LN23@inflateBac@3:

; 567  :                 DROPBITS(state->extra);

  01224	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01227	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0122a	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0122d	d3 ea		 shr	 edx, cl
  0122f	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01232	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01235	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01238	2b 48 48	 sub	 ecx, DWORD PTR [eax+72]
  0123b	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0123e	33 d2		 xor	 edx, edx
  01240	75 e2		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  01242	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01245	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01248	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0124b	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  0124e	1b c0		 sbb	 eax, eax
  01250	23 45 e4	 and	 eax, DWORD PTR _left$[ebp]
  01253	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01256	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  01259	2b d0		 sub	 edx, eax
  0125b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0125e	39 50 44	 cmp	 DWORD PTR [eax+68], edx
  01261	76 18		 jbe	 SHORT $LN16@inflateBac@3

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  01263	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01266	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 572  :                 state->mode = BAD;

  0126d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01270	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 573  :                 break;

  01276	e9 32 01 00 00	 jmp	 $LN342@inflateBac@3
$LN16@inflateBac@3:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  0127b	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0127f	75 3d		 jne	 SHORT $LN15@inflateBac@3
  01281	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01284	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01287	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  0128a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0128d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  01290	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  01293	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01296	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01299	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  0129c	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0129f	50		 push	 eax
  012a0	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  012a3	51		 push	 ecx
  012a4	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  012a7	52		 push	 edx
  012a8	ff 55 14	 call	 DWORD PTR _out$[ebp]
  012ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  012ae	85 c0		 test	 eax, eax
  012b0	74 0c		 je	 SHORT $LN15@inflateBac@3
  012b2	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  012b9	e9 f4 00 00 00	 jmp	 $inf_leave$77633
$LN15@inflateBac@3:
  012be	33 c0		 xor	 eax, eax
  012c0	75 b9		 jne	 SHORT $LN16@inflateBac@3

; 580  :                 copy = state->wsize - state->offset;

  012c2	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012c5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  012c8	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  012cb	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  012ce	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 581  :                 if (copy < left) {

  012d1	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  012d4	3b 4d e4	 cmp	 ecx, DWORD PTR _left$[ebp]
  012d7	73 14		 jae	 SHORT $LN11@inflateBac@3

; 582  :                     from = put + copy;

  012d9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  012dc	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  012df	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 583  :                     copy = left - copy;

  012e2	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  012e5	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  012e8	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 584  :                 }
; 585  :                 else {

  012eb	eb 12		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 586  :                     from = put - state->offset;

  012ed	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012f0	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  012f3	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  012f6	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 587  :                     copy = left;

  012f9	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  012fc	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN10@inflateBac@3:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  012ff	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01302	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  01305	3b 51 40	 cmp	 edx, DWORD PTR [ecx+64]
  01308	76 09		 jbe	 SHORT $LN9@inflateBac@3
  0130a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0130d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01310	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN9@inflateBac@3:

; 590  :                 state->length -= copy;

  01313	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01316	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  01319	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  0131c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0131f	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 591  :                 left -= copy;

  01322	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01325	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  01328	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx
$LN8@inflateBac@3:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  0132b	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  0132e	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  01331	8a 11		 mov	 dl, BYTE PTR [ecx]
  01333	88 10		 mov	 BYTE PTR [eax], dl
  01335	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01338	83 c0 01	 add	 eax, 1
  0133b	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  0133e	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  01341	83 c1 01	 add	 ecx, 1
  01344	89 4d d0	 mov	 DWORD PTR _from$[ebp], ecx

; 594  :                 } while (--copy);

  01347	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  0134a	83 ea 01	 sub	 edx, 1
  0134d	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
  01350	75 d9		 jne	 SHORT $LN8@inflateBac@3

; 595  :             } while (state->length != 0);

  01352	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01355	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  01359	0f 85 1c ff ff
	ff		 jne	 $LN16@inflateBac@3

; 596  :             break;

  0135f	eb 4c		 jmp	 SHORT $LN342@inflateBac@3
$LN5@inflateBac@3:

; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;

  01361	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 601  :             if (left < state->wsize) {

  01368	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0136b	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  0136e	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  01371	73 26		 jae	 SHORT $LN4@inflateBac@3

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  01373	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01376	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01379	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  0137c	51		 push	 ecx
  0137d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01380	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01383	50		 push	 eax
  01384	8b 4d 18	 mov	 ecx, DWORD PTR _out_desc$[ebp]
  01387	51		 push	 ecx
  01388	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0138b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0138e	85 c0		 test	 eax, eax
  01390	74 07		 je	 SHORT $LN4@inflateBac@3

; 603  :                     ret = Z_BUF_ERROR;

  01392	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN4@inflateBac@3:

; 604  :             }
; 605  :             goto inf_leave;

  01399	eb 17		 jmp	 SHORT $inf_leave$77633
$LN2@inflateBac@3:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  0139b	c7 45 dc fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 609  :             goto inf_leave;

  013a2	eb 0e		 jmp	 SHORT $inf_leave$77633
$LN1@inflateBac@3:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  013a4	c7 45 dc fe ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  013ab	eb 05		 jmp	 SHORT $inf_leave$77633
$LN342@inflateBac@3:

; 613  :             goto inf_leave;
; 614  :         }

  013ad	e9 e3 ec ff ff	 jmp	 $LN345@inflateBac@3
$inf_leave$77633:

; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  013b2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  013b5	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  013b8	89 02		 mov	 DWORD PTR [edx], eax

; 619  :     strm->avail_in = have;

  013ba	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  013bd	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  013c0	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 620  :     return ret;

  013c3	8b 45 dc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN348@inflateBac@3:

; 621  : }

  013c6	8b e5		 mov	 esp, ebp
  013c8	5d		 pop	 ebp
  013c9	c2 14 00	 ret	 20			; 00000014H
$LN353@inflateBac@3:
  013cc	00 00 00 00	 DD	 $LN341@inflateBac@3
  013d0	00 00 00 00	 DD	 $LN310@inflateBac@3
  013d4	00 00 00 00	 DD	 $LN272@inflateBac@3
  013d8	00 00 00 00	 DD	 $LN130@inflateBac@3
  013dc	00 00 00 00	 DD	 $LN5@inflateBac@3
  013e0	00 00 00 00	 DD	 $LN2@inflateBac@3
  013e4	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN352@inflateBac@3:
  013e8	00		 DB	 0
  013e9	06		 DB	 6
  013ea	01		 DB	 1
  013eb	06		 DB	 6
  013ec	06		 DB	 6
  013ed	02		 DB	 2
  013ee	06		 DB	 6
  013ef	06		 DB	 6
  013f0	06		 DB	 6
  013f1	03		 DB	 3
  013f2	06		 DB	 6
  013f3	06		 DB	 6
  013f4	06		 DB	 6
  013f5	06		 DB	 6
  013f6	06		 DB	 6
  013f7	06		 DB	 6
  013f8	06		 DB	 6
  013f9	04		 DB	 4
  013fa	05		 DB	 5
  013fb	90		 npad	 1
$LN354@inflateBac@3:
  013fc	00 00 00 00	 DD	 $LN318@inflateBac@3
  01400	00 00 00 00	 DD	 $LN317@inflateBac@3
  01404	00 00 00 00	 DD	 $LN316@inflateBac@3
  01408	00 00 00 00	 DD	 $LN315@inflateBac@3
_inflateBack@20 ENDP
END
