; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\lp_solve_5.5\xli\xli_ZIMPL\ziboptVS10\thirdparty\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateMark@4
; Function compile flags: /Odtp
; File d:\lp_solve_5.5\xli\xli_zimpl\ziboptvs10\thirdparty\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv77 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN1@inflateMar
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 07		 jne	 SHORT $LN2@inflateMar
$LN1@inflateMar:
  00015	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  0001a	eb 54		 jmp	 SHORT $LN3@inflateMar
$LN2@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00025	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00028	83 38 0f	 cmp	 DWORD PTR [eax], 15	; 0000000fH
  0002b	75 0b		 jne	 SHORT $LN7@inflateMar
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00033	89 55 f8	 mov	 DWORD PTR tv77[ebp], edx
  00036	eb 29		 jmp	 SHORT $LN8@inflateMar
$LN7@inflateMar:
  00038	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	83 38 18	 cmp	 DWORD PTR [eax], 24	; 00000018H
  0003e	75 14		 jne	 SHORT $LN5@inflateMar
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00046	8b 81 c8 1b 00
	00		 mov	 eax, DWORD PTR [ecx+7112]
  0004c	2b 42 40	 sub	 eax, DWORD PTR [edx+64]
  0004f	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00052	eb 07		 jmp	 SHORT $LN6@inflateMar
$LN5@inflateMar:
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN6@inflateMar:
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  0005e	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN8@inflateMar:
  00061	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00064	8b 82 c4 1b 00
	00		 mov	 eax, DWORD PTR [edx+7108]
  0006a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006d	03 45 f8	 add	 eax, DWORD PTR tv77[ebp]
$LN3@inflateMar:

; 1480 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateUndermine@8
; Function compile flags: /Odtp
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN1@inflateUnd
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN2@inflateUnd
$LN1@inflateUnd:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 2d		 jmp	 SHORT $LN3@inflateUnd
$LN2@inflateUnd:

; 1460 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1461 :     state->sane = !subvert;

  00023	33 c0		 xor	 eax, eax
  00025	83 7d 0c 00	 cmp	 DWORD PTR _subvert$[ebp], 0
  00029	0f 94 c0	 sete	 al
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	89 81 c0 1b 00
	00		 mov	 DWORD PTR [ecx+7104], eax

; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	c7 82 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+7104], 1

; 1466 :     return Z_DATA_ERROR;

  00042	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
$LN3@inflateUnd:

; 1467 : #endif
; 1468 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateCopy@8
; Function compile flags: /Odtp
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_copy$ = -12						; size = 4
_wsize$ = -8						; size = 4
_window$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1409 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00006	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  0000a	74 21		 je	 SHORT $LN6@inflateCop
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  00010	74 1b		 je	 SHORT $LN6@inflateCop
  00012	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00015	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00019	74 12		 je	 SHORT $LN6@inflateCop
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0001e	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00022	74 09		 je	 SHORT $LN6@inflateCop
  00024	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00027	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002b	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1418 :         return Z_STREAM_ERROR;

  0002d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00032	e9 85 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1419 :     state = (struct inflate_state FAR *)source->state;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0003a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003d	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx

; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00040	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00045	6a 01		 push	 1
  00047	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  0004a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00051	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00054	ff d2		 call	 edx
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0005c	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00060	75 0a		 jne	 SHORT $LN5@inflateCop
  00062	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00067	e9 50 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1425 :     window = Z_NULL;

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 1426 :     if (state->window != Z_NULL) {

  00073	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00076	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007a	74 4b		 je	 SHORT $LN4@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007c	6a 01		 push	 1
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00089	d3 e2		 shl	 edx, cl
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0008f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00092	51		 push	 ecx
  00093	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00096	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00099	ff d0		 call	 eax
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 45 fc	 mov	 DWORD PTR _window$[ebp], eax

; 1429 :         if (window == Z_NULL) {

  000a1	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  000a5	75 20		 jne	 SHORT $LN4@inflateCop

; 1430 :             ZFREE(source, copy);

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  000ae	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b1	50		 push	 eax
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000b5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b8	ff d2		 call	 edx
  000ba	83 c4 08	 add	 esp, 8

; 1431 :             return Z_MEM_ERROR;

  000bd	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000c2	e9 f5 00 00 00	 jmp	 $LN8@inflateCop
$LN4@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  000c7	6a 38		 push	 56			; 00000038H
  000c9	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _memcpy
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  000d9	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000de	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000e1	52		 push	 edx
  000e2	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memcpy
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fa	39 4a 4c	 cmp	 DWORD PTR [edx+76], ecx
  000fd	72 58		 jb	 SHORT $LN2@inflateCop
  000ff	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00102	05 bc 1b 00 00	 add	 eax, 7100		; 00001bbcH
  00107	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0010a	39 41 4c	 cmp	 DWORD PTR [ecx+76], eax
  0010d	77 48		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  0010f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00112	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00118	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0011b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0011e	2b ca		 sub	 ecx, edx
  00120	c1 f9 02	 sar	 ecx, 2
  00123	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00126	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00130	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00133	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00136	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  0013c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00142	2b ca		 sub	 ecx, edx
  00144	c1 f9 02	 sar	 ecx, 2
  00147	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0014a	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00151	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00154	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  00157	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0015a	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00160	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00163	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00166	2b ca		 sub	 ecx, edx
  00168	c1 f9 02	 sar	 ecx, 2
  0016b	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0016e	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00178	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 1444 :     if (window != Z_NULL) {

  0017b	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  0017f	74 27		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  00181	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0018c	d3 e0		 shl	 eax, cl
  0018e	89 45 f8	 mov	 DWORD PTR _wsize$[ebp], eax

; 1446 :         zmemcpy(window, state->window, wsize);

  00191	8b 4d f8	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00194	51		 push	 ecx
  00195	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00198	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0019b	50		 push	 eax
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _window$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _memcpy
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;

  001a8	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001ab	8b 45 fc	 mov	 eax, DWORD PTR _window$[ebp]
  001ae	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1449 :     dest->state = (struct internal_state FAR *)copy;

  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  001b4	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001b7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1450 :     return Z_OK;

  001ba	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1451 : }

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint@4
; Function compile flags: /Odtp
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
tv71 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN1@inflateSyn
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 07		 jne	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	eb 2d		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1402 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1403 :     return state->mode == STORED && state->bits == 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00028	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  0002b	75 12		 jne	 SHORT $LN5@inflateSyn
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00034	75 09		 jne	 SHORT $LN5@inflateSyn
  00036	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0003d	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN5@inflateSyn:
  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN6@inflateSyn:
  00046	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
$LN3@inflateSyn:

; 1404 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _syncsearch
_TEXT	SEGMENT
_got$ = -8						; size = 4
_next$ = -4						; size = 4
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00006	8b 45 08	 mov	 eax, DWORD PTR _have$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _got$[ebp], ecx

; 1331 :     next = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN6@syncsearch:

; 1332 :     while (next < len && got < 4) {

  00015	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00018	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0001b	73 5c		 jae	 SHORT $LN5@syncsearch
  0001d	83 7d f8 04	 cmp	 DWORD PTR _got$[ebp], 4
  00021	73 56		 jae	 SHORT $LN5@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00026	03 45 fc	 add	 eax, DWORD PTR _next$[ebp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002c	83 7d f8 02	 cmp	 DWORD PTR _got$[ebp], 2
  00030	1b d2		 sbb	 edx, edx
  00032	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00038	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003e	3b ca		 cmp	 ecx, edx
  00040	75 0b		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
  0004b	eb 21		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00050	03 4d fc	 add	 ecx, DWORD PTR _next$[ebp]
  00053	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00056	85 d2		 test	 edx, edx
  00058	74 09		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0

; 1337 :         else

  00061	eb 0b		 jmp	 SHORT $LN3@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  00063	b8 04 00 00 00	 mov	 eax, 4
  00068	2b 45 f8	 sub	 eax, DWORD PTR _got$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
$LN3@syncsearch:

; 1339 :         next++;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00071	83 c1 01	 add	 ecx, 1
  00074	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 1340 :     }

  00077	eb 9c		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1341 :     *have = got;

  00079	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  0007f	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :     return next;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]

; 1343 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
PUBLIC	_inflateGetHeader@8
; Function compile flags: /Odtp
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN2@inflateGet
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN3@inflateGet
$LN2@inflateGet:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 30		 jmp	 SHORT $LN4@inflateGet
$LN3@inflateGet:

; 1302 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00026	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00029	83 e1 02	 and	 ecx, 2
  0002c	75 07		 jne	 SHORT $LN1@inflateGet
  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	eb 15		 jmp	 SHORT $LN4@inflateGet
$LN1@inflateGet:

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0003b	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 1307 :     head->done = 0;

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00041	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1308 :     return Z_OK;

  00048	33 c0		 xor	 eax, eax
$LN4@inflateGet:

; 1309 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd@4
; Function compile flags: /Odtp
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 12		 je	 SHORT $LN2@inflateEnd
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	74 09		 je	 SHORT $LN2@inflateEnd
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00016	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001a	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	eb 50		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1244 :     state = (struct inflate_state FAR *)strm->state;

  00023	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00033	74 19		 je	 SHORT $LN1@inflateEnd
  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00046	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00049	ff d1		 call	 ecx
  0004b	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  0004e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00051	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00058	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0005b	52		 push	 edx
  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00062	ff d1		 call	 ecx
  00064	83 c4 08	 add	 esp, 8

; 1247 :     strm->state = Z_NULL;

  00067	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0006a	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  00071	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1250 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_state$ = -12						; size = 4
_copy$ = -8						; size = 4
_dist$ = -4						; size = 4
_strm$ = 8						; size = 4
_out$ = 12						; size = 4
_updatewindow PROC					; COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000c	89 4d f4	 mov	 DWORD PTR _state$[ebp], ecx

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0000f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00012	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00016	75 3b		 jne	 SHORT $LN10@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00018	6a 01		 push	 1
  0001a	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00025	d3 e2		 shl	 edx, cl
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00035	ff d0		 call	 eax
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 372  :         if (state->window == Z_NULL) return 1;

  00040	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00043	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00047	75 0a		 jne	 SHORT $LN10@updatewind
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	e9 4a 01 00 00	 jmp	 $LN11@updatewind
$LN10@updatewind:

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  00053	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00056	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0005a	75 27		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00067	d3 e2		 shl	 edx, cl
  00069	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 378  :         state->wnext = 0;

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 379  :         state->whave = 0;

  00079	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0
$LN8@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  00083	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00089	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0008c	89 4d f8	 mov	 DWORD PTR _copy$[ebp], ecx

; 384  :     if (copy >= state->wsize) {

  0008f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00092	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00095	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00098	72 3e		 jb	 SHORT $LN7@updatewind

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0009d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000a7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000aa	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  000ad	52		 push	 edx
  000ae	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000b1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 386  :         state->wnext = 0;

  000bd	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000c0	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 387  :         state->whave = state->wsize;

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000ca	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000cd	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000d0	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 388  :     }
; 389  :     else {

  000d3	e9 c3 00 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 390  :         dist = state->wsize - state->wnext;

  000d8	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000db	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000de	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  000e1	2b 51 30	 sub	 edx, DWORD PTR [ecx+48]
  000e4	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx

; 391  :         if (dist > copy) dist = copy;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _dist$[ebp]
  000ea	3b 45 f8	 cmp	 eax, DWORD PTR _copy$[ebp]
  000ed	76 06		 jbe	 SHORT $LN5@updatewind
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  000f2	89 4d fc	 mov	 DWORD PTR _dist$[ebp], ecx
$LN5@updatewind:

; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  000f5	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000fc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ff	2b 4d f8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00106	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00109	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0010c	03 41 30	 add	 eax, DWORD PTR [ecx+48]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _memcpy
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  :         copy -= dist;

  00118	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  0011b	2b 55 fc	 sub	 edx, DWORD PTR _dist$[ebp]
  0011e	89 55 f8	 mov	 DWORD PTR _copy$[ebp], edx

; 394  :         if (copy) {

  00121	74 34		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  00123	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0012a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0012d	2b 55 f8	 sub	 edx, DWORD PTR _copy$[ebp]
  00130	52		 push	 edx
  00131	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00134	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 396  :             state->wnext = copy;

  00140	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00143	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00146	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 397  :             state->whave = state->wsize;

  00149	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0014c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0014f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00152	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 398  :         }
; 399  :         else {

  00155	eb 44		 jmp	 SHORT $LN6@updatewind
$LN4@updatewind:

; 400  :             state->wnext += dist;

  00157	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0015a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0015d	03 55 fc	 add	 edx, DWORD PTR _dist$[ebp]
  00160	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00163	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  00166	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00169	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0016c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0016f	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00172	75 0a		 jne	 SHORT $LN2@updatewind
  00174	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00177	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN2@updatewind:

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  0017e	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00181	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00184	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00187	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0018a	73 0f		 jae	 SHORT $LN6@updatewind
  0018c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0018f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00192	03 45 fc	 add	 eax, DWORD PTR _dist$[ebp]
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00198	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN6@updatewind:

; 403  :         }
; 404  :     }
; 405  :     return 0;

  0019b	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 406  : }

  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 278  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 279  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 280  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 281  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflatePrime@12
; Function compile flags: /Odtp
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN4@inflatePri
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN5@inflatePri
$LN4@inflatePri:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 7d		 jmp	 SHORT $LN6@inflatePri
$LN5@inflatePri:

; 217  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 218  :     if (bits < 0) {

  00023	83 7d 0c 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00027	7d 18		 jge	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002c	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 220  :         state->bits = 0;

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00036	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 221  :         return Z_OK;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 56		 jmp	 SHORT $LN6@inflatePri
$LN3@inflatePri:

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00041	83 7d 0c 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00045	7f 0e		 jg	 SHORT $LN1@inflatePri
  00047	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0004d	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  00050	83 f8 20	 cmp	 eax, 32			; 00000020H
  00053	76 07		 jbe	 SHORT $LN2@inflatePri
$LN1@inflatePri:
  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	eb 3b		 jmp	 SHORT $LN6@inflatePri
$LN2@inflatePri:

; 224  :     value &= (1L << bits) - 1;

  0005c	ba 01 00 00 00	 mov	 edx, 1
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00064	d3 e2		 shl	 edx, cl
  00066	83 ea 01	 sub	 edx, 1
  00069	23 55 10	 and	 edx, DWORD PTR _value$[ebp]
  0006c	89 55 10	 mov	 DWORD PTR _value$[ebp], edx

; 225  :     state->hold += value << state->bits;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00072	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp]
  00075	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00078	d3 e2		 shl	 edx, cl
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007d	03 50 38	 add	 edx, DWORD PTR [eax+56]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 226  :     state->bits += bits;

  00086	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00089	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0008c	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00092	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 227  :     return Z_OK;

  00095	33 c0		 xor	 eax, eax
$LN6@inflatePri:

; 228  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset@4
; Function compile flags: /Odtp
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN1@inflateRes
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 0a		 jne	 SHORT $LN2@inflateRes
$LN1@inflateRes:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 e0 00 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 109  :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00029	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00033	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0003a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 111  :     strm->msg = Z_NULL;

  00044	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00047	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00051	c7 41 30 01 00
	00 00		 mov	 DWORD PTR [ecx+48], 1

; 113  :     state->mode = HEAD;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 114  :     state->last = 0;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00064	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 115  :     state->havedict = 0;

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 116  :     state->dmax = 32768U;

  00075	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00078	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [edx+20], 32768 ; 00008000H

; 117  :     state->head = Z_NULL;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00082	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 118  :     state->wsize = 0;

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008c	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 119  :     state->whave = 0;

  00093	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00096	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 120  :     state->wnext = 0;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a0	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 121  :     state->hold = 0;

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000aa	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 122  :     state->bits = 0;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 123  :     state->lencode = state->distcode = state->next = state->codes;

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000be	05 30 05 00 00	 add	 eax, 1328		; 00000530H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000cf	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  000d2	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000db	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000de	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 124  :     state->sane = 1;

  000e1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	c7 82 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+7104], 1

; 125  :     state->back = -1;

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	c7 80 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7108], -1

; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  000fb	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 128  : }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
_inflateReset@4 ENDP
PUBLIC	_inflateSync@4
; Function compile flags: /Odtp
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$ = -20						; size = 4
_out$ = -16						; size = 4
_buf$ = -12						; size = 4
_len$ = -8						; size = 4
_in$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN6@inflateSyn@2
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN7@inflateSyn@2
$LN6@inflateSyn@2:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 61 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN7@inflateSyn@2:

; 1355 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 ec	 mov	 DWORD PTR _state$[ebp], edx

; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	75 13		 jne	 SHORT $LN5@inflateSyn@2
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00038	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0003a	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0003f	e9 3c 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN5@inflateSyn@2:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  00044	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 3a 1f	 cmp	 DWORD PTR [edx], 31	; 0000001fH
  0004a	0f 84 9e 00 00
	00		 je	 $LN4@inflateSyn@2

; 1360 :         state->mode = SYNC;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00053	c7 00 1f 00 00
	00		 mov	 DWORD PTR [eax], 31	; 0000001fH

; 1361 :         state->hold <<= state->bits & 7;

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0005c	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0005f	83 e1 07	 and	 ecx, 7
  00062	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00065	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00068	d3 e0		 shl	 eax, cl
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1362 :         state->bits -= state->bits & 7;

  00070	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00073	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00076	83 e0 07	 and	 eax, 7
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007f	2b d0		 sub	 edx, eax
  00081	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00084	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1363 :         len = 0;

  00087	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN3@inflateSyn@2:

; 1364 :         while (state->bits >= 8) {

  0008e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00091	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00095	72 36		 jb	 SHORT $LN2@inflateSyn@2

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  00097	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8a 48 38	 mov	 cl, BYTE PTR [eax+56]
  000a0	88 4c 15 f4	 mov	 BYTE PTR _buf$[ebp+edx], cl
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 1366 :             state->hold >>= 8;

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b3	c1 e9 08	 shr	 ecx, 8
  000b6	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000b9	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 1367 :             state->bits -= 8;

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000c2	83 e9 08	 sub	 ecx, 8
  000c5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1368 :         }

  000cb	eb c1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1369 :         state->have = 0;

  000cd	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 1370 :         syncsearch(&(state->have), buf, len);

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  000da	51		 push	 ecx
  000db	8d 55 f4	 lea	 edx, DWORD PTR _buf$[ebp]
  000de	52		 push	 edx
  000df	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000e2	83 c0 68	 add	 eax, 104		; 00000068H
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _syncsearch
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@inflateSyn@2:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000fe	83 c2 68	 add	 edx, 104		; 00000068H
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 _syncsearch
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1375 :     strm->avail_in -= len;

  0010d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	2b 4d f8	 sub	 ecx, DWORD PTR _len$[ebp]
  00116	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00119	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1376 :     strm->next_in += len;

  0011c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00124	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00127	89 0a		 mov	 DWORD PTR [edx], ecx

; 1377 :     strm->total_in += len;

  00129	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0012c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012f	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00132	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00135	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  00138	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0013b	83 78 68 04	 cmp	 DWORD PTR [eax+104], 4
  0013f	74 07		 je	 SHORT $LN1@inflateSyn@2
  00141	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00146	eb 38		 jmp	 SHORT $LN8@inflateSyn@2
$LN1@inflateSyn@2:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0014b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0014e	89 55 fc	 mov	 DWORD PTR _in$[ebp], edx
  00151	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00154	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00157	89 4d f0	 mov	 DWORD PTR _out$[ebp], ecx

; 1382 :     inflateReset(strm);

  0015a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _inflateReset@4

; 1383 :     strm->total_in = in;  strm->total_out = out;

  00163	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  00169	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0016c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0016f	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  00172	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1384 :     state->mode = TYPE;

  00175	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00178	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1385 :     return Z_OK;

  0017e	33 c0		 xor	 eax, eax
$LN8@inflateSyn@2:

; 1386 : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateSetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_id$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN7@inflateSet
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN8@inflateSet
$LN7@inflateSet:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 fb 00 00 00	 jmp	 $LN9@inflateSet
$LN8@inflateSet:

; 1262 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  00028	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002f	74 12		 je	 SHORT $LN6@inflateSet
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 39 0a	 cmp	 DWORD PTR [ecx], 10	; 0000000aH
  00037	74 0a		 je	 SHORT $LN6@inflateSet

; 1264 :         return Z_STREAM_ERROR;

  00039	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003e	e9 d7 00 00 00	 jmp	 $LN9@inflateSet
$LN6@inflateSet:

; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  00043	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00046	83 3a 0a	 cmp	 DWORD PTR [edx], 10	; 0000000aH
  00049	75 37		 jne	 SHORT $LN5@inflateSet

; 1268 :         id = adler32(0L, Z_NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 _adler32@12
  00056	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 1269 :         id = adler32(id, dictionary, dictLength);

  00059	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 fc	 mov	 edx, DWORD PTR _id$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _adler32@12
  0006a	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 1270 :         if (id != state->check)

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _id$[ebp]
  00073	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00076	74 0a		 je	 SHORT $LN5@inflateSet

; 1271 :             return Z_DATA_ERROR;

  00078	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0007d	e9 98 00 00 00	 jmp	 $LN9@inflateSet
$LN5@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  00082	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00085	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _updatewindow
  00092	83 c4 08	 add	 esp, 8
  00095	85 c0		 test	 eax, eax
  00097	74 10		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  00099	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0009c	c7 02 1e 00 00
	00		 mov	 DWORD PTR [edx], 30	; 0000001eH

; 1277 :         return Z_MEM_ERROR;

  000a2	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000a7	eb 71		 jmp	 SHORT $LN9@inflateSet
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  000af	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  000b2	76 31		 jbe	 SHORT $LN2@inflateSet

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b7	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  000be	03 4d 10	 add	 ecx, DWORD PTR _dictLength$[ebp]
  000c1	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000c4	2b 4a 28	 sub	 ecx, DWORD PTR [edx+40]
  000c7	51		 push	 ecx
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cb	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1282 :         state->whave = state->wsize;

  000d7	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000da	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dd	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000e0	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1283 :     }
; 1284 :     else {

  000e3	eb 29		 jmp	 SHORT $LN1@inflateSet
$LN2@inflateSet:

; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  000e5	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  000e8	52		 push	 edx
  000e9	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000f0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000f6	03 50 28	 add	 edx, DWORD PTR [eax+40]
  000f9	2b 55 10	 sub	 edx, DWORD PTR _dictLength$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _memcpy
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1287 :         state->whave = dictLength;

  00105	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00108	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  0010b	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
$LN1@inflateSet:

; 1288 :     }
; 1289 :     state->havedict = 1;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00111	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  00118	33 c0		 xor	 eax, eax
$LN9@inflateSet:

; 1292 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflate@8
; Function compile flags: /Odtp
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv1334 = -92						; size = 4
tv1322 = -88						; size = 4
tv1249 = -84						; size = 4
tv1235 = -80						; size = 4
tv556 = -76						; size = 4
tv351 = -72						; size = 4
tv80 = -68						; size = 4
_state$ = -64						; size = 4
_out$ = -60						; size = 4
_from$ = -56						; size = 4
_copy$ = -52						; size = 4
_hbuf$ = -48						; size = 4
_hold$ = -44						; size = 4
_ret$ = -40						; size = 4
_next$ = -36						; size = 4
_left$ = -32						; size = 4
_bits$ = -28						; size = 4
_len$ = -24						; size = 4
_in$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 23		 je	 SHORT $LN506@inflate
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	74 1a		 je	 SHORT $LN506@inflate
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00018	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0001c	74 11		 je	 SHORT $LN506@inflate
  0001e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00021	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00024	75 13		 jne	 SHORT $LN507@inflate
  00026	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00029	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002d	74 0a		 je	 SHORT $LN507@inflate
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 8e 1f 00 00	 jmp	 $LN508@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003f	89 55 c0	 mov	 DWORD PTR _state$[ebp], edx

; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00042	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00045	83 38 0b	 cmp	 DWORD PTR [eax], 11	; 0000000bH
  00048	75 09		 jne	 SHORT $LN504@inflate
  0004a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN504@inflate:

; 618  :     LOAD();

  00053	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00056	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00059	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00062	89 55 e0	 mov	 DWORD PTR _left$[ebp], edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00076	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00079	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0007c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0007f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00082	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00085	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00088	33 d2		 xor	 edx, edx
  0008a	75 c7		 jne	 SHORT $LN504@inflate

; 619  :     in = have;

  0008c	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0008f	89 45 ec	 mov	 DWORD PTR _in$[ebp], eax

; 620  :     out = left;

  00092	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00095	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 621  :     ret = Z_OK;

  00098	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN501@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  0009f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	8b 02		 mov	 eax, DWORD PTR [edx]
  000a4	89 45 bc	 mov	 DWORD PTR tv80[ebp], eax
  000a7	83 7d bc 1e	 cmp	 DWORD PTR tv80[ebp], 30	; 0000001eH
  000ab	0f 87 6b 1d 00
	00		 ja	 $LN11@inflate
  000b1	8b 4d bc	 mov	 ecx, DWORD PTR tv80[ebp]
  000b4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN520@inflate[ecx*4]
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  000bb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000be	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000c2	75 0e		 jne	 SHORT $LN492@inflate

; 626  :                 state->mode = TYPEDO;

  000c4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 627  :                 break;

  000cd	e9 54 1d 00 00	 jmp	 $LN498@inflate
$LN492@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  000d2	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  000d6	73 3d		 jae	 SHORT $LN494@inflate
$LN490@inflate:
  000d8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  000dc	75 05		 jne	 SHORT $LN487@inflate
  000de	e9 48 1d 00 00	 jmp	 $inf_leave$77705
$LN487@inflate:
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  000ec	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  000ef	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  000f5	d3 e0		 shl	 eax, cl
  000f7	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  000fa	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  000fd	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00100	83 c1 01	 add	 ecx, 1
  00103	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00106	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00109	83 c2 08	 add	 edx, 8
  0010c	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0010f	33 c0		 xor	 eax, eax
  00111	75 c5		 jne	 SHORT $LN490@inflate
  00113	eb bd		 jmp	 SHORT $LN492@inflate
$LN494@inflate:
  00115	33 c9		 xor	 ecx, ecx
  00117	75 b9		 jne	 SHORT $LN492@inflate

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00119	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0011c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011f	83 e0 02	 and	 eax, 2
  00122	74 65		 je	 SHORT $LN486@inflate
  00124	81 7d d4 1f 8b
	00 00		 cmp	 DWORD PTR _hold$[ebp], 35615 ; 00008b1fH
  0012b	75 5c		 jne	 SHORT $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 _crc32@12
  00138	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0013b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN485@inflate:

; 633  :                 CRC2(state->check, hold);

  0013e	8a 55 d4	 mov	 dl, BYTE PTR _hold$[ebp]
  00141	88 55 d0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00144	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00147	c1 e8 08	 shr	 eax, 8
  0014a	88 45 d1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0014d	6a 02		 push	 2
  0014f	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00156	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _crc32@12
  0015f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00162	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00165	33 d2		 xor	 edx, edx
  00167	75 d5		 jne	 SHORT $LN485@inflate
$LN482@inflate:

; 634  :                 INITBITS();

  00169	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00170	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00177	33 c0		 xor	 eax, eax
  00179	75 ee		 jne	 SHORT $LN482@inflate

; 635  :                 state->mode = FLAGS;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0017e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 636  :                 break;

  00184	e9 9d 1c 00 00	 jmp	 $LN498@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */

  00189	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0018c	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 639  :             if (state->head != Z_NULL)

  00193	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00196	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0019a	74 0d		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  0019c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0019f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001a2	c7 42 30 ff ff
	ff ff		 mov	 DWORD PTR [edx+48], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  001a9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001af	83 e1 01	 and	 ecx, 1
  001b2	74 20		 je	 SHORT $LN477@inflate
  001b4	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  001b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001bc	c1 e0 08	 shl	 eax, 8
  001bf	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  001c2	c1 ea 08	 shr	 edx, 8
  001c5	03 c2		 add	 eax, edx
  001c7	33 d2		 xor	 edx, edx
  001c9	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  001ce	f7 f1		 div	 ecx
  001d0	85 d2		 test	 edx, edx
  001d2	74 18		 je	 SHORT $LN478@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  001d4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d7	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 647  :                 state->mode = BAD;

  001de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001e1	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 648  :                 break;

  001e7	e9 3a 1c 00 00	 jmp	 $LN498@inflate
$LN478@inflate:

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  001ec	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  001ef	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f2	83 f9 08	 cmp	 ecx, 8
  001f5	74 18		 je	 SHORT $LN475@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  001f7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001fa	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 652  :                 state->mode = BAD;

  00201	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00204	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 653  :                 break;

  0020a	e9 17 1c 00 00	 jmp	 $LN498@inflate
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);

  0020f	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00212	c1 e9 04	 shr	 ecx, 4
  00215	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00218	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0021b	83 ea 04	 sub	 edx, 4
  0021e	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00221	33 c0		 xor	 eax, eax
  00223	75 ea		 jne	 SHORT $LN475@inflate

; 656  :             len = BITS(4) + 8;

  00225	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00228	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0022b	83 c1 08	 add	 ecx, 8
  0022e	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx

; 657  :             if (state->wbits == 0)

  00231	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00234	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00238	75 0b		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  0023a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0023d	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00240	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  00243	eb 23		 jmp	 SHORT $LN471@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  00245	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00248	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  0024b	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0024e	76 18		 jbe	 SHORT $LN471@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  00250	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00253	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 661  :                 state->mode = BAD;

  0025a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0025d	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 662  :                 break;

  00263	e9 be 1b 00 00	 jmp	 $LN498@inflate
$LN471@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  00268	b8 01 00 00 00	 mov	 eax, 1
  0026d	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00270	d3 e0		 shl	 eax, cl
  00272	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00275	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	6a 00		 push	 0
  0027e	e8 00 00 00 00	 call	 _adler32@12
  00283	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00286	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00289	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0028c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0028f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00292	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00295	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00298	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0029d	f7 d8		 neg	 eax
  0029f	1b c0		 sbb	 eax, eax
  002a1	83 e0 fe	 and	 eax, -2			; fffffffeH
  002a4	83 c0 0b	 add	 eax, 11			; 0000000bH
  002a7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002aa	89 01		 mov	 DWORD PTR [ecx], eax
$LN469@inflate:

; 668  :             INITBITS();

  002ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002b3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002ba	33 d2		 xor	 edx, edx
  002bc	75 ee		 jne	 SHORT $LN469@inflate

; 669  :             break;

  002be	e9 63 1b 00 00	 jmp	 $LN498@inflate
$LN462@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  002c3	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  002c7	73 3d		 jae	 SHORT $LN464@inflate
$LN460@inflate:
  002c9	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  002cd	75 05		 jne	 SHORT $LN457@inflate
  002cf	e9 57 1b 00 00	 jmp	 $inf_leave$77705
$LN457@inflate:
  002d4	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  002d7	83 e8 01	 sub	 eax, 1
  002da	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  002dd	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  002e0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002e3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  002e6	d3 e2		 shl	 edx, cl
  002e8	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  002eb	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  002ee	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  002f1	83 c0 01	 add	 eax, 1
  002f4	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  002f7	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  002fa	83 c1 08	 add	 ecx, 8
  002fd	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00300	33 d2		 xor	 edx, edx
  00302	75 c5		 jne	 SHORT $LN460@inflate
  00304	eb bd		 jmp	 SHORT $LN462@inflate
$LN464@inflate:
  00306	33 c0		 xor	 eax, eax
  00308	75 b9		 jne	 SHORT $LN462@inflate

; 673  :             state->flags = (int)(hold);

  0030a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0030d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00310	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00313	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00316	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00319	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0031f	83 f9 08	 cmp	 ecx, 8
  00322	74 18		 je	 SHORT $LN456@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  00324	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00327	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 676  :                 state->mode = BAD;

  0032e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00331	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 677  :                 break;

  00337	e9 ea 1a 00 00	 jmp	 $LN498@inflate
$LN456@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  0033c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0033f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00342	81 e2 00 e0 00
	00		 and	 edx, 57344		; 0000e000H
  00348	74 18		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0034a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0034d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 681  :                 state->mode = BAD;

  00354	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00357	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 682  :                 break;

  0035d	e9 c4 1a 00 00	 jmp	 $LN498@inflate
$LN455@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00362	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00365	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00369	74 11		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  0036b	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0036e	c1 e8 08	 shr	 eax, 8
  00371	83 e0 01	 and	 eax, 1
  00374	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00377	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0037a	89 02		 mov	 DWORD PTR [edx], eax
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0037c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0037f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00382	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00388	74 2b		 je	 SHORT $LN449@inflate
$LN452@inflate:
  0038a	8a 55 d4	 mov	 dl, BYTE PTR _hold$[ebp]
  0038d	88 55 d0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00390	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00393	c1 e8 08	 shr	 eax, 8
  00396	88 45 d1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00399	6a 02		 push	 2
  0039b	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  0039e	51		 push	 ecx
  0039f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  003a2	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 _crc32@12
  003ab	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ae	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  003b1	33 d2		 xor	 edx, edx
  003b3	75 d5		 jne	 SHORT $LN452@inflate
$LN449@inflate:

; 687  :             INITBITS();

  003b5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  003bc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  003c3	33 c0		 xor	 eax, eax
  003c5	75 ee		 jne	 SHORT $LN449@inflate

; 688  :             state->mode = TIME;

  003c7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ca	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN442@inflate:

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  003d0	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  003d4	73 3d		 jae	 SHORT $LN444@inflate
$LN440@inflate:
  003d6	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  003da	75 05		 jne	 SHORT $LN437@inflate
  003dc	e9 4a 1a 00 00	 jmp	 $inf_leave$77705
$LN437@inflate:
  003e1	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  003e4	83 ea 01	 sub	 edx, 1
  003e7	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  003ea	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  003ed	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  003f0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  003f3	d3 e2		 shl	 edx, cl
  003f5	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  003f8	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  003fb	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  003fe	83 c0 01	 add	 eax, 1
  00401	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00404	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00407	83 c1 08	 add	 ecx, 8
  0040a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0040d	33 d2		 xor	 edx, edx
  0040f	75 c5		 jne	 SHORT $LN440@inflate
  00411	eb bd		 jmp	 SHORT $LN442@inflate
$LN444@inflate:
  00413	33 c0		 xor	 eax, eax
  00415	75 b9		 jne	 SHORT $LN442@inflate

; 691  :             if (state->head != Z_NULL)

  00417	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0041a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0041e	74 0c		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  00420	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00423	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00426	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00429	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0042c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0042f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00432	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00437	74 3d		 je	 SHORT $LN431@inflate
$LN434@inflate:
  00439	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  0043c	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  0043f	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00442	c1 ea 08	 shr	 edx, 8
  00445	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00448	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0044b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0044e	88 45 d2	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00451	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00454	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00457	88 4d d3	 mov	 BYTE PTR _hbuf$[ebp+3], cl
  0045a	6a 04		 push	 4
  0045c	8d 55 d0	 lea	 edx, DWORD PTR _hbuf$[ebp]
  0045f	52		 push	 edx
  00460	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00463	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00466	51		 push	 ecx
  00467	e8 00 00 00 00	 call	 _crc32@12
  0046c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0046f	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00472	33 c0		 xor	 eax, eax
  00474	75 c3		 jne	 SHORT $LN434@inflate
$LN431@inflate:

; 694  :             INITBITS();

  00476	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0047d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00484	33 c9		 xor	 ecx, ecx
  00486	75 ee		 jne	 SHORT $LN431@inflate

; 695  :             state->mode = OS;

  00488	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0048b	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3
$LN424@inflate:

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  00491	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00495	73 3d		 jae	 SHORT $LN426@inflate
$LN422@inflate:
  00497	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0049b	75 05		 jne	 SHORT $LN419@inflate
  0049d	e9 89 19 00 00	 jmp	 $inf_leave$77705
$LN419@inflate:
  004a2	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  004a5	83 e8 01	 sub	 eax, 1
  004a8	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  004ab	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  004ae	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  004b1	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  004b4	d3 e2		 shl	 edx, cl
  004b6	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  004b9	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  004bc	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  004bf	83 c0 01	 add	 eax, 1
  004c2	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  004c5	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  004c8	83 c1 08	 add	 ecx, 8
  004cb	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  004ce	33 d2		 xor	 edx, edx
  004d0	75 c5		 jne	 SHORT $LN422@inflate
  004d2	eb bd		 jmp	 SHORT $LN424@inflate
$LN426@inflate:
  004d4	33 c0		 xor	 eax, eax
  004d6	75 b9		 jne	 SHORT $LN424@inflate

; 698  :             if (state->head != Z_NULL) {

  004d8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  004db	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  004df	74 21		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  004e1	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  004e4	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004ea	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004ed	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004f0	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 700  :                 state->head->os = (int)(hold >> 8);

  004f3	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  004f6	c1 ea 08	 shr	 edx, 8
  004f9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004fc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004ff	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00502	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00505	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00508	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0050d	74 2b		 je	 SHORT $LN413@inflate
$LN416@inflate:
  0050f	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  00512	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  00515	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00518	c1 ea 08	 shr	 edx, 8
  0051b	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0051e	6a 02		 push	 2
  00520	8d 45 d0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00523	50		 push	 eax
  00524	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00527	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0052a	52		 push	 edx
  0052b	e8 00 00 00 00	 call	 _crc32@12
  00530	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00533	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00536	33 d2		 xor	 edx, edx
  00538	75 d5		 jne	 SHORT $LN416@inflate
$LN413@inflate:

; 703  :             INITBITS();

  0053a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00541	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00548	33 c0		 xor	 eax, eax
  0054a	75 ee		 jne	 SHORT $LN413@inflate

; 704  :             state->mode = EXLEN;

  0054c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0054f	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  00555	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00558	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0055b	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00560	0f 84 b1 00 00
	00		 je	 $LN409@inflate
$LN405@inflate:

; 707  :                 NEEDBITS(16);

  00566	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0056a	73 3d		 jae	 SHORT $LN407@inflate
$LN403@inflate:
  0056c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00570	75 05		 jne	 SHORT $LN400@inflate
  00572	e9 b4 18 00 00	 jmp	 $inf_leave$77705
$LN400@inflate:
  00577	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0057a	83 e9 01	 sub	 ecx, 1
  0057d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00580	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00583	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00586	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00589	d3 e0		 shl	 eax, cl
  0058b	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  0058e	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00591	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00594	83 c1 01	 add	 ecx, 1
  00597	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0059a	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0059d	83 c2 08	 add	 edx, 8
  005a0	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  005a3	33 c0		 xor	 eax, eax
  005a5	75 c5		 jne	 SHORT $LN403@inflate
  005a7	eb bd		 jmp	 SHORT $LN405@inflate
$LN407@inflate:
  005a9	33 c9		 xor	 ecx, ecx
  005ab	75 b9		 jne	 SHORT $LN405@inflate

; 708  :                 state->length = (unsigned)(hold);

  005ad	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005b0	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  005b3	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 709  :                 if (state->head != Z_NULL)

  005b6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005b9	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  005bd	74 0c		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  005bf	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005c2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005c5	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  005c8	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  005cb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005ce	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  005d1	25 00 02 00 00	 and	 eax, 512		; 00000200H
  005d6	74 2b		 je	 SHORT $LN394@inflate
$LN397@inflate:
  005d8	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  005db	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  005de	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  005e1	c1 ea 08	 shr	 edx, 8
  005e4	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  005e7	6a 02		 push	 2
  005e9	8d 45 d0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  005ec	50		 push	 eax
  005ed	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005f0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005f3	52		 push	 edx
  005f4	e8 00 00 00 00	 call	 _crc32@12
  005f9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005fc	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  005ff	33 d2		 xor	 edx, edx
  00601	75 d5		 jne	 SHORT $LN397@inflate
$LN394@inflate:

; 712  :                 INITBITS();

  00603	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0060a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00611	33 c0		 xor	 eax, eax
  00613	75 ee		 jne	 SHORT $LN394@inflate

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  00615	eb 16		 jmp	 SHORT $LN391@inflate
$LN409@inflate:
  00617	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0061a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0061e	74 0d		 je	 SHORT $LN391@inflate

; 715  :                 state->head->extra = Z_NULL;

  00620	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00623	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00626	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN391@inflate:

; 716  :             state->mode = EXTRA;

  0062d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00630	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  00636	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00639	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0063c	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00641	0f 84 e4 00 00
	00		 je	 $LN388@inflate

; 719  :                 copy = state->length;

  00647	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0064a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0064d	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 720  :                 if (copy > have) copy = have;

  00650	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00653	3b 45 f0	 cmp	 eax, DWORD PTR _have$[ebp]
  00656	76 06		 jbe	 SHORT $LN387@inflate
  00658	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0065b	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN387@inflate:

; 721  :                 if (copy) {

  0065e	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00662	0f 84 b5 00 00
	00		 je	 $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  00668	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0066b	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0066f	74 63		 je	 SHORT $LN385@inflate
  00671	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00674	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00677	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0067b	74 57		 je	 SHORT $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  0067d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00680	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00683	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00686	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00689	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  0068c	89 55 e8	 mov	 DWORD PTR _len$[ebp], edx

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  0068f	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  00692	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00695	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00698	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0069b	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0069e	76 11		 jbe	 SHORT $LN510@inflate
  006a0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006a3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  006a6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006a9	2b 55 e8	 sub	 edx, DWORD PTR _len$[ebp]
  006ac	89 55 b8	 mov	 DWORD PTR tv351[ebp], edx
  006af	eb 06		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  006b1	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  006b4	89 45 b8	 mov	 DWORD PTR tv351[ebp], eax
$LN511@inflate:
  006b7	8b 4d b8	 mov	 ecx, DWORD PTR tv351[ebp]
  006ba	51		 push	 ecx
  006bb	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  006be	52		 push	 edx
  006bf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006c2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  006c5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006c8	03 55 e8	 add	 edx, DWORD PTR _len$[ebp]
  006cb	52		 push	 edx
  006cc	e8 00 00 00 00	 call	 _memcpy
  006d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  006d4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006d7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006da	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  006e0	74 1a		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  006e2	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  006e5	52		 push	 edx
  006e6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  006e9	50		 push	 eax
  006ea	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006ed	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006f0	52		 push	 edx
  006f1	e8 00 00 00 00	 call	 _crc32@12
  006f6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006f9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN384@inflate:

; 731  :                     have -= copy;

  006fc	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  006ff	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00702	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 732  :                     next += copy;

  00705	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00708	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  0070b	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 733  :                     state->length -= copy;

  0070e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00711	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00714	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00717	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0071a	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  0071d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00720	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00724	74 05		 je	 SHORT $LN388@inflate
  00726	e9 00 17 00 00	 jmp	 $inf_leave$77705
$LN388@inflate:

; 736  :             }
; 737  :             state->length = 0;

  0072b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0072e	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 738  :             state->mode = NAME;

  00735	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00738	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  0073e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00741	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00744	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0074a	0f 84 c6 00 00
	00		 je	 $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  00750	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00754	75 05		 jne	 SHORT $LN380@inflate
  00756	e9 d0 16 00 00	 jmp	 $inf_leave$77705
$LN380@inflate:

; 742  :                 copy = 0;

  0075b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN379@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00762	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00765	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00768	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0076b	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx
  0076e	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00771	83 c2 01	 add	 edx, 1
  00774	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00777	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0077a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0077e	74 41		 je	 SHORT $LN378@inflate
  00780	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00783	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00786	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0078a	74 35		 je	 SHORT $LN378@inflate
  0078c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0078f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00792	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00795	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00798	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  0079b	73 24		 jae	 SHORT $LN378@inflate

; 748  :                         state->head->name[state->length++] = len;

  0079d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007a0	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  007a3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  007a6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007a9	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  007ac	8a 4d e8	 mov	 cl, BYTE PTR _len$[ebp]
  007af	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  007b2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  007b5	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  007b8	83 c0 01	 add	 eax, 1
  007bb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007be	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN378@inflate:

; 749  :                 } while (len && copy < have);

  007c1	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  007c5	74 08		 je	 SHORT $LN377@inflate
  007c7	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007ca	3b 55 f0	 cmp	 edx, DWORD PTR _have$[ebp]
  007cd	72 93		 jb	 SHORT $LN379@inflate
$LN377@inflate:

; 750  :                 if (state->flags & 0x0200)

  007cf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  007d2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  007d5	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  007db	74 1a		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  007dd	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007e0	52		 push	 edx
  007e1	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  007e4	50		 push	 eax
  007e5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007e8	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  007eb	52		 push	 edx
  007ec	e8 00 00 00 00	 call	 _crc32@12
  007f1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007f4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN374@inflate:

; 752  :                 have -= copy;

  007f7	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  007fa	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  007fd	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 753  :                 next += copy;

  00800	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00803	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00806	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 754  :                 if (len) goto inf_leave;

  00809	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0080d	74 05		 je	 SHORT $LN373@inflate
  0080f	e9 17 16 00 00	 jmp	 $inf_leave$77705
$LN373@inflate:

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  00814	eb 16		 jmp	 SHORT $LN372@inflate
$LN381@inflate:
  00816	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00819	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0081d	74 0d		 je	 SHORT $LN372@inflate

; 757  :                 state->head->name = Z_NULL;

  0081f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00822	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00825	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN372@inflate:

; 758  :             state->length = 0;

  0082c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0082f	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 759  :             state->mode = COMMENT;

  00836	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00839	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  0083f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00842	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00845	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0084b	0f 84 c5 00 00
	00		 je	 $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  00851	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00855	75 05		 jne	 SHORT $LN368@inflate
  00857	e9 cf 15 00 00	 jmp	 $inf_leave$77705
$LN368@inflate:

; 763  :                 copy = 0;

  0085c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN367@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  00863	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00866	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00869	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0086c	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax
  0086f	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00872	83 c1 01	 add	 ecx, 1
  00875	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  00878	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0087b	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0087f	74 41		 je	 SHORT $LN366@inflate
  00881	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00884	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00887	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0088b	74 35		 je	 SHORT $LN366@inflate
  0088d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00890	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00893	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00896	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00899	3b 50 28	 cmp	 edx, DWORD PTR [eax+40]
  0089c	73 24		 jae	 SHORT $LN366@inflate

; 769  :                         state->head->comment[state->length++] = len;

  0089e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008a1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  008a4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  008a7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008aa	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  008ad	8a 45 e8	 mov	 al, BYTE PTR _len$[ebp]
  008b0	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  008b3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  008b6	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  008b9	83 c2 01	 add	 edx, 1
  008bc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008bf	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN366@inflate:

; 770  :                 } while (len && copy < have);

  008c2	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  008c6	74 08		 je	 SHORT $LN365@inflate
  008c8	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008cb	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  008ce	72 93		 jb	 SHORT $LN367@inflate
$LN365@inflate:

; 771  :                 if (state->flags & 0x0200)

  008d0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008d3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  008d6	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008db	74 1a		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  008dd	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008e0	51		 push	 ecx
  008e1	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  008e4	52		 push	 edx
  008e5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008e8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  008eb	51		 push	 ecx
  008ec	e8 00 00 00 00	 call	 _crc32@12
  008f1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008f4	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN362@inflate:

; 773  :                 have -= copy;

  008f7	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  008fa	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  008fd	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax

; 774  :                 next += copy;

  00900	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00903	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  00906	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx

; 775  :                 if (len) goto inf_leave;

  00909	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0090d	74 05		 je	 SHORT $LN361@inflate
  0090f	e9 17 15 00 00	 jmp	 $inf_leave$77705
$LN361@inflate:

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00914	eb 16		 jmp	 SHORT $LN360@inflate
$LN369@inflate:
  00916	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00919	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0091d	74 0d		 je	 SHORT $LN360@inflate

; 778  :                 state->head->comment = Z_NULL;

  0091f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00922	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00925	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$LN360@inflate:

; 779  :             state->mode = HCRC;

  0092c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0092f	c7 02 08 00 00
	00		 mov	 DWORD PTR [edx], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00935	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00938	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0093b	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00941	0f 84 82 00 00
	00		 je	 $LN357@inflate
$LN353@inflate:

; 782  :                 NEEDBITS(16);

  00947	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0094b	73 3d		 jae	 SHORT $LN355@inflate
$LN351@inflate:
  0094d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00951	75 05		 jne	 SHORT $LN348@inflate
  00953	e9 d3 14 00 00	 jmp	 $inf_leave$77705
$LN348@inflate:
  00958	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0095b	83 ea 01	 sub	 edx, 1
  0095e	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00961	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00964	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00967	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0096a	d3 e2		 shl	 edx, cl
  0096c	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0096f	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00972	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00975	83 c0 01	 add	 eax, 1
  00978	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0097b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0097e	83 c1 08	 add	 ecx, 8
  00981	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00984	33 d2		 xor	 edx, edx
  00986	75 c5		 jne	 SHORT $LN351@inflate
  00988	eb bd		 jmp	 SHORT $LN353@inflate
$LN355@inflate:
  0098a	33 c0		 xor	 eax, eax
  0098c	75 b9		 jne	 SHORT $LN353@inflate

; 783  :                 if (hold != (state->check & 0xffff)) {

  0098e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00991	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00994	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0099a	39 55 d4	 cmp	 DWORD PTR _hold$[ebp], edx
  0099d	74 18		 je	 SHORT $LN346@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  0099f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  009a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 785  :                     state->mode = BAD;

  009a9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009ac	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 786  :                     break;

  009b2	e9 6f 14 00 00	 jmp	 $LN498@inflate
$LN346@inflate:

; 787  :                 }
; 788  :                 INITBITS();

  009b7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  009be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  009c5	33 d2		 xor	 edx, edx
  009c7	75 ee		 jne	 SHORT $LN346@inflate
$LN357@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  009c9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009cc	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  009d0	74 22		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  009d2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009d5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  009d8	c1 fa 09	 sar	 edx, 9
  009db	83 e2 01	 and	 edx, 1
  009de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009e1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  009e4	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 792  :                 state->head->done = 1;

  009e7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  009ea	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  009ed	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  009f4	6a 00		 push	 0
  009f6	6a 00		 push	 0
  009f8	6a 00		 push	 0
  009fa	e8 00 00 00 00	 call	 _crc32@12
  009ff	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a02	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00a05	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00a08	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a0b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00a0e	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 795  :             state->mode = TYPE;

  00a11	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a14	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 796  :             break;

  00a1a	e9 07 14 00 00	 jmp	 $LN498@inflate
$LN338@inflate:

; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  00a1f	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00a23	73 3d		 jae	 SHORT $LN340@inflate
$LN336@inflate:
  00a25	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a29	75 05		 jne	 SHORT $LN333@inflate
  00a2b	e9 fb 13 00 00	 jmp	 $inf_leave$77705
$LN333@inflate:
  00a30	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00a33	83 e8 01	 sub	 eax, 1
  00a36	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00a39	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00a3c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00a3f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a42	d3 e2		 shl	 edx, cl
  00a44	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00a47	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00a4a	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00a4d	83 c0 01	 add	 eax, 1
  00a50	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00a53	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a56	83 c1 08	 add	 ecx, 8
  00a59	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00a5c	33 d2		 xor	 edx, edx
  00a5e	75 c5		 jne	 SHORT $LN336@inflate
  00a60	eb bd		 jmp	 SHORT $LN338@inflate
$LN340@inflate:
  00a62	33 c0		 xor	 eax, eax
  00a64	75 b9		 jne	 SHORT $LN338@inflate

; 800  :             strm->adler = state->check = REVERSE(hold);

  00a66	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a69	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00a6c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a72	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00a75	c1 ea 08	 shr	 edx, 8
  00a78	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00a7e	03 ca		 add	 ecx, edx
  00a80	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00a83	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00a88	c1 e0 08	 shl	 eax, 8
  00a8b	03 c8		 add	 ecx, eax
  00a8d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00a90	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a96	c1 e2 18	 shl	 edx, 24			; 00000018H
  00a99	03 ca		 add	 ecx, edx
  00a9b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a9e	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00aa1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00aa4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00aa7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00aaa	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN332@inflate:

; 801  :             INITBITS();

  00aad	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00ab4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00abb	33 c9		 xor	 ecx, ecx
  00abd	75 ee		 jne	 SHORT $LN332@inflate

; 802  :             state->mode = DICT;

  00abf	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00ac2	c7 02 0a 00 00
	00		 mov	 DWORD PTR [edx], 10	; 0000000aH
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  00ac8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00acb	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00acf	75 43		 jne	 SHORT $LN328@inflate
$LN327@inflate:

; 805  :                 RESTORE();

  00ad1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ad4	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00ad7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00ada	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00add	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00ae0	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00ae3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ae6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00ae9	89 02		 mov	 DWORD PTR [edx], eax
  00aeb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00aee	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00af1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00af4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00af7	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00afa	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00afd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b00	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00b03	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00b06	33 c9		 xor	 ecx, ecx
  00b08	75 c7		 jne	 SHORT $LN327@inflate

; 806  :                 return Z_NEED_DICT;

  00b0a	b8 02 00 00 00	 mov	 eax, 2
  00b0f	e9 b3 14 00 00	 jmp	 $LN508@inflate
$LN328@inflate:

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00b14	6a 00		 push	 0
  00b16	6a 00		 push	 0
  00b18	6a 00		 push	 0
  00b1a	e8 00 00 00 00	 call	 _adler32@12
  00b1f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b22	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00b25	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b28	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b2b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b2e	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 809  :             state->mode = TYPE;

  00b31	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b34	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH
$LN324@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00b3a	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00b3e	74 06		 je	 SHORT $LN322@inflate
  00b40	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00b44	75 05		 jne	 SHORT $LN321@inflate
$LN322@inflate:
  00b46	e9 e0 12 00 00	 jmp	 $inf_leave$77705
$LN321@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  00b4b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00b52	74 2e		 je	 SHORT $LN313@inflate
$LN319@inflate:

; 814  :                 BYTEBITS();

  00b54	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b57	83 e1 07	 and	 ecx, 7
  00b5a	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00b5d	d3 ea		 shr	 edx, cl
  00b5f	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00b62	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00b65	83 e0 07	 and	 eax, 7
  00b68	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b6b	2b c8		 sub	 ecx, eax
  00b6d	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00b70	33 d2		 xor	 edx, edx
  00b72	75 e0		 jne	 SHORT $LN319@inflate

; 815  :                 state->mode = CHECK;

  00b74	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b77	c7 00 1a 00 00
	00		 mov	 DWORD PTR [eax], 26	; 0000001aH

; 816  :                 break;

  00b7d	e9 a4 12 00 00	 jmp	 $LN498@inflate
$LN313@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  00b82	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00b86	73 3d		 jae	 SHORT $LN315@inflate
$LN311@inflate:
  00b88	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b8c	75 05		 jne	 SHORT $LN308@inflate
  00b8e	e9 98 12 00 00	 jmp	 $inf_leave$77705
$LN308@inflate:
  00b93	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00b96	83 e9 01	 sub	 ecx, 1
  00b99	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00b9c	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00b9f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ba2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ba5	d3 e0		 shl	 eax, cl
  00ba7	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00baa	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00bad	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00bb0	83 c1 01	 add	 ecx, 1
  00bb3	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00bb6	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00bb9	83 c2 08	 add	 edx, 8
  00bbc	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00bbf	33 c0		 xor	 eax, eax
  00bc1	75 c5		 jne	 SHORT $LN311@inflate
  00bc3	eb bd		 jmp	 SHORT $LN313@inflate
$LN315@inflate:
  00bc5	33 c9		 xor	 ecx, ecx
  00bc7	75 b9		 jne	 SHORT $LN313@inflate

; 819  :             state->last = BITS(1);

  00bc9	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00bcc	83 e2 01	 and	 edx, 1
  00bcf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00bd2	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN307@inflate:

; 820  :             DROPBITS(1);

  00bd5	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bd8	d1 e9		 shr	 ecx, 1
  00bda	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00bdd	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00be0	83 ea 01	 sub	 edx, 1
  00be3	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00be6	33 c0		 xor	 eax, eax
  00be8	75 eb		 jne	 SHORT $LN307@inflate

; 821  :             switch (BITS(2)) {

  00bea	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bed	83 e1 03	 and	 ecx, 3
  00bf0	89 4d b4	 mov	 DWORD PTR tv556[ebp], ecx
  00bf3	83 7d b4 03	 cmp	 DWORD PTR tv556[ebp], 3
  00bf7	77 6b		 ja	 SHORT $LN294@inflate
  00bf9	8b 55 b4	 mov	 edx, DWORD PTR tv556[ebp]
  00bfc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN521@inflate[edx*4]
$LN302@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;

  00c03	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c06	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 826  :                 break;

  00c0c	eb 56		 jmp	 SHORT $LN294@inflate
$LN301@inflate:

; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  00c0e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00c11	51		 push	 ecx
  00c12	e8 00 00 00 00	 call	 _fixedtables
  00c17	83 c4 04	 add	 esp, 4

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */

  00c1a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c1d	c7 02 13 00 00
	00		 mov	 DWORD PTR [edx], 19	; 00000013H

; 832  :                 if (flush == Z_TREES) {

  00c23	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00c27	75 1b		 jne	 SHORT $LN300@inflate
$LN299@inflate:

; 833  :                     DROPBITS(2);

  00c29	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c2c	c1 e8 02	 shr	 eax, 2
  00c2f	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c32	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c35	83 e9 02	 sub	 ecx, 2
  00c38	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00c3b	33 d2		 xor	 edx, edx
  00c3d	75 ea		 jne	 SHORT $LN299@inflate

; 834  :                     goto inf_leave;

  00c3f	e9 e7 11 00 00	 jmp	 $inf_leave$77705
$LN300@inflate:

; 835  :                 }
; 836  :                 break;

  00c44	eb 1e		 jmp	 SHORT $LN294@inflate
$LN296@inflate:

; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;

  00c46	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c49	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 841  :                 break;

  00c4f	eb 13		 jmp	 SHORT $LN294@inflate
$LN295@inflate:

; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  00c51	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c54	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 844  :                 state->mode = BAD;

  00c5b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c5e	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
$LN294@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  00c64	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c67	c1 e8 02	 shr	 eax, 2
  00c6a	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c6d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c70	83 e9 02	 sub	 ecx, 2
  00c73	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00c76	33 d2		 xor	 edx, edx
  00c78	75 ea		 jne	 SHORT $LN294@inflate

; 847  :             break;

  00c7a	e9 a7 11 00 00	 jmp	 $LN498@inflate
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  00c7f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c82	83 e1 07	 and	 ecx, 7
  00c85	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c88	d3 e8		 shr	 eax, cl
  00c8a	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c8d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c90	83 e1 07	 and	 ecx, 7
  00c93	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00c96	2b d1		 sub	 edx, ecx
  00c98	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00c9b	33 c0		 xor	 eax, eax
  00c9d	75 e0		 jne	 SHORT $LN290@inflate
$LN284@inflate:

; 850  :             NEEDBITS(32);

  00c9f	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00ca3	73 3d		 jae	 SHORT $LN286@inflate
$LN282@inflate:
  00ca5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ca9	75 05		 jne	 SHORT $LN279@inflate
  00cab	e9 7b 11 00 00	 jmp	 $inf_leave$77705
$LN279@inflate:
  00cb0	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00cb3	83 e9 01	 sub	 ecx, 1
  00cb6	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00cb9	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00cbc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00cbf	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cc2	d3 e0		 shl	 eax, cl
  00cc4	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00cc7	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00cca	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00ccd	83 c1 01	 add	 ecx, 1
  00cd0	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00cd3	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00cd6	83 c2 08	 add	 edx, 8
  00cd9	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00cdc	33 c0		 xor	 eax, eax
  00cde	75 c5		 jne	 SHORT $LN282@inflate
  00ce0	eb bd		 jmp	 SHORT $LN284@inflate
$LN286@inflate:
  00ce2	33 c9		 xor	 ecx, ecx
  00ce4	75 b9		 jne	 SHORT $LN284@inflate

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00ce6	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00ce9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00cef	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00cf2	c1 e8 10	 shr	 eax, 16			; 00000010H
  00cf5	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00cfa	3b d0		 cmp	 edx, eax
  00cfc	74 18		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  00cfe	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d01	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 853  :                 state->mode = BAD;

  00d08	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d0b	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 854  :                 break;

  00d11	e9 10 11 00 00	 jmp	 $LN498@inflate
$LN278@inflate:

; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  00d16	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00d19	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d1e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d21	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN277@inflate:

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  00d24	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00d2b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00d32	33 d2		 xor	 edx, edx
  00d34	75 ee		 jne	 SHORT $LN277@inflate

; 860  :             state->mode = COPY_;

  00d36	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00d39	c7 00 0e 00 00
	00		 mov	 DWORD PTR [eax], 14	; 0000000eH

; 861  :             if (flush == Z_TREES) goto inf_leave;

  00d3f	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00d43	75 05		 jne	 SHORT $LN273@inflate
  00d45	e9 e1 10 00 00	 jmp	 $inf_leave$77705
$LN273@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  00d4a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d4d	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  00d53	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d56	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00d59	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 866  :             if (copy) {

  00d5c	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d60	74 73		 je	 SHORT $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  00d62	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00d65	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00d68	76 06		 jbe	 SHORT $LN270@inflate
  00d6a	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00d6d	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN270@inflate:

; 868  :                 if (copy > left) copy = left;

  00d70	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00d73	3b 45 e0	 cmp	 eax, DWORD PTR _left$[ebp]
  00d76	76 06		 jbe	 SHORT $LN269@inflate
  00d78	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00d7b	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN269@inflate:

; 869  :                 if (copy == 0) goto inf_leave;

  00d7e	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d82	75 05		 jne	 SHORT $LN268@inflate
  00d84	e9 a2 10 00 00	 jmp	 $inf_leave$77705
$LN268@inflate:

; 870  :                 zmemcpy(put, next, copy);

  00d89	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00d8c	52		 push	 edx
  00d8d	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00d90	50		 push	 eax
  00d91	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00d94	51		 push	 ecx
  00d95	e8 00 00 00 00	 call	 _memcpy
  00d9a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  :                 have -= copy;

  00d9d	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00da0	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00da3	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 872  :                 next += copy;

  00da6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00da9	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00dac	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 873  :                 left -= copy;

  00daf	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00db2	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00db5	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 874  :                 put += copy;

  00db8	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00dbb	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00dbe	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 875  :                 state->length -= copy;

  00dc1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00dc4	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00dc7	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00dca	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00dcd	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 876  :                 break;

  00dd0	e9 51 10 00 00	 jmp	 $LN498@inflate
$LN271@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;

  00dd5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00dd8	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 880  :             break;

  00dde	e9 43 10 00 00	 jmp	 $LN498@inflate
$LN263@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  00de3	83 7d e4 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00de7	73 3d		 jae	 SHORT $LN265@inflate
$LN261@inflate:
  00de9	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ded	75 05		 jne	 SHORT $LN258@inflate
  00def	e9 37 10 00 00	 jmp	 $inf_leave$77705
$LN258@inflate:
  00df4	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00df7	83 e9 01	 sub	 ecx, 1
  00dfa	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00dfd	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00e00	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00e03	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e06	d3 e0		 shl	 eax, cl
  00e08	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00e0b	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00e0e	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00e11	83 c1 01	 add	 ecx, 1
  00e14	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00e17	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00e1a	83 c2 08	 add	 edx, 8
  00e1d	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00e20	33 c0		 xor	 eax, eax
  00e22	75 c5		 jne	 SHORT $LN261@inflate
  00e24	eb bd		 jmp	 SHORT $LN263@inflate
$LN265@inflate:
  00e26	33 c9		 xor	 ecx, ecx
  00e28	75 b9		 jne	 SHORT $LN263@inflate

; 883  :             state->nlen = BITS(5) + 257;

  00e2a	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00e2d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00e30	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00e36	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e39	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN257@inflate:

; 884  :             DROPBITS(5);

  00e3c	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00e3f	c1 e9 05	 shr	 ecx, 5
  00e42	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00e45	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00e48	83 ea 05	 sub	 edx, 5
  00e4b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00e4e	33 c0		 xor	 eax, eax
  00e50	75 ea		 jne	 SHORT $LN257@inflate

; 885  :             state->ndist = BITS(5) + 1;

  00e52	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00e55	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00e58	83 c1 01	 add	 ecx, 1
  00e5b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e5e	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
$LN254@inflate:

; 886  :             DROPBITS(5);

  00e61	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00e64	c1 e8 05	 shr	 eax, 5
  00e67	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00e6a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e6d	83 e9 05	 sub	 ecx, 5
  00e70	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00e73	33 d2		 xor	 edx, edx
  00e75	75 ea		 jne	 SHORT $LN254@inflate

; 887  :             state->ncode = BITS(4) + 4;

  00e77	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00e7a	83 e0 0f	 and	 eax, 15			; 0000000fH
  00e7d	83 c0 04	 add	 eax, 4
  00e80	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e83	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN251@inflate:

; 888  :             DROPBITS(4);

  00e86	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00e89	c1 ea 04	 shr	 edx, 4
  00e8c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00e8f	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00e92	83 e8 04	 sub	 eax, 4
  00e95	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  00e98	33 c9		 xor	 ecx, ecx
  00e9a	75 ea		 jne	 SHORT $LN251@inflate

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  00e9c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e9f	81 7a 60 1e 01
	00 00		 cmp	 DWORD PTR [edx+96], 286	; 0000011eH
  00ea6	77 09		 ja	 SHORT $LN247@inflate
  00ea8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00eab	83 78 64 1e	 cmp	 DWORD PTR [eax+100], 30	; 0000001eH
  00eaf	76 18		 jbe	 SHORT $LN248@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  00eb1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00eb4	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 892  :                 state->mode = BAD;

  00ebb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00ebe	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 893  :                 break;

  00ec4	e9 5d 0f 00 00	 jmp	 $LN498@inflate
$LN248@inflate:

; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  00ec9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ecc	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 898  :             state->mode = LENLENS;

  00ed3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00ed6	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN245@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  00edc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00edf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ee2	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  00ee5	3b 48 5c	 cmp	 ecx, DWORD PTR [eax+92]
  00ee8	0f 83 8d 00 00
	00		 jae	 $LN231@inflate
$LN240@inflate:

; 901  :                 NEEDBITS(3);

  00eee	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00ef2	73 3d		 jae	 SHORT $LN242@inflate
$LN238@inflate:
  00ef4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ef8	75 05		 jne	 SHORT $LN235@inflate
  00efa	e9 2c 0f 00 00	 jmp	 $inf_leave$77705
$LN235@inflate:
  00eff	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00f02	83 ea 01	 sub	 edx, 1
  00f05	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00f08	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00f0b	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00f0e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f11	d3 e2		 shl	 edx, cl
  00f13	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00f16	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00f19	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00f1c	83 c0 01	 add	 eax, 1
  00f1f	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00f22	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f25	83 c1 08	 add	 ecx, 8
  00f28	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00f2b	33 d2		 xor	 edx, edx
  00f2d	75 c5		 jne	 SHORT $LN238@inflate
  00f2f	eb bd		 jmp	 SHORT $LN240@inflate
$LN242@inflate:
  00f31	33 c0		 xor	 eax, eax
  00f33	75 b9		 jne	 SHORT $LN240@inflate

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00f35	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00f38	83 e1 07	 and	 ecx, 7
  00f3b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f3e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f41	0f b7 14 45 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00f49	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f4c	66 89 4c 50 70	 mov	 WORD PTR [eax+edx*2+112], cx
  00f51	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f54	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00f57	83 c2 01	 add	 edx, 1
  00f5a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f5d	89 50 68	 mov	 DWORD PTR [eax+104], edx
$LN234@inflate:

; 903  :                 DROPBITS(3);

  00f60	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00f63	c1 e9 03	 shr	 ecx, 3
  00f66	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00f69	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00f6c	83 ea 03	 sub	 edx, 3
  00f6f	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00f72	33 c0		 xor	 eax, eax
  00f74	75 ea		 jne	 SHORT $LN234@inflate

; 904  :             }

  00f76	e9 61 ff ff ff	 jmp	 $LN245@inflate
$LN231@inflate:

; 905  :             while (state->have < 19)

  00f7b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f7e	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00f82	73 29		 jae	 SHORT $LN230@inflate

; 906  :                 state->lens[order[state->have++]] = 0;

  00f84	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f87	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f8a	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00f92	33 d2		 xor	 edx, edx
  00f94	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f97	66 89 54 48 70	 mov	 WORD PTR [eax+ecx*2+112], dx
  00f9c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f9f	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00fa2	83 c2 01	 add	 edx, 1
  00fa5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fa8	89 50 68	 mov	 DWORD PTR [eax+104], edx
  00fab	eb ce		 jmp	 SHORT $LN231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;

  00fad	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fb0	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  00fb6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fb9	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx

; 908  :             state->lencode = (code const FAR *)(state->next);

  00fbc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fbf	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fc2	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00fc5	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 909  :             state->lenbits = 7;

  00fc8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fcb	c7 40 54 07 00
	00 00		 mov	 DWORD PTR [eax+84], 7

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  00fd2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fd5	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  00fdb	51		 push	 ecx
  00fdc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fdf	83 c2 54	 add	 edx, 84			; 00000054H
  00fe2	52		 push	 edx
  00fe3	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fe6	83 c0 6c	 add	 eax, 108		; 0000006cH
  00fe9	50		 push	 eax
  00fea	6a 13		 push	 19			; 00000013H
  00fec	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fef	83 c1 70	 add	 ecx, 112		; 00000070H
  00ff2	51		 push	 ecx
  00ff3	6a 00		 push	 0
  00ff5	e8 00 00 00 00	 call	 _inflate_table
  00ffa	83 c4 18	 add	 esp, 24			; 00000018H
  00ffd	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 912  :             if (ret) {

  01000	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01004	74 18		 je	 SHORT $LN229@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  01006	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01009	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 914  :                 state->mode = BAD;

  01010	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01013	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 915  :                 break;

  01019	e9 08 0e 00 00	 jmp	 $LN498@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  0101e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01021	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 919  :             state->mode = CODELENS;

  01028	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0102b	c7 02 12 00 00
	00		 mov	 DWORD PTR [edx], 18	; 00000012H
$LN227@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  01031	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01034	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01037	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0103a	03 4a 64	 add	 ecx, DWORD PTR [edx+100]
  0103d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01040	39 48 68	 cmp	 DWORD PTR [eax+104], ecx
  01043	0f 83 6b 03 00
	00		 jae	 $LN226@inflate
$LN225@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  01049	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0104c	ba 01 00 00 00	 mov	 edx, 1
  01051	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  01054	d3 e2		 shl	 edx, cl
  01056	83 ea 01	 sub	 edx, 1
  01059	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  0105c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0105f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01062	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01065	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  01068	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0106c	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  0106f	77 02		 ja	 SHORT $LN222@inflate
  01071	eb 3d		 jmp	 SHORT $LN224@inflate
$LN222@inflate:

; 925  :                     PULLBYTE();

  01073	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01077	75 05		 jne	 SHORT $LN219@inflate
  01079	e9 ad 0d 00 00	 jmp	 $inf_leave$77705
$LN219@inflate:
  0107e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01081	83 e9 01	 sub	 ecx, 1
  01084	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01087	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0108a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0108d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01090	d3 e0		 shl	 eax, cl
  01092	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01095	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01098	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0109b	83 c1 01	 add	 ecx, 1
  0109e	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  010a1	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  010a4	83 c2 08	 add	 edx, 8
  010a7	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  010aa	33 c0		 xor	 eax, eax
  010ac	75 c5		 jne	 SHORT $LN222@inflate

; 926  :                 }

  010ae	eb 99		 jmp	 SHORT $LN225@inflate
$LN224@inflate:

; 927  :                 if (here.val < 16) {

  010b0	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  010b4	83 f9 10	 cmp	 ecx, 16			; 00000010H
  010b7	0f 8d 8c 00 00
	00		 jge	 $LN218@inflate
$LN214@inflate:

; 928  :                     NEEDBITS(here.bits);

  010bd	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  010c1	39 55 e4	 cmp	 DWORD PTR _bits$[ebp], edx
  010c4	73 3d		 jae	 SHORT $LN216@inflate
$LN212@inflate:
  010c6	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  010ca	75 05		 jne	 SHORT $LN209@inflate
  010cc	e9 5a 0d 00 00	 jmp	 $inf_leave$77705
$LN209@inflate:
  010d1	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  010d4	83 e8 01	 sub	 eax, 1
  010d7	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  010da	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  010dd	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  010e0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  010e3	d3 e2		 shl	 edx, cl
  010e5	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  010e8	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  010eb	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  010ee	83 c0 01	 add	 eax, 1
  010f1	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  010f4	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  010f7	83 c1 08	 add	 ecx, 8
  010fa	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  010fd	33 d2		 xor	 edx, edx
  010ff	75 c5		 jne	 SHORT $LN212@inflate
  01101	eb ba		 jmp	 SHORT $LN214@inflate
$LN216@inflate:
  01103	33 c0		 xor	 eax, eax
  01105	75 b6		 jne	 SHORT $LN214@inflate
$LN208@inflate:

; 929  :                     DROPBITS(here.bits);

  01107	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0110b	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  0110e	d3 ea		 shr	 edx, cl
  01110	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01113	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01117	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0111a	2b c8		 sub	 ecx, eax
  0111c	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0111f	33 d2		 xor	 edx, edx
  01121	75 e4		 jne	 SHORT $LN208@inflate

; 930  :                     state->lens[state->have++] = here.val;

  01123	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01126	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  01129	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0112c	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  01130	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  01135	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01138	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0113b	83 c2 01	 add	 edx, 1
  0113e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01141	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 931  :                 }
; 932  :                 else {

  01144	e9 66 02 00 00	 jmp	 $LN205@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  01149	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0114d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01150	0f 85 c2 00 00
	00		 jne	 $LN204@inflate
$LN200@inflate:

; 934  :                         NEEDBITS(here.bits + 2);

  01156	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  0115a	83 c2 02	 add	 edx, 2
  0115d	39 55 e4	 cmp	 DWORD PTR _bits$[ebp], edx
  01160	73 3d		 jae	 SHORT $LN202@inflate
$LN198@inflate:
  01162	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01166	75 05		 jne	 SHORT $LN195@inflate
  01168	e9 be 0c 00 00	 jmp	 $inf_leave$77705
$LN195@inflate:
  0116d	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01170	83 e8 01	 sub	 eax, 1
  01173	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01176	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01179	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0117c	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0117f	d3 e2		 shl	 edx, cl
  01181	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01184	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01187	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0118a	83 c0 01	 add	 eax, 1
  0118d	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01190	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01193	83 c1 08	 add	 ecx, 8
  01196	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01199	33 d2		 xor	 edx, edx
  0119b	75 c5		 jne	 SHORT $LN198@inflate
  0119d	eb b7		 jmp	 SHORT $LN200@inflate
$LN202@inflate:
  0119f	33 c0		 xor	 eax, eax
  011a1	75 b3		 jne	 SHORT $LN200@inflate
$LN194@inflate:

; 935  :                         DROPBITS(here.bits);

  011a3	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  011a7	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  011aa	d3 ea		 shr	 edx, cl
  011ac	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  011af	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  011b3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  011b6	2b c8		 sub	 ecx, eax
  011b8	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  011bb	33 d2		 xor	 edx, edx
  011bd	75 e4		 jne	 SHORT $LN194@inflate

; 936  :                         if (state->have == 0) {

  011bf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  011c2	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  011c6	75 18		 jne	 SHORT $LN191@inflate

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  011c8	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  011cb	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 938  :                             state->mode = BAD;

  011d2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  011d5	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 939  :                             break;

  011db	e9 d4 01 00 00	 jmp	 $LN226@inflate
$LN191@inflate:

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];

  011e0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  011e3	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  011e6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  011e9	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  011ee	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 942  :                         copy = 3 + BITS(2);

  011f1	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  011f4	83 e1 03	 and	 ecx, 3
  011f7	83 c1 03	 add	 ecx, 3
  011fa	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN190@inflate:

; 943  :                         DROPBITS(2);

  011fd	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01200	c1 ea 02	 shr	 edx, 2
  01203	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01206	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01209	83 e8 02	 sub	 eax, 2
  0120c	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  0120f	33 c9		 xor	 ecx, ecx
  01211	75 ea		 jne	 SHORT $LN190@inflate

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  01213	e9 36 01 00 00	 jmp	 $LN187@inflate
$LN204@inflate:
  01218	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  0121c	83 fa 11	 cmp	 edx, 17			; 00000011H
  0121f	0f 85 97 00 00
	00		 jne	 $LN166@inflate
$LN182@inflate:

; 946  :                         NEEDBITS(here.bits + 3);

  01225	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01229	83 c0 03	 add	 eax, 3
  0122c	39 45 e4	 cmp	 DWORD PTR _bits$[ebp], eax
  0122f	73 3d		 jae	 SHORT $LN184@inflate
$LN180@inflate:
  01231	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01235	75 05		 jne	 SHORT $LN177@inflate
  01237	e9 ef 0b 00 00	 jmp	 $inf_leave$77705
$LN177@inflate:
  0123c	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0123f	83 e9 01	 sub	 ecx, 1
  01242	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01245	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01248	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0124b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0124e	d3 e0		 shl	 eax, cl
  01250	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01253	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01256	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01259	83 c1 01	 add	 ecx, 1
  0125c	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0125f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01262	83 c2 08	 add	 edx, 8
  01265	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01268	33 c0		 xor	 eax, eax
  0126a	75 c5		 jne	 SHORT $LN180@inflate
  0126c	eb b7		 jmp	 SHORT $LN182@inflate
$LN184@inflate:
  0126e	33 c9		 xor	 ecx, ecx
  01270	75 b3		 jne	 SHORT $LN182@inflate
$LN176@inflate:

; 947  :                         DROPBITS(here.bits);

  01272	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01276	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01279	d3 ea		 shr	 edx, cl
  0127b	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0127e	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01282	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01285	2b c8		 sub	 ecx, eax
  01287	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0128a	33 d2		 xor	 edx, edx
  0128c	75 e4		 jne	 SHORT $LN176@inflate

; 948  :                         len = 0;

  0128e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 949  :                         copy = 3 + BITS(3);

  01295	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01298	83 e0 07	 and	 eax, 7
  0129b	83 c0 03	 add	 eax, 3
  0129e	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN173@inflate:

; 950  :                         DROPBITS(3);

  012a1	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  012a4	c1 e9 03	 shr	 ecx, 3
  012a7	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  012aa	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  012ad	83 ea 03	 sub	 edx, 3
  012b0	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  012b3	33 c0		 xor	 eax, eax
  012b5	75 ea		 jne	 SHORT $LN173@inflate

; 951  :                     }
; 952  :                     else {

  012b7	e9 92 00 00 00	 jmp	 $LN187@inflate
$LN166@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  012bc	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  012c0	83 c1 07	 add	 ecx, 7
  012c3	39 4d e4	 cmp	 DWORD PTR _bits$[ebp], ecx
  012c6	73 3d		 jae	 SHORT $LN168@inflate
$LN164@inflate:
  012c8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  012cc	75 05		 jne	 SHORT $LN161@inflate
  012ce	e9 58 0b 00 00	 jmp	 $inf_leave$77705
$LN161@inflate:
  012d3	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  012d6	83 ea 01	 sub	 edx, 1
  012d9	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  012dc	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  012df	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  012e2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012e5	d3 e2		 shl	 edx, cl
  012e7	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  012ea	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  012ed	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  012f0	83 c0 01	 add	 eax, 1
  012f3	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  012f6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012f9	83 c1 08	 add	 ecx, 8
  012fc	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012ff	33 d2		 xor	 edx, edx
  01301	75 c5		 jne	 SHORT $LN164@inflate
  01303	eb b7		 jmp	 SHORT $LN166@inflate
$LN168@inflate:
  01305	33 c0		 xor	 eax, eax
  01307	75 b3		 jne	 SHORT $LN166@inflate
$LN160@inflate:

; 954  :                         DROPBITS(here.bits);

  01309	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0130d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01310	d3 ea		 shr	 edx, cl
  01312	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01315	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01319	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0131c	2b c8		 sub	 ecx, eax
  0131e	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01321	33 d2		 xor	 edx, edx
  01323	75 e4		 jne	 SHORT $LN160@inflate

; 955  :                         len = 0;

  01325	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 956  :                         copy = 11 + BITS(7);

  0132c	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0132f	83 e0 7f	 and	 eax, 127		; 0000007fH
  01332	83 c0 0b	 add	 eax, 11			; 0000000bH
  01335	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN157@inflate:

; 957  :                         DROPBITS(7);

  01338	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0133b	c1 e9 07	 shr	 ecx, 7
  0133e	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  01341	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01344	83 ea 07	 sub	 edx, 7
  01347	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0134a	33 c0		 xor	 eax, eax
  0134c	75 ea		 jne	 SHORT $LN157@inflate
$LN187@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  0134e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01351	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  01354	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  01357	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0135a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0135d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01360	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  01363	3b d1		 cmp	 edx, ecx
  01365	76 15		 jbe	 SHORT $LN153@inflate

; 960  :                         strm->msg = (char *)"invalid bit length repeat";

  01367	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0136a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 961  :                         state->mode = BAD;

  01371	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01374	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 962  :                         break;

  0137a	eb 38		 jmp	 SHORT $LN226@inflate
$LN153@inflate:

; 963  :                     }
; 964  :                     while (copy--)

  0137c	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  0137f	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01382	83 e9 01	 sub	 ecx, 1
  01385	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
  01388	85 c0		 test	 eax, eax
  0138a	74 23		 je	 SHORT $LN205@inflate

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  0138c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0138f	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  01392	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01395	66 8b 55 e8	 mov	 dx, WORD PTR _len$[ebp]
  01399	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  0139e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013a1	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  013a4	83 c1 01	 add	 ecx, 1
  013a7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013aa	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  013ad	eb cd		 jmp	 SHORT $LN153@inflate
$LN205@inflate:

; 966  :                 }
; 967  :             }

  013af	e9 7d fc ff ff	 jmp	 $LN227@inflate
$LN226@inflate:

; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  013b4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013b7	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  013ba	75 05		 jne	 SHORT $LN151@inflate
  013bc	e9 65 0a 00 00	 jmp	 $LN498@inflate
$LN151@inflate:

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  013c1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013c4	0f b7 91 70 02
	00 00		 movzx	 edx, WORD PTR [ecx+624]
  013cb	85 d2		 test	 edx, edx
  013cd	75 18		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  013cf	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  013d2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 975  :                 state->mode = BAD;

  013d9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013dc	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 976  :                 break;

  013e2	e9 3f 0a 00 00	 jmp	 $LN498@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;

  013e7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013ea	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  013f0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013f3	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 983  :             state->lencode = (code const FAR *)(state->next);

  013f6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013f9	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013fc	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  013ff	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 984  :             state->lenbits = 9;

  01402	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01405	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  0140c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0140f	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  01415	52		 push	 edx
  01416	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01419	83 c0 54	 add	 eax, 84			; 00000054H
  0141c	50		 push	 eax
  0141d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01420	83 c1 6c	 add	 ecx, 108		; 0000006cH
  01423	51		 push	 ecx
  01424	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01427	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0142a	50		 push	 eax
  0142b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0142e	83 c1 70	 add	 ecx, 112		; 00000070H
  01431	51		 push	 ecx
  01432	6a 01		 push	 1
  01434	e8 00 00 00 00	 call	 _inflate_table
  01439	83 c4 18	 add	 esp, 24			; 00000018H
  0143c	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 987  :             if (ret) {

  0143f	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01443	74 18		 je	 SHORT $LN149@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  01445	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01448	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 989  :                 state->mode = BAD;

  0144f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01452	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 990  :                 break;

  01458	e9 c9 09 00 00	 jmp	 $LN498@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  0145d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01460	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01463	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  01466	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 993  :             state->distbits = 6;

  01469	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0146c	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6

; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  01473	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01476	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  0147c	52		 push	 edx
  0147d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01480	83 c0 58	 add	 eax, 88			; 00000058H
  01483	50		 push	 eax
  01484	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01487	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0148a	51		 push	 ecx
  0148b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0148e	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  01491	50		 push	 eax
  01492	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01495	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  01498	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0149b	8d 4c 50 70	 lea	 ecx, DWORD PTR [eax+edx*2+112]
  0149f	51		 push	 ecx
  014a0	6a 02		 push	 2
  014a2	e8 00 00 00 00	 call	 _inflate_table
  014a7	83 c4 18	 add	 esp, 24			; 00000018H
  014aa	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 996  :             if (ret) {

  014ad	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  014b1	74 18		 je	 SHORT $LN148@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  014b3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014b6	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 998  :                 state->mode = BAD;

  014bd	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  014c0	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 999  :                 break;

  014c6	e9 5b 09 00 00	 jmp	 $LN498@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;

  014cb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014ce	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H

; 1003 :             if (flush == Z_TREES) goto inf_leave;

  014d4	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  014d8	75 05		 jne	 SHORT $LN146@inflate
  014da	e9 4c 09 00 00	 jmp	 $inf_leave$77705
$LN146@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  014df	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014e2	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  014e8	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  014ec	0f 82 a9 00 00
	00		 jb	 $LN144@inflate
  014f2	81 7d e0 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  014f9	0f 82 9c 00 00
	00		 jb	 $LN144@inflate
$LN143@inflate:

; 1008 :                 RESTORE();

  014ff	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01502	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01505	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01508	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0150b	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  0150e	89 42 10	 mov	 DWORD PTR [edx+16], eax
  01511	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01514	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01517	89 11		 mov	 DWORD PTR [ecx], edx
  01519	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0151c	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0151f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01522	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01525	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01528	89 42 38	 mov	 DWORD PTR [edx+56], eax
  0152b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0152e	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01531	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  01534	33 c0		 xor	 eax, eax
  01536	75 c7		 jne	 SHORT $LN143@inflate

; 1009 :                 inflate_fast(strm, out);

  01538	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  0153b	51		 push	 ecx
  0153c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0153f	52		 push	 edx
  01540	e8 00 00 00 00	 call	 _inflate_fast
  01545	83 c4 08	 add	 esp, 8
$LN140@inflate:

; 1010 :                 LOAD();

  01548	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0154b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0154e	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01551	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01554	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01557	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax
  0155a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0155d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0155f	89 55 dc	 mov	 DWORD PTR _next$[ebp], edx
  01562	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01565	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01568	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0156b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0156e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01571	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01574	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01577	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0157a	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0157d	33 c0		 xor	 eax, eax
  0157f	75 c7		 jne	 SHORT $LN140@inflate

; 1011 :                 if (state->mode == TYPE)

  01581	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01584	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  01587	75 0d		 jne	 SHORT $LN137@inflate

; 1012 :                     state->back = -1;

  01589	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0158c	c7 82 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+7108], -1
$LN137@inflate:

; 1013 :                 break;

  01596	e9 8b 08 00 00	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;

  0159b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0159e	c7 80 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+7108], 0
$LN136@inflate:

; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  015a8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  015ab	ba 01 00 00 00	 mov	 edx, 1
  015b0	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  015b3	d3 e2		 shl	 edx, cl
  015b5	83 ea 01	 sub	 edx, 1
  015b8	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  015bb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  015be	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  015c1	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  015c4	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  015c7	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  015cb	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  015ce	77 02		 ja	 SHORT $LN133@inflate
  015d0	eb 3d		 jmp	 SHORT $LN135@inflate
$LN133@inflate:

; 1019 :                 PULLBYTE();

  015d2	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  015d6	75 05		 jne	 SHORT $LN130@inflate
  015d8	e9 4e 08 00 00	 jmp	 $inf_leave$77705
$LN130@inflate:
  015dd	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  015e0	83 e9 01	 sub	 ecx, 1
  015e3	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  015e6	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  015e9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  015ec	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  015ef	d3 e0		 shl	 eax, cl
  015f1	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  015f4	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  015f7	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  015fa	83 c1 01	 add	 ecx, 1
  015fd	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01600	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01603	83 c2 08	 add	 edx, 8
  01606	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01609	33 c0		 xor	 eax, eax
  0160b	75 c5		 jne	 SHORT $LN133@inflate

; 1020 :             }

  0160d	eb 99		 jmp	 SHORT $LN136@inflate
$LN135@inflate:

; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  0160f	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  01613	85 c9		 test	 ecx, ecx
  01615	0f 84 c5 00 00
	00		 je	 $LN118@inflate
  0161b	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0161f	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  01625	0f 85 b5 00 00
	00		 jne	 $LN118@inflate

; 1022 :                 last = here;

  0162b	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  0162e	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN128@inflate:

; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  01631	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  01635	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01639	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  0163d	03 c8		 add	 ecx, eax
  0163f	b8 01 00 00 00	 mov	 eax, 1
  01644	d3 e0		 shl	 eax, cl
  01646	83 e8 01	 sub	 eax, 1
  01649	23 45 d4	 and	 eax, DWORD PTR _hold$[ebp]
  0164c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01650	d3 e8		 shr	 eax, cl
  01652	03 d0		 add	 edx, eax
  01654	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01657	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0165a	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0165d	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01660	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  01664	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01668	03 d0		 add	 edx, eax
  0166a	3b 55 e4	 cmp	 edx, DWORD PTR _bits$[ebp]
  0166d	77 02		 ja	 SHORT $LN125@inflate
  0166f	eb 3d		 jmp	 SHORT $LN121@inflate
$LN125@inflate:

; 1027 :                     PULLBYTE();

  01671	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01675	75 05		 jne	 SHORT $LN122@inflate
  01677	e9 af 07 00 00	 jmp	 $inf_leave$77705
$LN122@inflate:
  0167c	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0167f	83 e9 01	 sub	 ecx, 1
  01682	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01685	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01688	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0168b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0168e	d3 e0		 shl	 eax, cl
  01690	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01693	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01696	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01699	83 c1 01	 add	 ecx, 1
  0169c	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0169f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  016a2	83 c2 08	 add	 edx, 8
  016a5	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  016a8	33 c0		 xor	 eax, eax
  016aa	75 c5		 jne	 SHORT $LN125@inflate

; 1028 :                 }

  016ac	eb 83		 jmp	 SHORT $LN128@inflate
$LN121@inflate:

; 1029 :                 DROPBITS(last.bits);

  016ae	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  016b2	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  016b5	d3 ea		 shr	 edx, cl
  016b7	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  016ba	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  016be	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  016c1	2b c8		 sub	 ecx, eax
  016c3	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  016c6	33 d2		 xor	 edx, edx
  016c8	75 e4		 jne	 SHORT $LN121@inflate

; 1030 :                 state->back += last.bits;

  016ca	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  016ce	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  016d1	03 81 c4 1b 00
	00		 add	 eax, DWORD PTR [ecx+7108]
  016d7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  016da	89 82 c4 1b 00
	00		 mov	 DWORD PTR [edx+7108], eax
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  016e0	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  016e4	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  016e7	d3 e8		 shr	 eax, cl
  016e9	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  016ec	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  016f0	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  016f3	2b d1		 sub	 edx, ecx
  016f5	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  016f8	33 c0		 xor	 eax, eax
  016fa	75 e4		 jne	 SHORT $LN118@inflate

; 1033 :             state->back += here.bits;

  016fc	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01700	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01703	03 8a c4 1b 00
	00		 add	 ecx, DWORD PTR [edx+7108]
  01709	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0170c	89 88 c4 1b 00
	00		 mov	 DWORD PTR [eax+7108], ecx

; 1034 :             state->length = (unsigned)here.val;

  01712	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  01716	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01719	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 1035 :             if ((int)(here.op) == 0) {

  0171c	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  01720	85 c0		 test	 eax, eax
  01722	75 0e		 jne	 SHORT $LN115@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  01724	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01727	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1040 :                 break;

  0172d	e9 f4 06 00 00	 jmp	 $LN498@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  01732	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  01736	83 e2 20	 and	 edx, 32			; 00000020H
  01739	74 1b		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  0173b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0173e	c7 80 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7108], -1

; 1045 :                 state->mode = TYPE;

  01748	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0174b	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1046 :                 break;

  01751	e9 d0 06 00 00	 jmp	 $LN498@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  01756	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0175a	83 e2 40	 and	 edx, 64			; 00000040H
  0175d	74 18		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  0175f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01762	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1050 :                 state->mode = BAD;

  01769	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0176c	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 1051 :                 break;

  01772	e9 af 06 00 00	 jmp	 $LN498@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  01777	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0177b	83 e2 0f	 and	 edx, 15			; 0000000fH
  0177e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01781	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1054 :             state->mode = LENEXT;

  01784	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01787	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  0178d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01790	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  01794	0f 84 a1 00 00
	00		 je	 $LN111@inflate
$LN107@inflate:

; 1057 :                 NEEDBITS(state->extra);

  0179a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0179d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  017a0	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  017a3	73 3d		 jae	 SHORT $LN109@inflate
$LN105@inflate:
  017a5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  017a9	75 05		 jne	 SHORT $LN102@inflate
  017ab	e9 7b 06 00 00	 jmp	 $inf_leave$77705
$LN102@inflate:
  017b0	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  017b3	83 ea 01	 sub	 edx, 1
  017b6	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  017b9	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  017bc	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  017bf	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  017c2	d3 e2		 shl	 edx, cl
  017c4	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  017c7	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  017ca	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  017cd	83 c0 01	 add	 eax, 1
  017d0	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  017d3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  017d6	83 c1 08	 add	 ecx, 8
  017d9	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  017dc	33 d2		 xor	 edx, edx
  017de	75 c5		 jne	 SHORT $LN105@inflate
  017e0	eb b8		 jmp	 SHORT $LN107@inflate
$LN109@inflate:
  017e2	33 c0		 xor	 eax, eax
  017e4	75 b4		 jne	 SHORT $LN107@inflate

; 1058 :                 state->length += BITS(state->extra);

  017e6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017e9	ba 01 00 00 00	 mov	 edx, 1
  017ee	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  017f1	d3 e2		 shl	 edx, cl
  017f3	83 ea 01	 sub	 edx, 1
  017f6	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  017f9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017fc	03 50 40	 add	 edx, DWORD PTR [eax+64]
  017ff	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01802	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN101@inflate:

; 1059 :                 DROPBITS(state->extra);

  01805	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01808	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0180b	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  0180e	d3 e8		 shr	 eax, cl
  01810	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01813	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01816	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01819	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  0181c	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0181f	33 c0		 xor	 eax, eax
  01821	75 e2		 jne	 SHORT $LN101@inflate

; 1060 :                 state->back += state->extra;

  01823	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01826	8b 91 c4 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7108]
  0182c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0182f	03 50 48	 add	 edx, DWORD PTR [eax+72]
  01832	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01835	89 91 c4 1b 00
	00		 mov	 DWORD PTR [ecx+7108], edx
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  0183b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0183e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01841	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01844	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx

; 1064 :             state->mode = DIST;

  0184a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0184d	c7 02 16 00 00
	00		 mov	 DWORD PTR [edx], 22	; 00000016H
$LN97@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  01853	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01856	ba 01 00 00 00	 mov	 edx, 1
  0185b	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0185e	d3 e2		 shl	 edx, cl
  01860	83 ea 01	 sub	 edx, 1
  01863	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01866	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01869	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0186c	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0186f	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  01872	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01876	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  01879	77 02		 ja	 SHORT $LN94@inflate
  0187b	eb 3d		 jmp	 SHORT $LN96@inflate
$LN94@inflate:

; 1069 :                 PULLBYTE();

  0187d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01881	75 05		 jne	 SHORT $LN91@inflate
  01883	e9 a3 05 00 00	 jmp	 $inf_leave$77705
$LN91@inflate:
  01888	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0188b	83 e9 01	 sub	 ecx, 1
  0188e	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01891	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01894	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01897	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0189a	d3 e0		 shl	 eax, cl
  0189c	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  0189f	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  018a2	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  018a5	83 c1 01	 add	 ecx, 1
  018a8	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  018ab	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  018ae	83 c2 08	 add	 edx, 8
  018b1	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  018b4	33 c0		 xor	 eax, eax
  018b6	75 c5		 jne	 SHORT $LN94@inflate

; 1070 :             }

  018b8	eb 99		 jmp	 SHORT $LN97@inflate
$LN96@inflate:

; 1071 :             if ((here.op & 0xf0) == 0) {

  018ba	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  018be	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  018c4	0f 85 b5 00 00
	00		 jne	 $LN79@inflate

; 1072 :                 last = here;

  018ca	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  018cd	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN89@inflate:

; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  018d0	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  018d4	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  018d8	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  018dc	03 ca		 add	 ecx, edx
  018de	ba 01 00 00 00	 mov	 edx, 1
  018e3	d3 e2		 shl	 edx, cl
  018e5	83 ea 01	 sub	 edx, 1
  018e8	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  018eb	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  018ef	d3 ea		 shr	 edx, cl
  018f1	03 c2		 add	 eax, edx
  018f3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  018f6	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  018f9	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  018fc	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  018ff	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01903	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  01907	03 ca		 add	 ecx, edx
  01909	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  0190c	77 02		 ja	 SHORT $LN86@inflate
  0190e	eb 3d		 jmp	 SHORT $LN82@inflate
$LN86@inflate:

; 1077 :                     PULLBYTE();

  01910	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01914	75 05		 jne	 SHORT $LN83@inflate
  01916	e9 10 05 00 00	 jmp	 $inf_leave$77705
$LN83@inflate:
  0191b	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0191e	83 e8 01	 sub	 eax, 1
  01921	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01924	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01927	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0192a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0192d	d3 e2		 shl	 edx, cl
  0192f	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01932	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01935	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01938	83 c0 01	 add	 eax, 1
  0193b	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0193e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01941	83 c1 08	 add	 ecx, 8
  01944	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01947	33 d2		 xor	 edx, edx
  01949	75 c5		 jne	 SHORT $LN86@inflate

; 1078 :                 }

  0194b	eb 83		 jmp	 SHORT $LN89@inflate
$LN82@inflate:

; 1079 :                 DROPBITS(last.bits);

  0194d	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01951	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01954	d3 e8		 shr	 eax, cl
  01956	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01959	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0195d	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01960	2b d1		 sub	 edx, ecx
  01962	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01965	33 c0		 xor	 eax, eax
  01967	75 e4		 jne	 SHORT $LN82@inflate

; 1080 :                 state->back += last.bits;

  01969	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0196d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01970	03 8a c4 1b 00
	00		 add	 ecx, DWORD PTR [edx+7108]
  01976	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01979	89 88 c4 1b 00
	00		 mov	 DWORD PTR [eax+7108], ecx
$LN79@inflate:

; 1081 :             }
; 1082 :             DROPBITS(here.bits);

  0197f	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01983	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01986	d3 ea		 shr	 edx, cl
  01988	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0198b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0198f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01992	2b c8		 sub	 ecx, eax
  01994	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01997	33 d2		 xor	 edx, edx
  01999	75 e4		 jne	 SHORT $LN79@inflate

; 1083 :             state->back += here.bits;

  0199b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0199f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019a2	03 81 c4 1b 00
	00		 add	 eax, DWORD PTR [ecx+7108]
  019a8	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019ab	89 82 c4 1b 00
	00		 mov	 DWORD PTR [edx+7108], eax

; 1084 :             if (here.op & 64) {

  019b1	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  019b5	83 e0 40	 and	 eax, 64			; 00000040H
  019b8	74 18		 je	 SHORT $LN76@inflate

; 1085 :                 strm->msg = (char *)"invalid distance code";

  019ba	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  019bd	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1086 :                 state->mode = BAD;

  019c4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019c7	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 1087 :                 break;

  019cd	e9 54 04 00 00	 jmp	 $LN498@inflate
$LN76@inflate:

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  019d2	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  019d6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019d9	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 1090 :             state->extra = (unsigned)(here.op) & 15;

  019dc	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  019e0	83 e2 0f	 and	 edx, 15			; 0000000fH
  019e3	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019e6	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1091 :             state->mode = DISTEXT;

  019e9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019ec	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  019f2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019f5	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  019f9	0f 84 a1 00 00
	00		 je	 $LN74@inflate
$LN70@inflate:

; 1094 :                 NEEDBITS(state->extra);

  019ff	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a02	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a05	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  01a08	73 3d		 jae	 SHORT $LN72@inflate
$LN68@inflate:
  01a0a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01a0e	75 05		 jne	 SHORT $LN65@inflate
  01a10	e9 16 04 00 00	 jmp	 $inf_leave$77705
$LN65@inflate:
  01a15	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01a18	83 ea 01	 sub	 edx, 1
  01a1b	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01a1e	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01a21	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01a24	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a27	d3 e2		 shl	 edx, cl
  01a29	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01a2c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01a2f	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01a32	83 c0 01	 add	 eax, 1
  01a35	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01a38	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a3b	83 c1 08	 add	 ecx, 8
  01a3e	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01a41	33 d2		 xor	 edx, edx
  01a43	75 c5		 jne	 SHORT $LN68@inflate
  01a45	eb b8		 jmp	 SHORT $LN70@inflate
$LN72@inflate:
  01a47	33 c0		 xor	 eax, eax
  01a49	75 b4		 jne	 SHORT $LN70@inflate

; 1095 :                 state->offset += BITS(state->extra);

  01a4b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a4e	ba 01 00 00 00	 mov	 edx, 1
  01a53	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  01a56	d3 e2		 shl	 edx, cl
  01a58	83 ea 01	 sub	 edx, 1
  01a5b	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01a5e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a61	03 50 44	 add	 edx, DWORD PTR [eax+68]
  01a64	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a67	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN64@inflate:

; 1096 :                 DROPBITS(state->extra);

  01a6a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a6d	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01a70	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  01a73	d3 e8		 shr	 eax, cl
  01a75	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01a78	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a7b	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01a7e	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  01a81	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01a84	33 c0		 xor	 eax, eax
  01a86	75 e2		 jne	 SHORT $LN64@inflate

; 1097 :                 state->back += state->extra;

  01a88	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a8b	8b 91 c4 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7108]
  01a91	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a94	03 50 48	 add	 edx, DWORD PTR [eax+72]
  01a97	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a9a	89 91 c4 1b 00
	00		 mov	 DWORD PTR [ecx+7108], edx
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  01aa0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01aa3	c7 02 18 00 00
	00		 mov	 DWORD PTR [edx], 24	; 00000018H
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  01aa9	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01aad	75 05		 jne	 SHORT $LN60@inflate
  01aaf	e9 77 03 00 00	 jmp	 $inf_leave$77705
$LN60@inflate:

; 1110 :             copy = out - left;

  01ab4	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01ab7	2b 45 e0	 sub	 eax, DWORD PTR _left$[ebp]
  01aba	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 1111 :             if (state->offset > copy) {         /* copy from window */

  01abd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ac0	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01ac3	3b 55 cc	 cmp	 edx, DWORD PTR _copy$[ebp]
  01ac6	0f 86 8e 00 00
	00		 jbe	 $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  01acc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01acf	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  01ad2	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  01ad5	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1113 :                 if (copy > state->whave) {

  01ad8	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01adb	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01ade	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  01ae1	76 24		 jbe	 SHORT $LN58@inflate

; 1114 :                     if (state->sane) {

  01ae3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ae6	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  01aed	74 18		 je	 SHORT $LN58@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  01aef	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01af2	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1116 :                         state->mode = BAD;

  01af9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01afc	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1117 :                         break;

  01b02	e9 1f 03 00 00	 jmp	 $LN498@inflate
$LN58@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  01b07	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b0a	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  01b0d	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  01b10	76 20		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;

  01b12	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b15	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01b18	2b 48 30	 sub	 ecx, DWORD PTR [eax+48]
  01b1b	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1135 :                     from = state->window + (state->wsize - copy);

  01b1e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b21	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  01b24	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01b27	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b2a	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  01b2d	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax

; 1136 :                 }
; 1137 :                 else

  01b30	eb 12		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  01b32	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b35	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  01b38	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01b3b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b3e	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  01b41	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax
$LN55@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  01b44	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b47	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01b4a	3b 42 40	 cmp	 eax, DWORD PTR [edx+64]
  01b4d	76 09		 jbe	 SHORT $LN54@inflate
  01b4f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b52	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  01b55	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN54@inflate:

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  01b58	eb 15		 jmp	 SHORT $LN53@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;

  01b5a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b5d	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b60	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  01b63	89 4d c8	 mov	 DWORD PTR _from$[ebp], ecx

; 1143 :                 copy = state->length;

  01b66	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b69	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  01b6c	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  01b6f	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01b72	3b 4d e0	 cmp	 ecx, DWORD PTR _left$[ebp]
  01b75	76 06		 jbe	 SHORT $LN52@inflate
  01b77	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  01b7a	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN52@inflate:

; 1146 :             left -= copy;

  01b7d	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  01b80	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01b83	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax

; 1147 :             state->length -= copy;

  01b86	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b89	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  01b8c	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  01b8f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b92	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  01b95	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b98	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01b9b	8a 02		 mov	 al, BYTE PTR [edx]
  01b9d	88 01		 mov	 BYTE PTR [ecx], al
  01b9f	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01ba2	83 c1 01	 add	 ecx, 1
  01ba5	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01ba8	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01bab	83 c2 01	 add	 edx, 1
  01bae	89 55 c8	 mov	 DWORD PTR _from$[ebp], edx

; 1150 :             } while (--copy);

  01bb1	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01bb4	83 e8 01	 sub	 eax, 1
  01bb7	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
  01bba	75 d9		 jne	 SHORT $LN51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  01bbc	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01bbf	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  01bc3	75 09		 jne	 SHORT $LN48@inflate
  01bc5	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bc8	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
$LN48@inflate:

; 1152 :             break;

  01bce	e9 53 02 00 00	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  01bd3	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01bd7	75 05		 jne	 SHORT $LN46@inflate
  01bd9	e9 4d 02 00 00	 jmp	 $inf_leave$77705
$LN46@inflate:

; 1155 :             *put++ = (unsigned char)(state->length);

  01bde	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01be1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01be4	8a 51 40	 mov	 dl, BYTE PTR [ecx+64]
  01be7	88 10		 mov	 BYTE PTR [eax], dl
  01be9	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01bec	83 c0 01	 add	 eax, 1
  01bef	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 1156 :             left--;

  01bf2	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01bf5	83 e9 01	 sub	 ecx, 1
  01bf8	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 1157 :             state->mode = LEN;

  01bfb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bfe	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H

; 1158 :             break;

  01c04	e9 1d 02 00 00	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  01c09	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c0c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  01c10	0f 84 49 01 00
	00		 je	 $LN44@inflate
$LN40@inflate:

; 1161 :                 NEEDBITS(32);

  01c16	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01c1a	73 3d		 jae	 SHORT $LN42@inflate
$LN38@inflate:
  01c1c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01c20	75 05		 jne	 SHORT $LN35@inflate
  01c22	e9 04 02 00 00	 jmp	 $inf_leave$77705
$LN35@inflate:
  01c27	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01c2a	83 e9 01	 sub	 ecx, 1
  01c2d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01c30	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01c33	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01c36	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01c39	d3 e0		 shl	 eax, cl
  01c3b	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01c3e	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01c41	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01c44	83 c1 01	 add	 ecx, 1
  01c47	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01c4a	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01c4d	83 c2 08	 add	 edx, 8
  01c50	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01c53	33 c0		 xor	 eax, eax
  01c55	75 c5		 jne	 SHORT $LN38@inflate
  01c57	eb bd		 jmp	 SHORT $LN40@inflate
$LN42@inflate:
  01c59	33 c9		 xor	 ecx, ecx
  01c5b	75 b9		 jne	 SHORT $LN40@inflate

; 1162 :                 out -= left;

  01c5d	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01c60	2b 55 e0	 sub	 edx, DWORD PTR _left$[ebp]
  01c63	89 55 c4	 mov	 DWORD PTR _out$[ebp], edx

; 1163 :                 strm->total_out += out;

  01c66	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01c69	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01c6c	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01c6f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01c72	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1164 :                 state->total += out;

  01c75	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c78	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01c7b	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01c7e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c81	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1165 :                 if (out)

  01c84	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01c88	74 51		 je	 SHORT $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  01c8a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c8d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01c91	74 1c		 je	 SHORT $LN512@inflate
  01c93	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01c96	51		 push	 ecx
  01c97	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01c9a	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01c9d	52		 push	 edx
  01c9e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ca1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01ca4	51		 push	 ecx
  01ca5	e8 00 00 00 00	 call	 _crc32@12
  01caa	89 45 b0	 mov	 DWORD PTR tv1235[ebp], eax
  01cad	eb 1a		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01caf	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01cb2	52		 push	 edx
  01cb3	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01cb6	2b 45 c4	 sub	 eax, DWORD PTR _out$[ebp]
  01cb9	50		 push	 eax
  01cba	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01cbd	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01cc0	52		 push	 edx
  01cc1	e8 00 00 00 00	 call	 _adler32@12
  01cc6	89 45 b0	 mov	 DWORD PTR tv1235[ebp], eax
$LN513@inflate:
  01cc9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ccc	8b 4d b0	 mov	 ecx, DWORD PTR tv1235[ebp]
  01ccf	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  01cd2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01cd5	8b 45 b0	 mov	 eax, DWORD PTR tv1235[ebp]
  01cd8	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN34@inflate:

; 1168 :                 out = left;

  01cdb	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01cde	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  01ce1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ce4	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01ce8	74 08		 je	 SHORT $LN514@inflate
  01cea	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01ced	89 45 ac	 mov	 DWORD PTR tv1249[ebp], eax
  01cf0	eb 38		 jmp	 SHORT $LN515@inflate
$LN514@inflate:
  01cf2	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01cf5	c1 e9 18	 shr	 ecx, 24			; 00000018H
  01cf8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01cfe	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01d01	c1 ea 08	 shr	 edx, 8
  01d04	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  01d0a	03 ca		 add	 ecx, edx
  01d0c	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01d0f	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01d14	c1 e0 08	 shl	 eax, 8
  01d17	03 c8		 add	 ecx, eax
  01d19	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01d1c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01d22	c1 e2 18	 shl	 edx, 24			; 00000018H
  01d25	03 ca		 add	 ecx, edx
  01d27	89 4d ac	 mov	 DWORD PTR tv1249[ebp], ecx
$LN515@inflate:
  01d2a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d2d	8b 4d ac	 mov	 ecx, DWORD PTR tv1249[ebp]
  01d30	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  01d33	74 18		 je	 SHORT $LN32@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  01d35	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01d38	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1175 :                     state->mode = BAD;

  01d3f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d42	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1176 :                     break;

  01d48	e9 d9 00 00 00	 jmp	 $LN498@inflate
$LN32@inflate:

; 1177 :                 }
; 1178 :                 INITBITS();

  01d4d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01d54	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01d5b	33 c9		 xor	 ecx, ecx
  01d5d	75 ee		 jne	 SHORT $LN32@inflate
$LN44@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  01d5f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d62	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  01d68	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d6b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  01d6f	0f 84 82 00 00
	00		 je	 $LN28@inflate
  01d75	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d78	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01d7c	74 79		 je	 SHORT $LN28@inflate
$LN24@inflate:

; 1185 :                 NEEDBITS(32);

  01d7e	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01d82	73 3d		 jae	 SHORT $LN26@inflate
$LN22@inflate:
  01d84	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01d88	75 05		 jne	 SHORT $LN19@inflate
  01d8a	e9 9c 00 00 00	 jmp	 $inf_leave$77705
$LN19@inflate:
  01d8f	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01d92	83 ea 01	 sub	 edx, 1
  01d95	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01d98	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01d9b	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01d9e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01da1	d3 e2		 shl	 edx, cl
  01da3	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01da6	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01da9	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01dac	83 c0 01	 add	 eax, 1
  01daf	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01db2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01db5	83 c1 08	 add	 ecx, 8
  01db8	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01dbb	33 d2		 xor	 edx, edx
  01dbd	75 c5		 jne	 SHORT $LN22@inflate
  01dbf	eb bd		 jmp	 SHORT $LN24@inflate
$LN26@inflate:
  01dc1	33 c0		 xor	 eax, eax
  01dc3	75 b9		 jne	 SHORT $LN24@inflate

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  01dc5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01dc8	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01dcb	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01dce	74 15		 je	 SHORT $LN17@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  01dd0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01dd3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@

; 1188 :                     state->mode = BAD;

  01dda	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ddd	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 1189 :                     break;

  01de3	eb 41		 jmp	 SHORT $LN498@inflate
$LN17@inflate:

; 1190 :                 }
; 1191 :                 INITBITS();

  01de5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01dec	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01df3	33 d2		 xor	 edx, edx
  01df5	75 ee		 jne	 SHORT $LN17@inflate
$LN28@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  01df7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01dfa	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  01e00	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1198 :             goto inf_leave;

  01e07	eb 22		 jmp	 SHORT $inf_leave$77705
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  01e09	c7 45 d8 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 1201 :             goto inf_leave;

  01e10	eb 19		 jmp	 SHORT $inf_leave$77705
$LN12@inflate:

; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;

  01e12	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01e17	e9 ab 01 00 00	 jmp	 $LN508@inflate
$LN11@inflate:

; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  01e1c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01e21	e9 a1 01 00 00	 jmp	 $LN508@inflate
$LN498@inflate:

; 1207 :         }

  01e26	e9 74 e2 ff ff	 jmp	 $LN501@inflate
$inf_leave$77705:

; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  01e2b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e2e	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01e31	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  01e34	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01e37	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01e3a	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01e3d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01e40	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01e43	89 02		 mov	 DWORD PTR [edx], eax
  01e45	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e48	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01e4b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01e4e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e51	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01e54	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  01e57	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e5a	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01e5d	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  01e60	33 c9		 xor	 ecx, ecx
  01e62	75 c7		 jne	 SHORT $inf_leave$77705

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  01e64	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e67	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  01e6b	75 13		 jne	 SHORT $LN6@inflate
  01e6d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e70	83 38 1a	 cmp	 DWORD PTR [eax], 26	; 0000001aH
  01e73	7d 32		 jge	 SHORT $LN7@inflate
  01e75	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e78	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01e7b	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  01e7e	74 27		 je	 SHORT $LN7@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  01e80	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01e83	50		 push	 eax
  01e84	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e87	51		 push	 ecx
  01e88	e8 00 00 00 00	 call	 _updatewindow
  01e8d	83 c4 08	 add	 esp, 8
  01e90	85 c0		 test	 eax, eax
  01e92	74 13		 je	 SHORT $LN7@inflate

; 1219 :             state->mode = MEM;

  01e94	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e97	c7 02 1e 00 00
	00		 mov	 DWORD PTR [edx], 30	; 0000001eH

; 1220 :             return Z_MEM_ERROR;

  01e9d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01ea2	e9 20 01 00 00	 jmp	 $LN508@inflate
$LN7@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;

  01ea7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01eaa	8b 4d ec	 mov	 ecx, DWORD PTR _in$[ebp]
  01ead	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  01eb0	89 4d ec	 mov	 DWORD PTR _in$[ebp], ecx

; 1223 :     out -= strm->avail_out;

  01eb3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01eb6	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01eb9	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  01ebc	89 45 c4	 mov	 DWORD PTR _out$[ebp], eax

; 1224 :     strm->total_in += in;

  01ebf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ec2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01ec5	03 55 ec	 add	 edx, DWORD PTR _in$[ebp]
  01ec8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01ecb	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1225 :     strm->total_out += out;

  01ece	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ed1	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01ed4	03 55 c4	 add	 edx, DWORD PTR _out$[ebp]
  01ed7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01eda	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1226 :     state->total += out;

  01edd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ee0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  01ee3	03 55 c4	 add	 edx, DWORD PTR _out$[ebp]
  01ee6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ee9	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1227 :     if (state->wrap && out)

  01eec	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01eef	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  01ef3	74 5d		 je	 SHORT $LN4@inflate
  01ef5	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01ef9	74 57		 je	 SHORT $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  01efb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01efe	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01f02	74 1f		 je	 SHORT $LN516@inflate
  01f04	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01f07	50		 push	 eax
  01f08	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f0b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01f0e	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01f11	52		 push	 edx
  01f12	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f15	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01f18	51		 push	 ecx
  01f19	e8 00 00 00 00	 call	 _crc32@12
  01f1e	89 45 a8	 mov	 DWORD PTR tv1322[ebp], eax
  01f21	eb 1d		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  01f23	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01f26	52		 push	 edx
  01f27	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01f2a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01f2d	2b 4d c4	 sub	 ecx, DWORD PTR _out$[ebp]
  01f30	51		 push	 ecx
  01f31	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f34	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01f37	50		 push	 eax
  01f38	e8 00 00 00 00	 call	 _adler32@12
  01f3d	89 45 a8	 mov	 DWORD PTR tv1322[ebp], eax
$LN517@inflate:
  01f40	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01f43	8b 55 a8	 mov	 edx, DWORD PTR tv1322[ebp]
  01f46	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  01f49	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01f4c	8b 4d a8	 mov	 ecx, DWORD PTR tv1322[ebp]
  01f4f	89 48 30	 mov	 DWORD PTR [eax+48], ecx
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  01f52	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f55	83 3a 13	 cmp	 DWORD PTR [edx], 19	; 00000013H
  01f58	74 11		 je	 SHORT $LN518@inflate
  01f5a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f5d	83 38 0e	 cmp	 DWORD PTR [eax], 14	; 0000000eH
  01f60	74 09		 je	 SHORT $LN518@inflate
  01f62	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv1334[ebp], 0
  01f69	eb 07		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01f6b	c7 45 a4 00 01
	00 00		 mov	 DWORD PTR tv1334[ebp], 256 ; 00000100H
$LN519@inflate:
  01f72	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01f75	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01f78	f7 da		 neg	 edx
  01f7a	1b d2		 sbb	 edx, edx
  01f7c	83 e2 40	 and	 edx, 64			; 00000040H
  01f7f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f82	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  01f85	03 ca		 add	 ecx, edx
  01f87	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f8a	33 c0		 xor	 eax, eax
  01f8c	83 3a 0b	 cmp	 DWORD PTR [edx], 11	; 0000000bH
  01f8f	0f 95 c0	 setne	 al
  01f92	83 e8 01	 sub	 eax, 1
  01f95	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01f9a	03 4d a4	 add	 ecx, DWORD PTR tv1334[ebp]
  01f9d	03 c1		 add	 eax, ecx
  01f9f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01fa2	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01fa5	83 7d ec 00	 cmp	 DWORD PTR _in$[ebp], 0
  01fa9	75 06		 jne	 SHORT $LN1@inflate
  01fab	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01faf	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01fb1	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01fb5	75 0d		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  01fb7	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01fbb	75 07		 jne	 SHORT $LN3@inflate

; 1234 :         ret = Z_BUF_ERROR;

  01fbd	c7 45 d8 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN3@inflate:

; 1235 :     return ret;

  01fc4	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
$LN508@inflate:

; 1236 : }

  01fc7	8b e5		 mov	 esp, ebp
  01fc9	5d		 pop	 ebp
  01fca	c2 08 00	 ret	 8
  01fcd	8d 49 00	 npad	 3
$LN520@inflate:
  01fd0	00 00 00 00	 DD	 $LN497@inflate
  01fd4	00 00 00 00	 DD	 $LN462@inflate
  01fd8	00 00 00 00	 DD	 $LN442@inflate
  01fdc	00 00 00 00	 DD	 $LN424@inflate
  01fe0	00 00 00 00	 DD	 $LN410@inflate
  01fe4	00 00 00 00	 DD	 $LN389@inflate
  01fe8	00 00 00 00	 DD	 $LN382@inflate
  01fec	00 00 00 00	 DD	 $LN370@inflate
  01ff0	00 00 00 00	 DD	 $LN358@inflate
  01ff4	00 00 00 00	 DD	 $LN338@inflate
  01ff8	00 00 00 00	 DD	 $LN329@inflate
  01ffc	00 00 00 00	 DD	 $LN324@inflate
  02000	00 00 00 00	 DD	 $LN321@inflate
  02004	00 00 00 00	 DD	 $LN290@inflate
  02008	00 00 00 00	 DD	 $LN273@inflate
  0200c	00 00 00 00	 DD	 $LN272@inflate
  02010	00 00 00 00	 DD	 $LN263@inflate
  02014	00 00 00 00	 DD	 $LN245@inflate
  02018	00 00 00 00	 DD	 $LN227@inflate
  0201c	00 00 00 00	 DD	 $LN146@inflate
  02020	00 00 00 00	 DD	 $LN145@inflate
  02024	00 00 00 00	 DD	 $LN112@inflate
  02028	00 00 00 00	 DD	 $LN97@inflate
  0202c	00 00 00 00	 DD	 $LN75@inflate
  02030	00 00 00 00	 DD	 $LN61@inflate
  02034	00 00 00 00	 DD	 $LN47@inflate
  02038	00 00 00 00	 DD	 $LN45@inflate
  0203c	00 00 00 00	 DD	 $LN29@inflate
  02040	00 00 00 00	 DD	 $LN14@inflate
  02044	00 00 00 00	 DD	 $LN13@inflate
  02048	00 00 00 00	 DD	 $LN12@inflate
$LN521@inflate:
  0204c	00 00 00 00	 DD	 $LN302@inflate
  02050	00 00 00 00	 DD	 $LN301@inflate
  02054	00 00 00 00	 DD	 $LN296@inflate
  02058	00 00 00 00	 DD	 $LN295@inflate
_inflate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset2@8
; Function compile flags: /Odtp
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$ = -8						; size = 4
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN7@inflateRes@2
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN8@inflateRes@2
$LN7@inflateRes@2:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 a6 00 00 00	 jmp	 $LN9@inflateRes@2
$LN8@inflateRes@2:

; 139  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00028	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0002c	7d 11		 jge	 SHORT $LN6@inflateRes@2

; 143  :         wrap = 0;

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 0

; 144  :         windowBits = -windowBits;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  00038	f7 d8		 neg	 eax
  0003a	89 45 0c	 mov	 DWORD PTR _windowBits$[ebp], eax

; 145  :     }
; 146  :     else {

  0003d	eb 1b		 jmp	 SHORT $LN5@inflateRes@2
$LN6@inflateRes@2:

; 147  :         wrap = (windowBits >> 4) + 1;

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  00042	c1 f9 04	 sar	 ecx, 4
  00045	83 c1 01	 add	 ecx, 1
  00048	89 4d fc	 mov	 DWORD PTR _wrap$[ebp], ecx

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  0004b	83 7d 0c 30	 cmp	 DWORD PTR _windowBits$[ebp], 48 ; 00000030H
  0004f	7d 09		 jge	 SHORT $LN5@inflateRes@2

; 150  :             windowBits &= 15;

  00051	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  00054	83 e2 0f	 and	 edx, 15			; 0000000fH
  00057	89 55 0c	 mov	 DWORD PTR _windowBits$[ebp], edx
$LN5@inflateRes@2:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0005a	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0005e	74 13		 je	 SHORT $LN3@inflateRes@2
  00060	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  00064	7c 06		 jl	 SHORT $LN2@inflateRes@2
  00066	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  0006a	7e 07		 jle	 SHORT $LN3@inflateRes@2
$LN2@inflateRes@2:

; 156  :         return Z_STREAM_ERROR;

  0006c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00071	eb 52		 jmp	 SHORT $LN9@inflateRes@2
$LN3@inflateRes@2:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00073	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00076	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007a	74 2e		 je	 SHORT $LN1@inflateRes@2
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0007f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00082	3b 55 0c	 cmp	 edx, DWORD PTR _windowBits$[ebp]
  00085	74 23		 je	 SHORT $LN1@inflateRes@2

; 158  :         ZFREE(strm, state->window);

  00087	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00091	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00098	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0009b	ff d2		 call	 edx
  0009d	83 c4 08	 add	 esp, 8

; 159  :         state->window = Z_NULL;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a3	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
$LN1@inflateRes@2:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _wrap$[ebp]
  000b0	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 164  :     state->wbits = (unsigned)windowBits;

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000b9	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 165  :     return inflateReset(strm);

  000bc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _inflateReset@4
$LN9@inflateRes@2:

; 166  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
PUBLIC	_inflateInit2_@16
; Function compile flags: /Odtp
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  00006	83 7d 10 00	 cmp	 DWORD PTR _version$[ebp], 0
  0000a	74 17		 je	 SHORT $LN6@inflateIni
  0000c	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  0000f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00012	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  00019	3b ca		 cmp	 ecx, edx
  0001b	75 06		 jne	 SHORT $LN6@inflateIni
  0001d	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00021	74 0a		 je	 SHORT $LN7@inflateIni
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  00023	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00028	e9 bf 00 00 00	 jmp	 $LN8@inflateIni
$LN7@inflateIni:

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002d	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00031	75 0a		 jne	 SHORT $LN5@inflateIni
  00033	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00038	e9 af 00 00 00	 jmp	 $LN8@inflateIni
$LN5@inflateIni:

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00040	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 182  :     if (strm->zalloc == (alloc_func)0) {

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0004e	75 14		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  00050	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00053	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 184  :         strm->opaque = (voidpf)0;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00067	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0006b	75 0a		 jne	 SHORT $LN3@inflateIni
  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN3@inflateIni:

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00077	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0007c	6a 01		 push	 1
  0007e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00081	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00084	51		 push	 ecx
  00085	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00088	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0008b	ff d0		 call	 eax
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00093	83 7d f8 00	 cmp	 DWORD PTR _state$[ebp], 0
  00097	75 07		 jne	 SHORT $LN2@inflateIni
  00099	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0009e	eb 4c		 jmp	 SHORT $LN8@inflateIni
$LN2@inflateIni:

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000a6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 192  :     state->window = Z_NULL;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 193  :     ret = inflateReset2(strm, windowBits);

  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000b6	51		 push	 ecx
  000b7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 _inflateReset2@8
  000c0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 194  :     if (ret != Z_OK) {

  000c3	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c7	74 20		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d0	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000d3	52		 push	 edx
  000d4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000d7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000da	ff d1		 call	 ecx
  000dc	83 c4 08	 add	 esp, 8

; 196  :         strm->state = Z_NULL;

  000df	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000e2	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN8@inflateIni:

; 199  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
PUBLIC	_inflateInit_@12
; Function compile flags: /Odtp
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  0000a	51		 push	 ecx
  0000b	6a 0f		 push	 15			; 0000000fH
  0000d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_@16

; 207  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
END
